///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.05
///////////////////////////////////////////////////////////////////////////////



//#ifndef __APPLE__
//
//#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
//#    include <X11/Xlib.h>
//#  endif
//#else
//#  ifndef HC_LARGE_IMAGES
//#    include <HALCONCpp/HalconCpp.h>
//#    include <HALCONCpp/HDevThread.h>
//#  else
//#    include <HALCONCppxl/HalconCpp.h>
//#    include <HALCONCppxl/HDevThread.h>
//#  endif
//#  include <stdio.h>
//#  include <HALCON/HpThread.h>
//#  include <CoreFoundation/CFRunLoop.h>
//#endif
#include "halconcpp/HalconCpp.h"
#include <stdio.h>
#include "halconcpp/HDevThread.h"
#include <vector>
#include <fstream>
#include <sstream>
#include <cassert>
#include <opencv2/core.hpp>
#include "configuration.hpp"
#include <Eigen/Core>
#include <fstream>
#include <iomanip>
#include <map>
#include <filesystem>
#include <Eigen/Dense>

namespace fs = std::filesystem;


#define PI 3.14159265358979323846

using namespace HalconCpp;

struct EstimatedPose
{
	std::vector<double> rotation;
	std::vector<double> translation;

	EstimatedPose(std::vector<double> p_rotation, std::vector<double> p_translation): rotation(p_rotation), translation(p_translation) {}
};

struct MatchingParams
{
	double rel_sampling_distance;
	double keypoint_fraction;
};

HTuple  gIsSinglePose;
HTuple  gTerminationButtonLabel;
HTuple  gInfoDecor;
HTuple  gInfoPos;
HTuple  gTitlePos;
HTuple  gTitleDecor;
HTuple  gAlphaDeselected;
HTuple  gDispObjOffset;
HTuple  gLabelsDecor;
HTuple  gUsesOpenGL;
HTuple ExpGetGlobalVar_gIsSinglePose(void)
{
	return gIsSinglePose;
}
void ExpSetGlobalVar_gIsSinglePose(HTuple val)
{
	gIsSinglePose = val;
}

HTuple ExpGetGlobalVar_gTerminationButtonLabel(void)
{
	return gTerminationButtonLabel;
}
void ExpSetGlobalVar_gTerminationButtonLabel(HTuple val)
{
	gTerminationButtonLabel = val;
}

HTuple ExpGetGlobalVar_gInfoDecor(void)
{
	return gInfoDecor;
}
void ExpSetGlobalVar_gInfoDecor(HTuple val)
{
	gInfoDecor = val;
}

HTuple ExpGetGlobalVar_gInfoPos(void)
{
	return gInfoPos;
}
void ExpSetGlobalVar_gInfoPos(HTuple val)
{
	gInfoPos = val;
}

HTuple ExpGetGlobalVar_gTitlePos(void)
{
	return gTitlePos;
}
void ExpSetGlobalVar_gTitlePos(HTuple val)
{
	gTitlePos = val;
}

HTuple ExpGetGlobalVar_gTitleDecor(void)
{
	return gTitleDecor;
}
void ExpSetGlobalVar_gTitleDecor(HTuple val)
{
	gTitleDecor = val;
}

HTuple ExpGetGlobalVar_gAlphaDeselected(void)
{
	return gAlphaDeselected;
}
void ExpSetGlobalVar_gAlphaDeselected(HTuple val)
{
	gAlphaDeselected = val;
}

HTuple ExpGetGlobalVar_gDispObjOffset(void)
{
	return gDispObjOffset;
}
void ExpSetGlobalVar_gDispObjOffset(HTuple val)
{
	gDispObjOffset = val;
}

HTuple ExpGetGlobalVar_gLabelsDecor(void)
{
	return gLabelsDecor;
}
void ExpSetGlobalVar_gLabelsDecor(HTuple val)
{
	gLabelsDecor = val;
}

HTuple ExpGetGlobalVar_gUsesOpenGL(void)
{
	return gUsesOpenGL;
}
void ExpSetGlobalVar_gUsesOpenGL(HTuple val)
{
	gUsesOpenGL = val;
}

// Procedure declarations 
// External procedures 
// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event(HObject ho_BackgroundImage, HTuple hv_Parameters, HTuple hv_MouseMapping,
	HTuple hv_Button, HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer,
	HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
	HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter,
	HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels,
	HTuple hv_MessageQueue, HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut,
	HTuple *hv_WindowCenteredRotationOut);
// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event_visualize_object_model_3d(HObject ho_BackgroundImage, HTuple hv_MouseMapping,
	HTuple hv_Button, HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer,
	HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
	HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter,
	HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels,
	HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut,
	HTuple *hv_WindowCenteredRotationOut);
void check_find_surface_model_params(HTuple hv_WindowHandle, HTuple hv_SurfaceModel,
	HTuple hv_ObjectModel3DScene, HTuple hv_GenParamNames, HTuple hv_GenParamValues);
void check_model_edges(HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3D, HTuple hv_WindowHandleViewpoint,
	HTuple hv_WindowHandleVisualization);
void check_mouse_over_button(HTuple hv_Parameters, HTuple hv_GraphButtonRow, HTuple hv_GraphButtonColumn,
	HTuple *hv_FoundButton);
// Chapter: Graphics / Parameters
void color_string_to_rgb(HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Parameters
void color_string_to_rgb_visualize_object_model_3d(HTuple hv_Color, HTuple *hv_RGB);
void create_visualization_message_queues(HTuple *hv_MessageQueues);
// Chapter: 3D Matching / Surface-Based
// Short Description: Inspect the parameters for surface-based matching. 
void debug_find_surface_model(HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DModel,
	HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID, HTuple *hv_CreateSurfaceModelParamName,
	HTuple *hv_CreateSurfaceModelParamValue, HTuple *hv_FindSurfaceModelParamName,
	HTuple *hv_FindSurfaceModelParamValue);
// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance(HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
	HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut);
// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance_visualize_object_model_3d(HTuple hv_ObjectModel3DID,
	HTuple hv_CamParam, HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut);
// Short Description: Closes the window if it is still open. 
void dev_close_window_if_open(HTuple hv_WindowHandle);
void dev_display_surface_matching_results(HTuple hv_WindowHandle1, HTuple hv_SurfaceMatchingResultID,
	HTuple hv_ObjectModel3DModel, HTuple hv_ObjectModel3DScene, HTuple hv_Score,
	HTuple hv_Pose, HTuple hv_EdgesTrained);
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off();
// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_buttons(HTuple hv_Parameters, HTuple hv_WindowHandle);
// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_continue_button(HTuple hv_WindowHandle);
void disp_menu_ext(HObject ho_MenuRegions, HTuple hv_WindowHandleMenu, HTuple hv_MenuText,
	HTuple hv_CasesDone, HTuple hv_CurrentCase);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl(HObject *ho_ModelContours, HTuple hv_ObjectModel3DID,
	HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer,
	HTuple hv_CamParam, HTuple hv_PosesOut);
// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl_visualize_object_model_3d(HObject *ho_ModelContours,
	HTuple hv_ObjectModel3DID, HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer,
	HTuple hv_CamParam, HTuple hv_PosesOut);
void disp_slider(HTuple hv_WindowHandle, HTuple hv_Row, HTuple hv_TotalHeight, HTuple hv_ColLabel,
	HTuple hv_ColValue, HTuple hv_ColSliderStart, HTuple hv_ColSliderEnd, HTuple hv_Label,
	HTuple hv_ValueStart, HTuple hv_ValueEnd, HTuple hv_ValueCurr, HTuple hv_FormatString);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor, HTuple hv_ButtonColor);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button_visualize_object_model_3d(HTuple hv_WindowHandle, HTuple hv_String,
	HTuple hv_CoordSystem, HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor,
	HTuple hv_ButtonColor);
// Chapter: Graphics / Output
void disp_title_and_information(HTuple hv_Parameters, HTuple hv_WindowHandle, HTuple hv_Title,
	HTuple hv_Information);
// Chapter: Graphics / Output
void disp_title_and_information_visualize_object_model_3d(HTuple hv_WindowHandle,
	HTuple hv_Title, HTuple hv_Information);
// Chapter: Graphics / Output
// Short Description: Renders 3D object models in a buffer window. 
void dump_image_output(HObject ho_BackgroundImage, HTuple hv_Parameters, HTuple hv_WindowHandleBuffer,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage,
	HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball,
	HTuple hv_DisplayButtons, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol,
	HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter,
	HTuple hv_RotationCenter, HTuple hv_Type, HTuple hv_Message, HTuple hv_DispViewPoint,
	HTuple hv_ViewPoint);
// Chapter: Graphics / Output
// Short Description: Renders 3D object models in a buffer window. 
void dump_image_output_visualize_object_model_3d(HObject ho_BackgroundImage, HTuple hv_WindowHandleBuffer,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage,
	HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball,
	HTuple hv_DisplayContinueButton, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol,
	HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter,
	HTuple hv_RotationCenter);
void estimate_noise_real(HObject ho_Image, HTuple hv_OutlierRemovalAmount, HTuple *hv_Sigma);
void estimate_visualization_pose(HTuple hv_SampledModel, HTuple hv_WindowHandleModel,
	HTuple *hv_PoseEstimated);
void estimate_visualization_pose_simple(HTuple hv_SampledModel, HTuple hv_WindowHandleModel,
	HTuple *hv_PoseEstimated);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model. 
void gen_cam_par_area_scan_division(HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx,
	HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight,
	HTuple *hv_CameraParam);
void gen_camera_facing_scene(HTuple hv_Viewpoint, HTuple hv_Center, HTuple hv_DiameterModel,
	HTuple *hv_OM3DCamera);
// Short Description: Create a 3D object model that resembles a camera 
void gen_camera_object_model_3d(HTuple hv_Pose, HTuple hv_Size, HTuple *hv_OM3DCamera);
void gen_menu_regions_ext(HObject *ho_MenuRegions, HTuple hv_TopBottom, HTuple hv_WindowHandleMenu,
	HTuple hv_PercentageHeight, HTuple hv_NumRows, HTuple hv_NumCols);
// Chapter: Calibration / Camera Parameters
// Short Description: Get the value of a specified camera parameter from the camera parameter tuple. 
void get_cam_par_data(HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue);
// Chapter: Calibration / Camera Parameters
// Short Description: Get the names of the parameters in a camera parameter tuple. 
void get_cam_par_names(HTuple hv_CameraParam, HTuple *hv_CameraType, HTuple *hv_ParamNames);
void get_find_parameter(HTuple hv_GenParamNames, HTuple hv_GenParamValues, HTuple hv_ParamName,
	HTuple hv_DefaultValue, HTuple *hv_ParamValue);
void get_image_direction(HObject ho_Image, HTuple *hv_MedianDirection);
void get_mouse_info(HTuple hv_WindowHandle, HTuple hv_MessageQueue, HTuple hv_Timeout,
	HTuple *hv_Row, HTuple *hv_Column, HTuple *hv_Button);
// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center(HTuple hv_ObjectModel3DID, HTuple *hv_Center);
// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center_visualize_object_model_3d(HTuple hv_ObjectModel3DID,
	HTuple *hv_Center);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center(HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel,
	HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center_visualize_object_model_3d(HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel,
	HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed(HTuple hv_SelectedObject, HTuple hv_TrackballCenterRow,
	HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_Scene3D,
	HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, HTuple hv_CamParam,
	HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter, HTuple *hv_TBSize);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed_visualize_object_model_3d(HTuple hv_SelectedObject,
	HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel,
	HTuple hv_Scene3D, HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer,
	HTuple hv_CamParam, HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter,
	HTuple *hv_TBSize);
void inspect_normal_direction(HObject ho_MenuRegions, HTuple hv_WindowHandle1, HTuple hv_WindowHandle2,
	HTuple hv_WindowHandleMenu, HTuple hv_SurfaceModelID, HTuple hv_Scene, HTuple hv_RelSamplingDistance,
	HTuple hv_KeyPointFraction, HTuple hv_MinScore, HTuple hv_GenParamNames, HTuple hv_GenParamValues,
	HTuple hv_SurfaceMatchingResultID, HTuple hv_MenuText, HTuple hv_CurrentCase,
	HTuple hv_CasesDone, HTuple hv_FontSize, HTuple *hv_CreateNames, HTuple *hv_CreateValues,
	HTuple *hv_FindNames, HTuple *hv_FindValues);
void inspect_scene_edge_directions(HTuple hv_WindowHandle1, HTuple hv_WindowHandle2,
	HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID,
	HTuple hv_MaxGapIn, HTuple hv_MinAmplitudeIn, HTuple hv_ViewpointIn, HTuple *hv_Viewpoint);
void inspect_scene_edge_parameters(HTuple hv_WindowHandle1, HTuple hv_WindowHandle2,
	HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID,
	HTuple hv_MaxGapIn, HTuple hv_MinAmplitudeAbsIn, HTuple hv_ViewpointIn, HTuple *hv_MaxGap,
	HTuple *hv_MinAmplitudeAbs);
// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width(HTuple hv_WindowHandle, HTuple hv_Lines, HTuple *hv_MaxWidth);
// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width_visualize_object_model_3d(HTuple hv_WindowHandle, HTuple hv_Lines,
	HTuple *hv_MaxWidth);
void process_slider_events(HTuple hv_WindowHandle, HTuple hv_MessageQueues, HTuple hv_PreviousState,
	HTuple *hv_CurrentState, HTuple *hv_DidFinish);
// Short Description: Generic processor for events of visualize_object_model_3d_ext 
void process_visualize_events_generic(HTuple hv_WindowHandle, HTuple hv_MessageQueues,
	HTuple hv_PreviousState, HTuple *hv_DidFinish, HTuple *hv_NewState, HTuple *hv_ButtonPressed,
	HTuple *hv_Poses);
// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball(HTuple hv_X, HTuple hv_Y, HTuple hv_VirtualTrackball,
	HTuple hv_TrackballSize, HTuple *hv_V);
// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball_visualize_object_model_3d(HTuple hv_X, HTuple hv_Y,
	HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple *hv_V);
void select_case(HObject ho_MenuRegions, HTuple hv_WindowHandleMenu, HTuple hv_MenuTexts,
	HTuple *hv_SelectedCase);
void send_pose_update(HTuple hv_Parameters, HTuple hv_Poses);
// Chapter: Calibration / Camera Parameters
// Short Description: Set the value of a specified camera parameter in the camera parameter tuple. 
void set_cam_par_data(HTuple hv_CameraParamIn, HTuple hv_ParamName, HTuple hv_ParamValue,
	HTuple *hv_CameraParamOut);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold,
	HTuple hv_Slant);
void set_edge_parameter_sliders(HTuple hv_WindowHandle, HTuple hv_ObjectModel3D,
	HTuple hv_MesageQueues, HTuple hv_MessageQueueOut, HTuple hv_ModelDiameter, HTuple hv_AmplitudeRange,
	HTuple hv_MaxGapRange, HTuple hv_Viewpoint, HTuple *hv_MinAmplitude, HTuple *hv_MaxGap);
// Chapter: Graphics / Output
// Short Description: Compute the 3D rotation from the mouse movement 
void trackball(HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2, HTuple hv_MY2, HTuple hv_VirtualTrackball,
	HTuple hv_TrackballSize, HTuple hv_SensFactor, HTuple *hv_QuatRotation);
// Chapter: Graphics / Output
// Short Description: Compute the 3D rotation from the mouse movement 
void trackball_visualize_object_model_3d(HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2,
	HTuple hv_MY2, HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SensFactor,
	HTuple *hv_QuatRotation);
// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product(HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC);
// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product_visualize_object_model_3d(HTuple hv_V1, HTuple hv_V2,
	HTuple *hv_VC);
// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d(HTuple hv_WindowHandle, HTuple hv_ObjectModel3D,
	HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue,
	HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple *hv_PoseOut);
// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d_ext(HTuple hv_WindowHandle, HTuple hv_ObjectModel3D,
	HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue,
	HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple hv_MessageQueue,
	HTuple hv_Buttons, HTuple hv_Type, HTuple hv_Message, HTuple hv_DispViewPoint,
	HTuple hv_ViewPoint);
// Short Description: Display continue button and wait for user to click it 
void wait_continue_button(HTuple hv_WindowHandle);
void write_note(HTuple hv_WindowHandle, HTuple hv_Type, HTuple hv_String);

// Generated stubs for parallel procedure calls. Wrapped in name
// space to avoid name conflicts with actual procedure names
namespace HDevExportCpp
{
	// Parallel execution wrapper for visualize_object_model_3d_ext(...) 
	static void* _hcppthread_visualize_object_model_3d_ext(void *hcthread);
	// Parallel execution wrapper for set_edge_parameter_sliders(...) 
	static void* _hcppthread_set_edge_parameter_sliders(void *hcthread);
}

// Procedures 
// External procedures 
// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event(HObject ho_BackgroundImage, HTuple hv_Parameters, HTuple hv_MouseMapping,
	HTuple hv_Button, HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer,
	HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
	HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter,
	HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels,
	HTuple hv_MessageQueue, HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut,
	HTuple *hv_WindowCenteredRotationOut)
{

	// Local iconic variables
	HObject  ho_ImageDump;

	// Local control variables
	HTuple  hv_VisualizeTB, hv_InvLog2, hv_Seconds;
	HTuple  hv_ModelIndex, hv_Exception1, hv_HomMat3DIdentity;
	HTuple  hv_NumModels, hv_Width, hv_Height, hv_MinImageSize;
	HTuple  hv_TrackballRadiusPixel, hv_TrackballCenterRow;
	HTuple  hv_TrackballCenterCol, hv_gIsSinglePose, hv_NumChannels;
	HTuple  hv_ColorImage, hv_BAnd, hv_SensFactor, hv_IsButtonTrans;
	HTuple  hv_IsButtonRot, hv_IsButtonDist, hv_MRow1, hv_MCol1;
	HTuple  hv_ButtonLoop, hv_MRow2, hv_MCol2, hv_PX, hv_PY;
	HTuple  hv_PZ, hv_QX1, hv_QY1, hv_QZ1, hv_QX2, hv_QY2, hv_QZ2;
	HTuple  hv_Len, hv_Dist, hv_Translate, hv_Index, hv_PoseIn;
	HTuple  hv_HomMat3DIn, hv_HomMat3DOut, hv_PoseOut, hv_Indices;
	HTuple  hv_Sequence, hv_Mod, hv_SequenceReal, hv_Sequence2Int;
	HTuple  hv_Selected, hv_InvSelected, hv_Exception, hv_DRow;
	HTuple  hv_TranslateZ, hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_RelQuaternion;
	HTuple  hv_HomMat3DRotRel, hv_HomMat3DInTmp1, hv_HomMat3DInTmp;
	HTuple  hv_PosesOut2;

	//This procedure reflects
	//- the pose change that was introduced by the user by
	//  moving the mouse
	//- the selection of a single object
	//
	(*hv_ButtonHoldOut) = hv_ButtonHoldIn;
	(*hv_PosesOut) = hv_PosesIn;
	(*hv_SelectedObjectOut) = hv_SelectedObjectIn;
	(*hv_WindowCenteredRotationOut) = hv_WindowCenteredRotationlIn;
	hv_VisualizeTB = ((*hv_SelectedObjectOut).TupleMax()) != 0;
	hv_InvLog2 = 1.0 / (HTuple(2).TupleLog());
	//
	if (0 != (hv_Button == HTuple(hv_MouseMapping[6])))
	{
		if (0 != (*hv_ButtonHoldOut))
		{
			return;
		}
		//Ctrl (16) + Alt (32) + left mouse button (1) => Toggle rotation center position
		//If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2
		CountSeconds(&hv_Seconds);
		if (0 != ((*hv_WindowCenteredRotationOut) == 1))
		{
			(*hv_WindowCenteredRotationOut) = 2;
		}
		else
		{
			(*hv_WindowCenteredRotationOut) = 1;
		}
		(*hv_ButtonHoldOut) = 1;
		return;
	}
	if (0 != (HTuple(hv_Button == HTuple(hv_MouseMapping[5])).TupleAnd((hv_ObjectModel3DID.TupleLength()) <= hv_MaxNumModels)))
	{
		if (0 != (*hv_ButtonHoldOut))
		{
			return;
		}
		//Ctrl (16) + left mouse button (1) => Select an object
		try
		{
			SetScene3dParam(hv_Scene3D, "object_index_persistence", "true");
			DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
			GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Row, hv_Column,
				"object_index", &hv_ModelIndex);
			SetScene3dParam(hv_Scene3D, "object_index_persistence", "false");
		}
		// catch (Exception1) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception1);
			//* NO OpenGL, no selection possible
			return;
		}
		if (0 != (hv_ModelIndex == -1))
		{
			//Background click:
			if (0 != (((*hv_SelectedObjectOut).TupleSum()) == ((*hv_SelectedObjectOut).TupleLength())))
			{
				//If all objects are already selected, deselect all
				(*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(), 0);
			}
			else
			{
				//Otherwise select all
				(*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(), 1);
			}
		}
		else
		{
			//Object click:
			(*hv_SelectedObjectOut)[hv_ModelIndex] = HTuple((*hv_SelectedObjectOut)[hv_ModelIndex]).TupleNot();
		}
		(*hv_ButtonHoldOut) = 1;
	}
	else
	{
		//Change the pose
		HomMat3dIdentity(&hv_HomMat3DIdentity);
		hv_NumModels = hv_ObjectModel3DID.TupleLength();
		get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
		get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
		hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
		hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize) / 2.0;
		//Set trackball fixed in the center of the window
		hv_TrackballCenterRow = hv_Height / 2;
		hv_TrackballCenterCol = hv_Width / 2;
		if (0 != ((hv_ObjectModel3DID.TupleLength())<hv_MaxNumModels))
		{
			if (0 != ((*hv_WindowCenteredRotationOut) == 1))
			{
				get_trackball_center_fixed(hv_SelectedObjectIn, hv_TrackballCenterRow, hv_TrackballCenterCol,
					hv_TrackballRadiusPixel, hv_Scene3D, hv_ObjectModel3DID, hv_PosesIn,
					hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, hv_GenParamValue,
					&hv_TBCenter, &hv_TBSize);
			}
			else
			{
				get_trackball_center(hv_SelectedObjectIn, hv_TrackballRadiusPixel, hv_ObjectModel3DID,
					hv_PosesIn, &hv_TBCenter, &hv_TBSize);
			}
		}
		if (0 != (HTuple(((*hv_SelectedObjectOut).TupleMin()) == 0).TupleAnd(((*hv_SelectedObjectOut).TupleMax()) == 1)))
		{
			//At this point, multiple objects do not necessary have the same
			//pose any more. Consequently, we have to return a tuple of poses
			//as output of visualize_object_model_3d
			hv_gIsSinglePose = 0;
			SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
		}
		CountChannels(ho_BackgroundImage, &hv_NumChannels);
		hv_ColorImage = hv_NumChannels == 3;
		//Alt (32) => lower sensitivity
		TupleRsh(hv_Button, 5, &hv_BAnd);
		if (0 != (hv_BAnd % 2))
		{
			hv_SensFactor = 0.1;
		}
		else
		{
			hv_SensFactor = 1.0;
		}
		hv_IsButtonTrans = HTuple(HTuple(hv_MouseMapping[0]) == hv_Button).TupleOr((32 + HTuple(hv_MouseMapping[0])) == hv_Button);
		hv_IsButtonRot = HTuple(HTuple(hv_MouseMapping[1]) == hv_Button).TupleOr((32 + HTuple(hv_MouseMapping[1])) == hv_Button);
		hv_IsButtonDist = HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(hv_MouseMapping[2]) == hv_Button).TupleOr((32 + HTuple(hv_MouseMapping[2])) == hv_Button)).TupleOr(HTuple(hv_MouseMapping[3]) == hv_Button)).TupleOr((32 + HTuple(hv_MouseMapping[3])) == hv_Button)).TupleOr(HTuple(hv_MouseMapping[4]) == hv_Button)).TupleOr((32 + HTuple(hv_MouseMapping[4])) == hv_Button);
		if (0 != hv_IsButtonTrans)
		{
			//Translate in XY-direction
			hv_MRow1 = hv_Row;
			hv_MCol1 = hv_Column;
			while (0 != hv_IsButtonTrans)
			{
				try
				{
					get_mouse_info(hv_WindowHandle, hv_MessageQueue, HTuple(), &hv_Row, &hv_Column,
						&hv_ButtonLoop);
					hv_IsButtonTrans = hv_ButtonLoop == hv_Button;
					hv_MRow2 = hv_MRow1 + ((hv_Row - hv_MRow1)*hv_SensFactor);
					hv_MCol2 = hv_MCol1 + ((hv_Column - hv_MCol1)*hv_SensFactor);
					GetLineOfSight(hv_MRow1, hv_MCol1, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ,
						&hv_QX1, &hv_QY1, &hv_QZ1);
					GetLineOfSight(hv_MRow2, hv_MCol2, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ,
						&hv_QX2, &hv_QY2, &hv_QZ2);
					hv_Len = (((hv_QX1*hv_QX1) + (hv_QY1*hv_QY1)) + (hv_QZ1*hv_QZ1)).TupleSqrt();
					hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0])) + (HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1]))) + (HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
					hv_Translate = ((((hv_QX2 - hv_QX1).TupleConcat(hv_QY2 - hv_QY1)).TupleConcat(hv_QZ2 - hv_QZ1))*hv_Dist) / hv_Len;
					(*hv_PosesOut) = HTuple();
					if (0 != (hv_NumModels <= hv_MaxNumModels))
					{
						{
							HTuple end_val109 = hv_NumModels - 1;
							HTuple step_val109 = 1;
							for (hv_Index = 0; hv_Index.Continue(end_val109, step_val109); hv_Index += step_val109)
							{
								hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
								if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
								{
									PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]),
										HTuple(hv_Translate[2]), &hv_HomMat3DOut);
									HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
									SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
								}
								else
								{
									hv_PoseOut = hv_PoseIn;
								}
								(*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
							}
						}
					}
					else
					{
						TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
						hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0]) * 7, (HTuple(hv_Indices[0]) * 7) + 6);
						PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
						HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]),
							HTuple(hv_Translate[2]), &hv_HomMat3DOut);
						HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
						hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
						TupleMod(hv_Sequence, 7, &hv_Mod);
						hv_SequenceReal = HTuple::TupleGenSequence(0, hv_NumModels - (1.0 / 7.0), 1.0 / 7.0);
						hv_Sequence2Int = hv_SequenceReal.TupleInt();
						TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
						hv_InvSelected = 1 - hv_Selected;
						TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
						(*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected) + (hv_PosesIn*hv_InvSelected);
						SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0, hv_NumModels - 1, 1),
							(*hv_PosesOut));
					}
					dump_image_output(ho_BackgroundImage, hv_Parameters, hv_WindowHandleBuffer,
						hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue,
						hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information,
						hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol,
						hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut) == 1,
						hv_TBCenter, HTuple(), HTuple(), HTuple(), HTuple());
					DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
					//dev_set_window (WindowHandle)
					//dev_display (ImageDump)
					DispObj(ho_ImageDump, hv_WindowHandle);
					send_pose_update(hv_Parameters, (*hv_PosesOut));
					//
					hv_MRow1 = hv_Row;
					hv_MCol1 = hv_Column;
					hv_PosesIn = (*hv_PosesOut);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
		}
		else if (0 != hv_IsButtonDist)
		{
			//Change the Z distance
			hv_MRow1 = hv_Row;
			while (0 != hv_IsButtonDist)
			{
				try
				{
					get_mouse_info(hv_WindowHandle, hv_MessageQueue, HTuple(), &hv_Row, &hv_Column,
						&hv_ButtonLoop);
					hv_IsButtonDist = hv_ButtonLoop == hv_Button;
					hv_MRow2 = hv_Row;
					hv_DRow = hv_MRow2 - hv_MRow1;
					hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0])) + (HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1]))) + (HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
					hv_TranslateZ = (((-hv_Dist)*hv_DRow)*0.003)*hv_SensFactor;
					hv_TBCenter[2] = HTuple(hv_TBCenter[2]) + hv_TranslateZ;
					(*hv_PosesOut) = HTuple();
					if (0 != (hv_NumModels <= hv_MaxNumModels))
					{
						{
							HTuple end_val165 = hv_NumModels - 1;
							HTuple step_val165 = 1;
							for (hv_Index = 0; hv_Index.Continue(end_val165, step_val165); hv_Index += step_val165)
							{
								hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
								if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
								{
									//Transform the whole scene or selected object only
									PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
									HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
									SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
								}
								else
								{
									hv_PoseOut = hv_PoseIn;
								}
								(*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
							}
						}
					}
					else
					{
						TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
						hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0]) * 7, (HTuple(hv_Indices[0]) * 7) + 6);
						PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
						HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
						HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
						hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
						TupleMod(hv_Sequence, 7, &hv_Mod);
						hv_SequenceReal = HTuple::TupleGenSequence(0, hv_NumModels - (1.0 / 7.0), 1.0 / 7.0);
						hv_Sequence2Int = hv_SequenceReal.TupleInt();
						TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
						hv_InvSelected = 1 - hv_Selected;
						TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
						(*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected) + (hv_PosesIn*hv_InvSelected);
						SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0, hv_NumModels - 1, 1),
							(*hv_PosesOut));
					}
					dump_image_output(ho_BackgroundImage, hv_Parameters, hv_WindowHandleBuffer,
						hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue,
						hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information,
						hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol,
						hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut),
						hv_TBCenter, HTuple(), HTuple(), HTuple(), HTuple());
					DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
					//dev_set_window (WindowHandle)
					//dev_display (ImageDump)
					DispObj(ho_ImageDump, hv_WindowHandle);
					send_pose_update(hv_Parameters, (*hv_PosesOut));
					//
					hv_MRow1 = hv_Row;
					hv_PosesIn = (*hv_PosesOut);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
		}
		else if (0 != hv_IsButtonRot)
		{
			//Rotate the object
			hv_MRow1 = hv_Row;
			hv_MCol1 = hv_Column;
			while (0 != hv_IsButtonRot)
			{
				try
				{
					get_mouse_info(hv_WindowHandle, hv_MessageQueue, HTuple(), &hv_Row, &hv_Column,
						&hv_ButtonLoop);
					hv_IsButtonRot = hv_ButtonLoop == hv_Button;
					hv_MRow2 = hv_Row;
					hv_MCol2 = hv_Column;
					//Transform the pixel coordinates to relative image coordinates
					hv_MX1 = (hv_TrackballCenterCol - hv_MCol1) / (0.5*hv_MinImageSize);
					hv_MY1 = (hv_TrackballCenterRow - hv_MRow1) / (0.5*hv_MinImageSize);
					hv_MX2 = (hv_TrackballCenterCol - hv_MCol2) / (0.5*hv_MinImageSize);
					hv_MY2 = (hv_TrackballCenterRow - hv_MRow2) / (0.5*hv_MinImageSize);
					//Compute the quaternion rotation that corresponds to the mouse
					//movement
					trackball(hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize,
						hv_SensFactor, &hv_RelQuaternion);
					//Transform the quaternion to a rotation matrix
					QuatToHomMat3d(hv_RelQuaternion, &hv_HomMat3DRotRel);
					(*hv_PosesOut) = HTuple();
					if (0 != (hv_NumModels <= hv_MaxNumModels))
					{
						{
							HTuple end_val229 = hv_NumModels - 1;
							HTuple step_val229 = 1;
							for (hv_Index = 0; hv_Index.Continue(end_val229, step_val229); hv_Index += step_val229)
							{
								hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
								if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
								{
									//Transform the whole scene or selected object only
									PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]),
										-HTuple(hv_TBCenter[2]), &hv_HomMat3DIn);
									HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]),
										HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
									HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
									SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
								}
								else
								{
									hv_PoseOut = hv_PoseIn;
								}
								(*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
							}
						}
					}
					else
					{
						TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
						hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0]) * 7, (HTuple(hv_Indices[0]) * 7) + 6);
						PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
						HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]),
							-HTuple(hv_TBCenter[2]), &hv_HomMat3DInTmp1);
						HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DInTmp1, &hv_HomMat3DInTmp);
						HomMat3dTranslate(hv_HomMat3DInTmp, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]),
							HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
						HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
						hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
						TupleMod(hv_Sequence, 7, &hv_Mod);
						hv_SequenceReal = HTuple::TupleGenSequence(0, hv_NumModels - (1.0 / 7.0), 1.0 / 7.0);
						hv_Sequence2Int = hv_SequenceReal.TupleInt();
						TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
						hv_InvSelected = 1 - hv_Selected;
						TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
						hv_PosesOut2 = ((*hv_PosesOut)*hv_Selected) + (hv_PosesIn*hv_InvSelected);
						(*hv_PosesOut) = hv_PosesOut2;
						SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0, hv_NumModels - 1, 1),
							(*hv_PosesOut));
					}
					dump_image_output(ho_BackgroundImage, hv_Parameters, hv_WindowHandleBuffer,
						hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue,
						hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information,
						hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol,
						hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut),
						hv_TBCenter, HTuple(), HTuple(), HTuple(), HTuple());
					DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
					//dev_set_window (WindowHandle)
					//dev_display (ImageDump)
					DispObj(ho_ImageDump, hv_WindowHandle);
					send_pose_update(hv_Parameters, (*hv_PosesOut));
					//
					hv_MRow1 = hv_Row;
					hv_MCol1 = hv_Column;
					hv_PosesIn = (*hv_PosesOut);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
		}
		(*hv_PosesOut) = hv_PosesIn;
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event_visualize_object_model_3d(HObject ho_BackgroundImage, HTuple hv_MouseMapping,
	HTuple hv_Button, HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer,
	HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
	HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter,
	HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels,
	HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut,
	HTuple *hv_WindowCenteredRotationOut)
{

	// Local iconic variables
	HObject  ho_ImageDump;

	// Local control variables
	HTuple  ExpTmpLocalVar_gIsSinglePose, hv_VisualizeTB;
	HTuple  hv_InvLog2, hv_Seconds, hv_ModelIndex, hv_Exception1;
	HTuple  hv_HomMat3DIdentity, hv_NumModels, hv_Width, hv_Height;
	HTuple  hv_MinImageSize, hv_TrackballRadiusPixel, hv_TrackballCenterRow;
	HTuple  hv_TrackballCenterCol, hv_NumChannels, hv_ColorImage;
	HTuple  hv_BAnd, hv_SensFactor, hv_IsButtonTrans, hv_IsButtonRot;
	HTuple  hv_IsButtonDist, hv_MRow1, hv_MCol1, hv_ButtonLoop;
	HTuple  hv_MRow2, hv_MCol2, hv_PX, hv_PY, hv_PZ, hv_QX1;
	HTuple  hv_QY1, hv_QZ1, hv_QX2, hv_QY2, hv_QZ2, hv_Len;
	HTuple  hv_Dist, hv_Translate, hv_Index, hv_PoseIn, hv_HomMat3DIn;
	HTuple  hv_HomMat3DOut, hv_PoseOut, hv_Indices, hv_Sequence;
	HTuple  hv_Mod, hv_SequenceReal, hv_Sequence2Int, hv_Selected;
	HTuple  hv_InvSelected, hv_Exception, hv_DRow, hv_TranslateZ;
	HTuple  hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_RelQuaternion;
	HTuple  hv_HomMat3DRotRel, hv_HomMat3DInTmp1, hv_HomMat3DInTmp;
	HTuple  hv_PosesOut2;

	//This procedure reflects
	//- the pose change that was introduced by the user by
	//  moving the mouse
	//- the selection of a single object
	//
	//global tuple gIsSinglePose
	//
	(*hv_ButtonHoldOut) = hv_ButtonHoldIn;
	(*hv_PosesOut) = hv_PosesIn;
	(*hv_SelectedObjectOut) = hv_SelectedObjectIn;
	(*hv_WindowCenteredRotationOut) = hv_WindowCenteredRotationlIn;
	hv_VisualizeTB = ((*hv_SelectedObjectOut).TupleMax()) != 0;
	hv_InvLog2 = 1.0 / (HTuple(2).TupleLog());
	//
	if (0 != (hv_Button == HTuple(hv_MouseMapping[6])))
	{
		if (0 != (*hv_ButtonHoldOut))
		{
			return;
		}
		//Ctrl (16) + Alt (32) + left mouse button (1) => Toggle rotation center position
		//If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2
		CountSeconds(&hv_Seconds);
		if (0 != ((*hv_WindowCenteredRotationOut) == 1))
		{
			(*hv_WindowCenteredRotationOut) = 2;
		}
		else
		{
			(*hv_WindowCenteredRotationOut) = 1;
		}
		(*hv_ButtonHoldOut) = 1;
		return;
	}
	if (0 != (HTuple(hv_Button == HTuple(hv_MouseMapping[5])).TupleAnd((hv_ObjectModel3DID.TupleLength()) <= hv_MaxNumModels)))
	{
		if (0 != (*hv_ButtonHoldOut))
		{
			return;
		}
		//Ctrl (16) + left mouse button (1) => Select an object
		try
		{
			SetScene3dParam(hv_Scene3D, "object_index_persistence", "true");
			DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
			GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Row, hv_Column,
				"object_index", &hv_ModelIndex);
			SetScene3dParam(hv_Scene3D, "object_index_persistence", "false");
		}
		// catch (Exception1) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception1);
			//* NO OpenGL, no selection possible
			return;
		}
		if (0 != (hv_ModelIndex == -1))
		{
			//Background click:
			if (0 != (((*hv_SelectedObjectOut).TupleSum()) == ((*hv_SelectedObjectOut).TupleLength())))
			{
				//If all objects are already selected, deselect all
				(*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(), 0);
			}
			else
			{
				//Otherwise select all
				(*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(), 1);
			}
		}
		else
		{
			//Object click:
			(*hv_SelectedObjectOut)[hv_ModelIndex] = HTuple((*hv_SelectedObjectOut)[hv_ModelIndex]).TupleNot();
		}
		(*hv_ButtonHoldOut) = 1;
	}
	else
	{
		//Change the pose
		HomMat3dIdentity(&hv_HomMat3DIdentity);
		hv_NumModels = hv_ObjectModel3DID.TupleLength();
		get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
		get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
		hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
		hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize) / 2.0;
		//Set trackball fixed in the center of the window
		hv_TrackballCenterRow = hv_Height / 2;
		hv_TrackballCenterCol = hv_Width / 2;
		if (0 != ((hv_ObjectModel3DID.TupleLength())<hv_MaxNumModels))
		{
			if (0 != ((*hv_WindowCenteredRotationOut) == 1))
			{
				get_trackball_center_fixed_visualize_object_model_3d(hv_SelectedObjectIn,
					hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel,
					hv_Scene3D, hv_ObjectModel3DID, hv_PosesIn, hv_WindowHandleBuffer, hv_CamParam,
					hv_GenParamName, hv_GenParamValue, &hv_TBCenter, &hv_TBSize);
			}
			else
			{
				get_trackball_center_visualize_object_model_3d(hv_SelectedObjectIn, hv_TrackballRadiusPixel,
					hv_ObjectModel3DID, hv_PosesIn, &hv_TBCenter, &hv_TBSize);
			}
		}
		if (0 != (HTuple(((*hv_SelectedObjectOut).TupleMin()) == 0).TupleAnd(((*hv_SelectedObjectOut).TupleMax()) == 1)))
		{
			//At this point, multiple objects do not necessary have the same
			//pose any more. Consequently, we have to return a tuple of poses
			//as output of visualize_object_model_3d
			ExpTmpLocalVar_gIsSinglePose = 0;
			ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
		}
		CountChannels(ho_BackgroundImage, &hv_NumChannels);
		hv_ColorImage = hv_NumChannels == 3;
		//Alt (32) => lower sensitivity
		TupleRsh(hv_Button, 5, &hv_BAnd);
		if (0 != (hv_BAnd % 2))
		{
			hv_SensFactor = 0.1;
		}
		else
		{
			hv_SensFactor = 1.0;
		}
		hv_IsButtonTrans = HTuple(HTuple(hv_MouseMapping[0]) == hv_Button).TupleOr((32 + HTuple(hv_MouseMapping[0])) == hv_Button);
		hv_IsButtonRot = HTuple(HTuple(hv_MouseMapping[1]) == hv_Button).TupleOr((32 + HTuple(hv_MouseMapping[1])) == hv_Button);
		hv_IsButtonDist = HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(hv_MouseMapping[2]) == hv_Button).TupleOr((32 + HTuple(hv_MouseMapping[2])) == hv_Button)).TupleOr(HTuple(hv_MouseMapping[3]) == hv_Button)).TupleOr((32 + HTuple(hv_MouseMapping[3])) == hv_Button)).TupleOr(HTuple(hv_MouseMapping[4]) == hv_Button)).TupleOr((32 + HTuple(hv_MouseMapping[4])) == hv_Button);
		if (0 != hv_IsButtonTrans)
		{
			//Translate in XY-direction
			hv_MRow1 = hv_Row;
			hv_MCol1 = hv_Column;
			while (0 != hv_IsButtonTrans)
			{
				try
				{
					GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
					hv_IsButtonTrans = hv_ButtonLoop == hv_Button;
					hv_MRow2 = hv_MRow1 + ((hv_Row - hv_MRow1)*hv_SensFactor);
					hv_MCol2 = hv_MCol1 + ((hv_Column - hv_MCol1)*hv_SensFactor);
					GetLineOfSight(hv_MRow1, hv_MCol1, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ,
						&hv_QX1, &hv_QY1, &hv_QZ1);
					GetLineOfSight(hv_MRow2, hv_MCol2, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ,
						&hv_QX2, &hv_QY2, &hv_QZ2);
					hv_Len = (((hv_QX1*hv_QX1) + (hv_QY1*hv_QY1)) + (hv_QZ1*hv_QZ1)).TupleSqrt();
					hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0])) + (HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1]))) + (HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
					hv_Translate = ((((hv_QX2 - hv_QX1).TupleConcat(hv_QY2 - hv_QY1)).TupleConcat(hv_QZ2 - hv_QZ1))*hv_Dist) / hv_Len;
					(*hv_PosesOut) = HTuple();
					if (0 != (hv_NumModels <= hv_MaxNumModels))
					{
						{
							HTuple end_val110 = hv_NumModels - 1;
							HTuple step_val110 = 1;
							for (hv_Index = 0; hv_Index.Continue(end_val110, step_val110); hv_Index += step_val110)
							{
								hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
								if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
								{
									PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]),
										HTuple(hv_Translate[2]), &hv_HomMat3DOut);
									HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
									SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
								}
								else
								{
									hv_PoseOut = hv_PoseIn;
								}
								(*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
							}
						}
					}
					else
					{
						TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
						hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0]) * 7, (HTuple(hv_Indices[0]) * 7) + 6);
						PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
						HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]),
							HTuple(hv_Translate[2]), &hv_HomMat3DOut);
						HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
						hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
						TupleMod(hv_Sequence, 7, &hv_Mod);
						hv_SequenceReal = HTuple::TupleGenSequence(0, hv_NumModels - (1.0 / 7.0), 1.0 / 7.0);
						hv_Sequence2Int = hv_SequenceReal.TupleInt();
						TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
						hv_InvSelected = 1 - hv_Selected;
						TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
						(*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected) + (hv_PosesIn*hv_InvSelected);
						SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0, hv_NumModels - 1, 1),
							(*hv_PosesOut));
					}
					dump_image_output_visualize_object_model_3d(ho_BackgroundImage, hv_WindowHandleBuffer,
						hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue,
						hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information,
						hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol,
						hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut) == 1,
						hv_TBCenter);
					DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
					HDevWindowStack::SetActive(hv_WindowHandle);
					if (HDevWindowStack::IsOpen())
						DispObj(ho_ImageDump, HDevWindowStack::GetActive());
					//
					hv_MRow1 = hv_Row;
					hv_MCol1 = hv_Column;
					hv_PosesIn = (*hv_PosesOut);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
		}
		else if (0 != hv_IsButtonDist)
		{
			//Change the Z distance
			hv_MRow1 = hv_Row;
			while (0 != hv_IsButtonDist)
			{
				try
				{
					GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
					hv_IsButtonDist = hv_ButtonLoop == hv_Button;
					hv_MRow2 = hv_Row;
					hv_DRow = hv_MRow2 - hv_MRow1;
					hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0])) + (HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1]))) + (HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
					hv_TranslateZ = (((-hv_Dist)*hv_DRow)*0.003)*hv_SensFactor;
					hv_TBCenter[2] = HTuple(hv_TBCenter[2]) + hv_TranslateZ;
					(*hv_PosesOut) = HTuple();
					if (0 != (hv_NumModels <= hv_MaxNumModels))
					{
						{
							HTuple end_val164 = hv_NumModels - 1;
							HTuple step_val164 = 1;
							for (hv_Index = 0; hv_Index.Continue(end_val164, step_val164); hv_Index += step_val164)
							{
								hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
								if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
								{
									//Transform the whole scene or selected object only
									PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
									HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
									SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
								}
								else
								{
									hv_PoseOut = hv_PoseIn;
								}
								(*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
							}
						}
					}
					else
					{
						TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
						hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0]) * 7, (HTuple(hv_Indices[0]) * 7) + 6);
						PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
						HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
						HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
						hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
						TupleMod(hv_Sequence, 7, &hv_Mod);
						hv_SequenceReal = HTuple::TupleGenSequence(0, hv_NumModels - (1.0 / 7.0), 1.0 / 7.0);
						hv_Sequence2Int = hv_SequenceReal.TupleInt();
						TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
						hv_InvSelected = 1 - hv_Selected;
						TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
						(*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected) + (hv_PosesIn*hv_InvSelected);
						SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0, hv_NumModels - 1, 1),
							(*hv_PosesOut));
					}
					dump_image_output_visualize_object_model_3d(ho_BackgroundImage, hv_WindowHandleBuffer,
						hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue,
						hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information,
						hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol,
						hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut),
						hv_TBCenter);
					DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
					HDevWindowStack::SetActive(hv_WindowHandle);
					if (HDevWindowStack::IsOpen())
						DispObj(ho_ImageDump, HDevWindowStack::GetActive());
					//
					hv_MRow1 = hv_Row;
					hv_PosesIn = (*hv_PosesOut);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
		}
		else if (0 != hv_IsButtonRot)
		{
			//Rotate the object
			hv_MRow1 = hv_Row;
			hv_MCol1 = hv_Column;
			while (0 != hv_IsButtonRot)
			{
				try
				{
					GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
					hv_IsButtonRot = hv_ButtonLoop == hv_Button;
					hv_MRow2 = hv_Row;
					hv_MCol2 = hv_Column;
					//Transform the pixel coordinates to relative image coordinates
					hv_MX1 = (hv_TrackballCenterCol - hv_MCol1) / (0.5*hv_MinImageSize);
					hv_MY1 = (hv_TrackballCenterRow - hv_MRow1) / (0.5*hv_MinImageSize);
					hv_MX2 = (hv_TrackballCenterCol - hv_MCol2) / (0.5*hv_MinImageSize);
					hv_MY2 = (hv_TrackballCenterRow - hv_MRow2) / (0.5*hv_MinImageSize);
					//Compute the quaternion rotation that corresponds to the mouse
					//movement
					trackball_visualize_object_model_3d(hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_VirtualTrackball,
						hv_TrackballSize, hv_SensFactor, &hv_RelQuaternion);
					//Transform the quaternion to a rotation matrix
					QuatToHomMat3d(hv_RelQuaternion, &hv_HomMat3DRotRel);
					(*hv_PosesOut) = HTuple();
					if (0 != (hv_NumModels <= hv_MaxNumModels))
					{
						{
							HTuple end_val226 = hv_NumModels - 1;
							HTuple step_val226 = 1;
							for (hv_Index = 0; hv_Index.Continue(end_val226, step_val226); hv_Index += step_val226)
							{
								hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
								if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
								{
									//Transform the whole scene or selected object only
									PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]),
										-HTuple(hv_TBCenter[2]), &hv_HomMat3DIn);
									HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DIn, &hv_HomMat3DIn);
									HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]),
										HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
									HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
									SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
								}
								else
								{
									hv_PoseOut = hv_PoseIn;
								}
								(*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
							}
						}
					}
					else
					{
						TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
						hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0]) * 7, (HTuple(hv_Indices[0]) * 7) + 6);
						PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
						HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]),
							-HTuple(hv_TBCenter[2]), &hv_HomMat3DInTmp1);
						HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DInTmp1, &hv_HomMat3DInTmp);
						HomMat3dTranslate(hv_HomMat3DInTmp, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]),
							HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
						HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
						hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
						TupleMod(hv_Sequence, 7, &hv_Mod);
						hv_SequenceReal = HTuple::TupleGenSequence(0, hv_NumModels - (1.0 / 7.0), 1.0 / 7.0);
						hv_Sequence2Int = hv_SequenceReal.TupleInt();
						TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
						hv_InvSelected = 1 - hv_Selected;
						TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
						hv_PosesOut2 = ((*hv_PosesOut)*hv_Selected) + (hv_PosesIn*hv_InvSelected);
						(*hv_PosesOut) = hv_PosesOut2;
						SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0, hv_NumModels - 1, 1),
							(*hv_PosesOut));
					}
					dump_image_output_visualize_object_model_3d(ho_BackgroundImage, hv_WindowHandleBuffer,
						hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue,
						hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information,
						hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol,
						hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut),
						hv_TBCenter);
					DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
					HDevWindowStack::SetActive(hv_WindowHandle);
					if (HDevWindowStack::IsOpen())
						DispObj(ho_ImageDump, HDevWindowStack::GetActive());
					//
					hv_MRow1 = hv_Row;
					hv_MCol1 = hv_Column;
					hv_PosesIn = (*hv_PosesOut);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
		}
		(*hv_PosesOut) = hv_PosesIn;
	}
	return;
}

void check_find_surface_model_params(HTuple hv_WindowHandle, HTuple hv_SurfaceModel,
	HTuple hv_ObjectModel3DScene, HTuple hv_GenParamNames, HTuple hv_GenParamValues)
{

	// Local iconic variables
	HObject  ho_X, ho_Y, ho_Z;

	// Local control variables
	HTuple  hv_DiameterModel, hv_Exception, hv_NumScenePoints;
	HTuple  hv_HasTriangles, hv_HasPolygons, hv_HasMapping;
	HTuple  hv_HasPointNormals, hv_NumPointsScene, hv_PX, hv_PY;
	HTuple  hv_PZ, hv_BBox, hv_DiameterScene, hv_CenterScene;
	HTuple  hv_EdgesTrained, hv_CenterModel, hv_HasCamPar, hv_CamPar;
	HTuple  hv_SizesOK, hv_IsNaN, hv_LargeNum, hv_Inf, hv_IsInf;
	HTuple  hv_DistThreshold, hv_NumNeighbors, hv_MaxNumNeighbors;
	HTuple  hv_Pos, hv_MedianDensity, hv_NormalsGood, hv_MLSNormals;
	HTuple  hv_NormalPos, hv_CheckNormals, hv_NX, hv_NY, hv_NZ;
	HTuple  hv_Length, hv_LengthOne, hv_LengthNotOne, hv_Rows;
	HTuple  hv_Cols, hv_MappingAsString, hv_CenterFromOrigin;
	HTuple  hv_CenterToDiameter, hv_NumSparsePoints, hv_MedianDirectionX;
	HTuple  hv_MedianDirectionXNorm, hv_MedianDirectionY, hv_MedianDirectionYNorm;
	HTuple  hv_ErrorX, hv_ErrorY, hv_DistanceOriginRel, hv_OM3D3DEdges;
	HTuple  hv_ViewpointString, hv_Viewpoint, hv_ViewpointToCenter;
	HTuple  hv_ZSigmaAbs, hv_ZSigmaRel, hv_ZSigmaPct;

	write_note(hv_WindowHandle, "none", "Checking parameters for find_surface_model[_image]...");
	NewLine(hv_WindowHandle);

	//*****************************************************************
	//Basic Parameter Checks
	//*****************************************************************
	if (0 != (HTuple((hv_SurfaceModel.TupleLength()) != 1).TupleOr((hv_ObjectModel3DScene.TupleLength()) != 1)))
	{
		write_note(hv_WindowHandle, "error", "Invalid number of surface model or scenes");
	}
	else
	{
		try
		{
			GetSurfaceModelParam(hv_SurfaceModel, "diameter", &hv_DiameterModel);
		}
		// catch (Exception) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception);
			write_note(hv_WindowHandle, "error", "Invalid surface model (nor a valid surface model handle)");
		}
		try
		{
			GetObjectModel3dParams(hv_ObjectModel3DScene, "num_points", &hv_NumScenePoints);
		}
		// catch (Exception) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception);
			write_note(hv_WindowHandle, "error", "Invalid scene (not a valid 3D object model handle)");
		}
		write_note(hv_WindowHandle, "ok", "Semantic types of parameters are OK");
	}

	if (0 != (hv_NumScenePoints<20))
	{
		write_note(hv_WindowHandle, "warning", (("The scene contains only " + hv_NumScenePoints) + " point(s). ") + "Some tests might be disabled.");
	}
	else
	{
		write_note(hv_WindowHandle, "ok", ("Number of scene points OK (Total number: " + hv_NumScenePoints) + ")");
	}


	GetObjectModel3dParams(hv_ObjectModel3DScene, "has_triangles", &hv_HasTriangles);
	GetObjectModel3dParams(hv_ObjectModel3DScene, "has_polygons", &hv_HasPolygons);
	GetObjectModel3dParams(hv_ObjectModel3DScene, "has_xyz_mapping", &hv_HasMapping);
	GetObjectModel3dParams(hv_ObjectModel3DScene, "has_point_normals", &hv_HasPointNormals);
	GetObjectModel3dParams(hv_ObjectModel3DScene, "num_points", &hv_NumPointsScene);
	try
	{
		GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_x", &hv_PX);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_y", &hv_PY);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_z", &hv_PZ);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "bounding_box1", &hv_BBox);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "diameter", &hv_DiameterScene);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "center", &hv_CenterScene);
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		//No points
		hv_PX = HTuple();
		hv_PY = HTuple();
		hv_PZ = HTuple();
		hv_BBox.Clear();
		hv_BBox[0] = 0;
		hv_BBox[1] = 0;
		hv_BBox[2] = 0;
		hv_BBox[3] = 0;
		hv_BBox[4] = 0;
		hv_BBox[5] = 0;
		hv_DiameterScene = 0;
		hv_CenterScene.Clear();
		hv_CenterScene[0] = 0;
		hv_CenterScene[1] = 0;
		hv_CenterScene[2] = 0;
	}

	GetSurfaceModelParam(hv_SurfaceModel, "3d_edges_trained", &hv_EdgesTrained);
	GetSurfaceModelParam(hv_SurfaceModel, "center", &hv_CenterModel);

	hv_HasCamPar = 0;
	try
	{
		GetSurfaceModelParam(hv_SurfaceModel, "camera_parameter", &hv_CamPar);
		hv_HasCamPar = 1;
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
	}

	if (0 != hv_HasCamPar)
	{
		write_note(hv_WindowHandle, "warning", HTuple("find_surface_model_images was used. Note that the parameters for image-based refinement (camera parameters, camera pose) are not checked by this version of the procedure."));
	}


	//*****************************************************************
	//Diameters
	//*****************************************************************
	hv_SizesOK = 1;
	GetSurfaceModelParam(hv_SurfaceModel, "diameter", &hv_DiameterModel);

	if (0 != (hv_DiameterScene<(0.3*hv_DiameterModel)))
	{
		write_note(hv_WindowHandle, "warning", "The diameter of the scene is very small (<30 % of model diameter)");
		hv_SizesOK = 0;
	}
	if (0 != ((hv_DiameterModel * 30)<hv_DiameterScene))
	{
		write_note(hv_WindowHandle, "warning", "The diameter of the scene is very large (more than 30 times the model diameter)");
		hv_SizesOK = 0;
	}
	if (0 != hv_SizesOK)
	{
		write_note(hv_WindowHandle, "ok", "Scene and model diameters seem to match");
	}


	//*****************************************************************
	//Check for NaN, INF in the 3D data
	//*****************************************************************
	if (0 != (hv_NumScenePoints>0))
	{
		//NaNs are the only "numbers" that are not equal to themself
		hv_IsNaN = HTuple((hv_PX.TupleNotEqualElem(hv_PX)).TupleOr(hv_PY.TupleNotEqualElem(hv_PY))).TupleOr(hv_PZ.TupleNotEqualElem(hv_PZ));
		//Inf is created by multiplying a large number a few times.
		//We cannot directly create it (with, for example, 1e500), since that
		//does not work in all language exports.
		hv_LargeNum = 1e50;
		TupleMult(hv_LargeNum, hv_LargeNum, &hv_LargeNum);
		TupleMult(hv_LargeNum, hv_LargeNum, &hv_LargeNum);
		TupleMult(hv_LargeNum, hv_LargeNum, &hv_Inf);
		hv_IsInf = HTuple(((hv_PX.TupleFabs()).TupleGreaterEqualElem(hv_Inf)).TupleOr((hv_PY.TupleFabs()).TupleGreaterEqualElem(hv_Inf))).TupleOr((hv_PZ.TupleFabs()).TupleGreaterEqualElem(hv_Inf));
		if (0 != ((HTuple(hv_IsNaN.TupleOr(hv_IsInf)).TupleSum())>0))
		{
			write_note(hv_WindowHandle, "warning", HTuple(HTuple("The scene contains ") + (HTuple(hv_IsNaN.TupleOr(hv_IsInf)).TupleSum())) + " point(s) with INF or NaN coordinates");
		}
		else
		{
			write_note(hv_WindowHandle, "ok", "No INF or NaN in data");
		}
	}


	//*****************************************************************
	//Check for other multiple points in the data
	//*****************************************************************
	hv_DistThreshold = hv_DiameterModel*1e-7;
	if (0 != (hv_NumScenePoints>0))
	{
		GetObjectModel3dParams(hv_ObjectModel3DScene, "num_neighbors_fast " + hv_DistThreshold,
			&hv_NumNeighbors);
		hv_MaxNumNeighbors = hv_NumNeighbors.TupleMax();
		if (0 != (hv_MaxNumNeighbors>30))
		{
			hv_Pos = ((const HTuple&)HTuple(hv_NumNeighbors.TupleSortIndex()))[(hv_NumNeighbors.TupleLength()) - 1];
			write_note(hv_WindowHandle, "error", (((((((("The scene point with the following coordinates seems to be duplicated around " + hv_MaxNumNeighbors) + " times: ") + "(") + HTuple(hv_PX[hv_Pos])) + HTuple(",")) + HTuple(hv_PY[hv_Pos])) + HTuple(",")) + HTuple(hv_PZ[hv_Pos])) + ")");
			write_note(hv_WindowHandle, "warning", HTuple(HTuple("Note that point duplication can generate several false positive ") + HTuple("warnings and errors! It is recommended to first fix this problem, ")) + "then to re-run this procedure");
			write_note(hv_WindowHandle, "warning", HTuple("To remove duplicate points, consider reducing the domain of the XYZ images or using select_points_object_model_3d with 'num_neighbors_fast'"));
			wait_continue_button(hv_WindowHandle);
			return;
		}
		else
		{
			write_note(hv_WindowHandle, "ok", "No duplicate point(s) detected");
		}
	}



	//*****************************************************************
	//Density of scene points
	//*****************************************************************
	//Compute the approximate scene point density
	//ATTENTION: If a point is contained multiple times in the scene,
	//           the density can be reported to be very high
	hv_DistThreshold = hv_DiameterModel*0.05;
	GetObjectModel3dParams(hv_ObjectModel3DScene, "num_neighbors_fast " + hv_DistThreshold,
		&hv_NumNeighbors);
	hv_MedianDensity = (hv_NumNeighbors*1.0).TupleMedian();

	if (0 != (hv_MedianDensity<1))
	{
		write_note(hv_WindowHandle, "warning", "The point density in the scene seems low");
	}
	else if (0 != (hv_MedianDensity>350))
	{
		write_note(hv_WindowHandle, "warning", HTuple(HTuple("The point density in the scene seems very high. ") + "This is not necessarily a problem if the sensor has a ") + "very high resolution");
	}
	else
	{
		write_note(hv_WindowHandle, "ok", "The point density in the scene looks good");
	}


	//*****************************************************************
	//Check for Scene Normals
	//
	//Normals can come from:
	//- Precomputed normal vectors (for example with surface_normals_object_model_3d)
	//- A XYZ-Mapping, used to compute the normals
	//- Setting 'scene_normal_computation' to 'mls', which is identical to using
	//  surface_normals_object_model_3d, but faster
	//*****************************************************************
	hv_NormalsGood = 0;
	hv_MLSNormals = 0;
	hv_NormalPos = hv_GenParamNames.TupleFind("scene_normal_computation");
	if (0 != (HTuple(hv_NormalPos != -1).TupleAnd(hv_NormalPos != HTuple())))
	{
		hv_MLSNormals = HTuple(hv_GenParamValues[hv_NormalPos]) == HTuple("mls");
	}

	hv_CheckNormals = 0;
	if (0 != (hv_MLSNormals == HTuple("true")))
	{
		write_note(hv_WindowHandle, "ok", "Normals computed with MLS method");
	}
	else if (0 != (hv_HasPointNormals == HTuple("true")))
	{
		write_note(hv_WindowHandle, "ok", "Scene contains normals vectors");
		hv_CheckNormals = 1;
	}
	else if (0 != (hv_HasMapping == HTuple("true")))
	{
		write_note(hv_WindowHandle, "ok", HTuple("Scene contains XYZ-Mapping, used for normal computation"));
	}
	else
	{
		write_note(hv_WindowHandle, "error", HTuple("No suitable way for computing the scene normals found (no XYZ mapping and no precomputed normals found). ") + "Please see the documentation of find_surface_model.");
	}


	//*****************************************************************
	//Check Normal Correctness
	//*****************************************************************
	if (0 != hv_CheckNormals)
	{
		GetObjectModel3dParams(hv_ObjectModel3DScene, "point_normal_x", &hv_NX);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "point_normal_y", &hv_NY);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "point_normal_z", &hv_NZ);

		hv_Length = (((hv_NX*hv_NX) + (hv_NY*hv_NY)) + (hv_NZ*hv_NZ)).TupleSqrt();
		hv_LengthOne = (((hv_Length - 1).TupleFabs()).TupleLessElem(0.05)).TupleSum();
		hv_LengthNotOne = (hv_Length.TupleLength()) - hv_LengthOne;
		if (0 != (HTuple(hv_LengthNotOne>((hv_Length.TupleLength())*0.05)).TupleOr(hv_LengthNotOne>10)))
		{
			write_note(hv_WindowHandle, "error", ((((HTuple("Scene normals do not have length 1. ") + "(") + hv_LengthOne) + HTuple(" have length ~ 1, ")) + hv_LengthNotOne) + " have not.)");
		}
		else
		{
			write_note(hv_WindowHandle, "ok", ((((HTuple("Scene normals have length 1. ") + "(") + hv_LengthOne) + HTuple(" have length ~ 1, ")) + hv_LengthNotOne) + " have not.)");
		}
	}


	//*****************************************************************
	//Check Mapping
	//
	//Avoid duplicates in the mapping, which can happen when merging
	//multiple scenes into one.
	//*****************************************************************
	if (0 != (hv_HasMapping == HTuple("true")))
	{
		GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_row", &hv_Rows);
		GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_col", &hv_Cols);
		if (0 != (HTuple(HTuple(HTuple(((hv_Rows.TupleLessElem(0)).TupleSum())>0).TupleOr(((hv_Cols.TupleLessElem(0)).TupleSum())>0)).TupleOr(((hv_Rows.TupleGreaterElem(100000)).TupleSum())>0)).TupleOr((hv_Cols.TupleGreaterElem(1000000)).TupleSum())))
		{
			write_note(hv_WindowHandle, "error", "Mapping contains invalid values (smaller zero or very large)");
		}
		else
		{
			//Search for duplicates
			hv_MappingAsString = (hv_Rows + "#") + hv_Cols;
			hv_MappingAsString = hv_MappingAsString.TupleUnion(HTuple());
			if (0 != ((hv_MappingAsString.TupleLength()) != (hv_Rows.TupleLength())))
			{
				write_note(hv_WindowHandle, "error", "Mapping contains duplicates. Maybe two scenes were merged into one?");
			}
		}
	}


	//*****************************************************************
	//Model Center
	//The model center should not be too far away from the origin.
	//Otherwise, numerical issues might worsen the result.
	//*****************************************************************
	hv_CenterFromOrigin = ((hv_CenterModel*hv_CenterModel).TupleSum()).TupleSqrt();
	hv_CenterToDiameter = hv_CenterFromOrigin / hv_DiameterModel;
	if (0 != (hv_CenterToDiameter>10))
	{
		write_note(hv_WindowHandle, "warning", ("The model center is far away from the origin (more than " + (hv_CenterToDiameter.TupleString(".0"))) + " times the diameter).");
	}
	else
	{
		write_note(hv_WindowHandle, "ok", "Model center is close to origin");
	}


	//*****************************************************************
	//Scene contains a mesh?
	//*****************************************************************
	if (0 != (HTuple(hv_HasTriangles == HTuple("true")).TupleOr(hv_HasPolygons == HTuple("true"))))
	{
		write_note(hv_WindowHandle, "warning", HTuple("Scene contains a mesh (triangles or polygons). ") + HTuple("Meshes are ignored, and only the 3D points are used during matching"));
	}
	else
	{
		write_note(hv_WindowHandle, "ok", "Scene contains no mesh (triangles or polygons)");
	}


	//*****************************************************************
	//Scene contains sparse data / points?
	//A point is 'sparse' if it has very few neighbors
	//*****************************************************************
	hv_DistThreshold = hv_DiameterModel*0.05;
	GetObjectModel3dParams(hv_ObjectModel3DScene, "num_neighbors_fast " + hv_DistThreshold,
		&hv_NumNeighbors);
	hv_NumSparsePoints = (hv_MaxNumNeighbors.TupleLessElem(3)).TupleSum();
	if (0 != (HTuple(hv_NumSparsePoints>20).TupleOr(hv_NumSparsePoints>(0.05*hv_NumScenePoints))))
	{
		write_note(hv_WindowHandle, "warning", (("Scene contains " + hv_NumSparsePoints) + " isolated point(s) that are far away from the other points. ") + "Consider removing them beforehand.");
	}
	else
	{
		write_note(hv_WindowHandle, "ok", ("Scene contains " + hv_NumSparsePoints) + " isolated point(s).");
	}


	//*****************************************************************
	//For edge-based matching, does the scene contain a mapping?
	//*****************************************************************
	if (0 != (hv_EdgesTrained == HTuple("false")))
	{
		write_note(hv_WindowHandle, "info", HTuple("Surface model was not created for edge-supported matching, ") + "skipping corresponding checks.");
	}
	else
	{
		write_note(hv_WindowHandle, "info", "Surface model was created for edge-supported matching");
	}

	if (0 != (hv_EdgesTrained == HTuple("true")))
	{
		if (0 != (hv_HasMapping == HTuple("false")))
		{
			write_note(hv_WindowHandle, "error", HTuple("Scene does not contain XYZ-Mapping, which is required for ") + "edge-supported matching.  Create the scene with xyz_to_object_model_3d instead.");
		}
		else
		{
			write_note(hv_WindowHandle, "ok", "Scene contains XYZ-Mapping");
		}
	}


	//*****************************************************************
	//For edge-based matching, is the mapping direction OK?
	//*****************************************************************
	if (0 != (HTuple(hv_EdgesTrained == HTuple("true")).TupleAnd(hv_HasMapping == HTuple("true"))))
	{
		ObjectModel3dToXyz(&ho_X, &ho_Y, &ho_Z, hv_ObjectModel3DScene, "from_xyz_map",
			HTuple(), HTuple());
		//Try to find the approximate direction in X
		get_image_direction(ho_X, &hv_MedianDirectionX);
		if (0 != ((((hv_MedianDirectionX*hv_MedianDirectionX).TupleSum()).TupleSqrt())>1e-8))
		{
			hv_MedianDirectionXNorm = hv_MedianDirectionX / (((hv_MedianDirectionX*hv_MedianDirectionX).TupleSum()).TupleSqrt());
		}
		else
		{
			hv_MedianDirectionXNorm.Clear();
			hv_MedianDirectionXNorm[0] = 0;
			hv_MedianDirectionXNorm[1] = 0;
		}
		get_image_direction(ho_Y, &hv_MedianDirectionY);
		if (0 != ((((hv_MedianDirectionY*hv_MedianDirectionY).TupleSum()).TupleSqrt())>1e-8))
		{
			hv_MedianDirectionYNorm = hv_MedianDirectionY / (((hv_MedianDirectionY*hv_MedianDirectionY).TupleSum()).TupleSqrt());
		}
		else
		{
			hv_MedianDirectionYNorm.Clear();
			hv_MedianDirectionYNorm[0] = 0;
			hv_MedianDirectionYNorm[1] = 0;
		}

		hv_ErrorX = hv_MedianDirectionXNorm - (HTuple(1).Append(0));
		hv_ErrorY = hv_MedianDirectionYNorm - (HTuple(0).Append(1));

		if (0 != (HTuple((((hv_ErrorX*hv_ErrorX).TupleSum()).TupleSqrt())>0.2).TupleOr((((hv_ErrorY*hv_ErrorY).TupleSum()).TupleSqrt())>0.2)))
		{
			write_note(hv_WindowHandle, "error", HTuple(HTuple("X or Y image of scene is not aligned with coordinate axis. ") + "This leads to incorrect edge directions and must be corrected. ") + HTuple("The X image should have increasing coordinates from left to right, the Y image from top to bottom."));
		}
		else
		{
			write_note(hv_WindowHandle, "ok", "X- and Y-Directions of mapping seem good");
		}
	}




	//*****************************************************************
	//Check if the origin is inside the data AND we would compute
	//the normals from the mapping
	//*****************************************************************
	if (0 != (HTuple(hv_HasPointNormals == HTuple("false")).TupleAnd(hv_HasMapping == HTuple("true"))))
	{
		hv_DistanceOriginRel = (((hv_CenterScene*hv_CenterScene).TupleSum()).TupleSqrt()) / hv_DiameterModel;
		if (0 != (HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(hv_BBox[0])<0).TupleAnd(HTuple(hv_BBox[1])<0)).TupleAnd(HTuple(hv_BBox[2])<0)).TupleAnd(HTuple(hv_BBox[3])>0)).TupleAnd(HTuple(hv_BBox[4])>0)).TupleAnd(HTuple(hv_BBox[5])>0)))
		{
			write_note(hv_WindowHandle, "warning", (((HTuple(HTuple("The scene origin is inside the scene data. This is problematic, since normals ") + "are computed from the mapping and oriented towards the origin. ") + "The distance from scene center to origin is ~") + (hv_DistanceOriginRel.TupleString(".1f"))) + " times the model diameter. ") + "Consider moving the scene origin to the original viewpoint of the sensor.");
		}
		else
		{
			write_note(hv_WindowHandle, "ok", ("Origin is not inside scene data. The distance from scene center to origin is ~" + (hv_DistanceOriginRel.TupleString(".1f"))) + " times the model diameter. ");
		}
	}


	//*****************************************************************
	//Check if the viewpoint is inside the data AND we compute edges internally
	//*****************************************************************
	get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edges", HTuple(), &hv_OM3D3DEdges);
	if (0 != (HTuple(hv_EdgesTrained == HTuple("true")).TupleAnd(hv_OM3D3DEdges == HTuple())))
	{
		//Obtain the viewpoint
		get_find_parameter(hv_GenParamNames, hv_GenParamValues, "viewpoint", "0 0 0",
			&hv_ViewpointString);
		hv_Viewpoint = (hv_ViewpointString.TupleSplit(" ")).TupleNumber();
		hv_ViewpointToCenter = hv_Viewpoint - hv_CenterScene;
		hv_DistanceOriginRel = (((hv_ViewpointToCenter*hv_ViewpointToCenter).TupleSum()).TupleSqrt()) / hv_DiameterModel;
		if (0 != (HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(hv_BBox[0])<0).TupleAnd(HTuple(hv_BBox[1])<0)).TupleAnd(HTuple(hv_BBox[2])<0)).TupleAnd(HTuple(hv_BBox[3])>0)).TupleAnd(HTuple(hv_BBox[4])>0)).TupleAnd(HTuple(hv_BBox[5])>0)))
		{
			write_note(hv_WindowHandle, "warning", ((HTuple("The viewpoint is inside the scene data. This is problematic, since the edge viewing directions will probably be incorrect. The distance from scene center to the viewpoint is ~") + (hv_DistanceOriginRel.TupleString(".1f"))) + " times the model diameter. ") + "Consider moving the viewpoint origin to the original viewpoint of the sensor.");
		}
		else
		{
			write_note(hv_WindowHandle, "ok", ("Viewpoint is not inside scene data. The distance from scene center to origin is ~" + (hv_DistanceOriginRel.TupleString(".1f"))) + " times the model diameter. ");
		}
	}


	//*****************************************************************
	//Check noise in Z-Direction
	//*****************************************************************
	if (0 != (hv_HasMapping == HTuple("true")))
	{
		ObjectModel3dToXyz(&ho_X, &ho_Y, &ho_Z, hv_ObjectModel3DScene, "from_xyz_map",
			HTuple(), HTuple());
		estimate_noise_real(ho_Z, 0.05, &hv_ZSigmaAbs);
		hv_ZSigmaRel = hv_ZSigmaAbs / hv_DiameterModel;
		hv_ZSigmaPct = ((hv_ZSigmaRel * 100).TupleString(".1")) + "%";
		if (0 != (hv_ZSigmaRel>0.2))
		{
			write_note(hv_WindowHandle, "error", ((("The noise in the data is very high (relative value: " + hv_ZSigmaPct) + "). ") + "Consider smoothing the Z-image with a median filter and using ") + "the mls normal estimation method.");
		}
		else if (0 != (hv_ZSigmaRel>0.1))
		{
			write_note(hv_WindowHandle, "warning", ((("The noise in the data seems rather high (relative value: " + hv_ZSigmaPct) + "). ") + "Consider smoothing the Z-image with a median filter and using ") + "the mls normal estimation method.");
		}
		else
		{
			write_note(hv_WindowHandle, "ok", ("The noise in the data looks good (relative value: " + hv_ZSigmaPct) + ")");
		}
	}
	else
	{
		//No suitable way of checking the noise (yet)
		write_note(hv_WindowHandle, "info", "Noise was not checked (requires XYZ mapping)");
	}

	//*****************************************************************
	//DONE
	//Wait for user to click continue
	//*****************************************************************
	wait_continue_button(hv_WindowHandle);

	return;

}

void check_model_edges(HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3D, HTuple hv_WindowHandleViewpoint,
	HTuple hv_WindowHandleVisualization)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_GenParamValue, hv_Instructions, hv_MessageQueues1;
	HTuple  hv_Buttons, hv_Row, hv_Column, hv_Width, hv_Height;
	HTuple  hv_CameraParam, hv_CurrentState1, hv_DiameterModel;
	HTuple  hv_CenterModel, hv_Viewpoint, hv_OM3DCamera, hv_OM3DLineSphereToModel;
	HTuple  hv_Center, hv_PoseIn, hv_CamParamVis, hv_PoseEstimated;
	HTuple  hv_MessageQueues2, hv_DirectionsShown, hv_CurrentState2;
	HTuple  hv_DidFinish1, hv_ButtonPressed, hv_Pose, hv_PoseInvert;
	HTuple  hv_Direction, hv_Length, hv_OM3DSphere, hv_OM3DModelEdges;
	HTuple  hv_EdgeDirs, hv_MessageHandle, hv_DidFinish2, hv_TIT;
	HTupleVector  hvec_TI(1);

	// +++ Threading variables 
	HDevThread*         hcppthread_handle;
	HDevThreadContext   hcppthread_context; // <-signals begin of procedure

	GetSurfaceModelParam(hv_SurfaceModelID, "diameter", &hv_GenParamValue);
	//
	hv_Instructions[0] = "Rotate: Left button";
	hv_Instructions[1] = "Zoom:   Shift + left button";
	hv_Instructions[2] = "Move:   Ctrl  + left button";
	//
	create_visualization_message_queues(&hv_MessageQueues1);
	hv_Buttons.Clear();
	hv_Buttons[0] = "Continue";
	hv_Buttons[1] = "right";
	hv_Buttons[2] = "bottom";
	hv_Buttons[3] = -1;
	hv_Buttons[4] = -1;
	GetWindowExtents(hv_WindowHandleViewpoint, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
	gen_cam_par_area_scan_division(0.008, 0, 5.2e-006, 5.2e-006, (hv_Width*0.5) + 0.5,
		(hv_Height*0.5) + 0.5, hv_Width, hv_Height, &hv_CameraParam);
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_visualize_object_model_3d_ext, 15, 0);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandleViewpoint);
	hcppthread_handle->SetInputCtrlParamTuple(1, hv_ObjectModel3D);
	hcppthread_handle->SetInputCtrlParamTuple(2, hv_CameraParam);
	hcppthread_handle->SetInputCtrlParamTuple(3, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(4, ((HTuple("disp_pose").Append("color_0")).Append("alpha_0")));
	hcppthread_handle->SetInputCtrlParamTuple(5, ((HTuple("true").Append("cyan")).Append(0.5)));
	hcppthread_handle->SetInputCtrlParamTuple(6, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(7, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(8, hv_Instructions);
	hcppthread_handle->SetInputCtrlParamTuple(9, hv_MessageQueues1);
	hcppthread_handle->SetInputCtrlParamTuple(10, hv_Buttons);
	hcppthread_handle->SetInputCtrlParamTuple(11, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(12, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(13, "false");
	hcppthread_handle->SetInputCtrlParamTuple(14, HTuple());

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[0].T());

	hv_CurrentState1 = HTuple();
	//
	GetSurfaceModelParam(hv_SurfaceModelID, "diameter", &hv_DiameterModel);
	GetSurfaceModelParam(hv_SurfaceModelID, "center", &hv_CenterModel);
	hv_Viewpoint = hv_CenterModel - (((HTuple(0).Append(0)).Append(1))*hv_DiameterModel);
	gen_camera_object_model_3d(hv_Viewpoint.TupleConcat((((HTuple(0).Append(0)).Append(0)).Append(0))),
		hv_DiameterModel*0.05, &hv_OM3DCamera);
	GenObjectModel3dFromPoints(HTuple(hv_Viewpoint[0]).TupleConcat(HTuple(hv_CenterModel[0])),
		HTuple(hv_Viewpoint[1]).TupleConcat(HTuple(hv_CenterModel[1])), HTuple(hv_Viewpoint[2]).TupleConcat(HTuple(hv_CenterModel[2])),
		&hv_OM3DLineSphereToModel);
	SetObjectModel3dAttribMod(hv_OM3DLineSphereToModel, "lines", HTuple(), ((HTuple(2).Append(0)).Append(1)));
	//
	//Find a pose for the second window such that both the model and the camer are visible,
	//from the side.
	get_object_models_center((hv_ObjectModel3D.TupleConcat(hv_OM3DCamera)).TupleConcat(hv_OM3DLineSphereToModel),
		&hv_Center);
	CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]),
		-90, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
	GetWindowExtents(hv_WindowHandleVisualization, &hv_Row, &hv_Column, &hv_Width,
		&hv_Height);
	gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width / 2, hv_Height / 2,
		hv_Width, hv_Height, &hv_CamParamVis);
	determine_optimum_pose_distance((hv_ObjectModel3D.TupleConcat(hv_OM3DCamera)).TupleConcat(hv_OM3DLineSphereToModel),
		hv_CamParamVis, 0.5, hv_PoseIn, &hv_PoseEstimated);
	//
	create_visualization_message_queues(&hv_MessageQueues2);
	hv_Buttons.Clear();
	hv_Buttons[0] = "Hide Edge Directions";
	hv_Buttons[1] = "center";
	hv_Buttons[2] = "bottom";
	hv_Buttons[3] = -1;
	hv_Buttons[4] = -1;
	hv_DirectionsShown = 1;
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_visualize_object_model_3d_ext, 15, 0);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandleVisualization);
	hcppthread_handle->SetInputCtrlParamTuple(1, ((hv_ObjectModel3D.TupleConcat(hv_ObjectModel3D)).TupleConcat(hv_OM3DCamera)).TupleConcat(hv_OM3DLineSphereToModel));
	hcppthread_handle->SetInputCtrlParamTuple(2, hv_CamParamVis);
	hcppthread_handle->SetInputCtrlParamTuple(3, hv_PoseEstimated);
	hcppthread_handle->SetInputCtrlParamTuple(4, (((((HTuple("color_0").Append("color_1")).Append("color_2")).Append("color_3")).Append("alpha_0")).Append("disp_normals_1")));
	hcppthread_handle->SetInputCtrlParamTuple(5, (((((HTuple("cyan").Append("red")).Append("gray")).Append("white")).Append(0.5)).Append("true")));
	hcppthread_handle->SetInputCtrlParamTuple(6, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(7, (((HTuple("").Append("")).Append("Viewpoint")).Append("")));
	hcppthread_handle->SetInputCtrlParamTuple(8, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(9, hv_MessageQueues2);
	hcppthread_handle->SetInputCtrlParamTuple(10, hv_Buttons);
	hcppthread_handle->SetInputCtrlParamTuple(11, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(12, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(13, "false");
	hcppthread_handle->SetInputCtrlParamTuple(14, HTuple());

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[1].T());

	hv_CurrentState2 = HTuple();
	//
	do
	{
		process_visualize_events_generic(hv_WindowHandleViewpoint, hv_MessageQueues1,
			hv_CurrentState1, &hv_DidFinish1, &hv_CurrentState1, &hv_ButtonPressed, &hv_Pose);
		if (0 != (hv_ButtonPressed == 0))
		{
			//Exit button
			break;
		}
		if (0 != (hv_Pose != HTuple()))
		{
			//The pose of view 1 was updated
			//-> Update the viewpoint in view 2
			PoseInvert(hv_Pose, &hv_PoseInvert);
			hv_Viewpoint = hv_PoseInvert.TupleSelectRange(0, 2);
			//pose_to_hom_mat3d (Pose, HomMat3D)


			//hom_mat3d_invert (HomMat3D, HomMat3DInvert)
			//affine_trans_point_3d (HomMat3DInvert, 0, 0, 0, Qx, Qy, Qz)
			//Viewpoint := [Qx,Qy,Qz]
			//With this method, the viewpoint would be very far away in view 2, leading to not-so-nice
			//visualization. Adapt the distance to be always the same.
			hv_Direction = hv_Viewpoint - hv_CenterModel;
			hv_Length = ((hv_Direction*hv_Direction).TupleSum()).TupleSqrt();
			hv_Viewpoint = hv_CenterModel + (hv_Direction*(hv_DiameterModel / hv_Length));
			//
			hv_PoseInvert[HTuple::TupleGenSequence(0, 2, 1)] = hv_Viewpoint;
			//
			gen_camera_object_model_3d(hv_PoseInvert, hv_DiameterModel*0.05, &hv_OM3DSphere);
			GenObjectModel3dFromPoints(HTuple(hv_Viewpoint[0]).TupleConcat(HTuple(hv_CenterModel[0])),
				HTuple(hv_Viewpoint[1]).TupleConcat(HTuple(hv_CenterModel[1])), HTuple(hv_Viewpoint[2]).TupleConcat(HTuple(hv_CenterModel[2])),
				&hv_OM3DLineSphereToModel);
			SetObjectModel3dAttribMod(hv_OM3DLineSphereToModel, "lines", HTuple(), ((HTuple(2).Append(0)).Append(1)));
			GetSurfaceModelParam(hv_SurfaceModelID, "edges " + ((hv_Viewpoint + " ").TupleSum()),
				&hv_OM3DModelEdges);
			//
			GetObjectModel3dParams(hv_OM3DModelEdges, HTuple("edge_dir_") + ((HTuple("x").Append("y")).Append("z")),
				&hv_EdgeDirs);
			SetObjectModel3dAttribMod(hv_OM3DModelEdges, HTuple("point_normal_") + ((HTuple("x").Append("y")).Append("z")),
				HTuple(), hv_EdgeDirs);
			//
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
			SetMessageTuple(hv_MessageHandle, "index", ((HTuple(1).Append(2)).Append(3)));
			SetMessageTuple(hv_MessageHandle, "model", (hv_OM3DModelEdges.TupleConcat(hv_OM3DSphere)).TupleConcat(hv_OM3DLineSphereToModel));
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
		}

		process_visualize_events_generic(hv_WindowHandleVisualization, hv_MessageQueues2,
			hv_CurrentState2, &hv_DidFinish2, &hv_CurrentState2, &hv_ButtonPressed, &hv_Pose);
		if (0 != (hv_ButtonPressed == 0))
		{
			hv_DirectionsShown = hv_DirectionsShown.TupleNot();
			//Toggle edge direction, using the normal vectors of the edge
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
			SetMessageTuple(hv_MessageHandle, "param", "disp_normals_1");
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
			SetMessageTuple(hv_MessageHandle, "index", 0);
			if (0 != hv_DirectionsShown)
			{
				SetMessageTuple(hv_MessageHandle, "text", "Hide Edge Directions");
			}
			else
			{
				SetMessageTuple(hv_MessageHandle, "text", "Show Edge Directions");
			}
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
		}
	} while (0 == (hv_DidFinish1.TupleOr(hv_DidFinish2)));

	//Send termination message to all subthreads
	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());

	//Wait for all subthreads to finish
	hv_TIT = hvec_TI.ConvertVectorToTuple();
	HDevThread::ParJoin(hv_TIT);
	return;
}

void check_mouse_over_button(HTuple hv_Parameters, HTuple hv_GraphButtonRow, HTuple hv_GraphButtonColumn,
	HTuple *hv_FoundButton)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_gButtons, hv_idx;

	GetMessageTuple(hv_Parameters, "gButtons", &hv_gButtons);
	(*hv_FoundButton) = -1;
	{
		HTuple end_val2 = (hv_gButtons.TupleLength()) - 1;
		HTuple step_val2 = 5;
		for (hv_idx = 0; hv_idx.Continue(end_val2, step_val2); hv_idx += step_val2)
		{
			if (0 != (HTuple(HTuple(HTuple(hv_GraphButtonRow >= (HTuple(hv_gButtons[hv_idx + 2]) - 1)).TupleAnd(hv_GraphButtonRow <= (HTuple(hv_gButtons[hv_idx + 4]) + 1))).TupleAnd(hv_GraphButtonColumn >= (HTuple(hv_gButtons[hv_idx + 1]) - 1))).TupleAnd(hv_GraphButtonColumn <= (HTuple(hv_gButtons[hv_idx + 3]) + 1))))
			{
				(*hv_FoundButton) = hv_idx;
			}
		}
	}
	return;
}

// Chapter: Graphics / Parameters
void color_string_to_rgb(HTuple hv_Color, HTuple *hv_RGB)
{

	// Local iconic variables
	HObject  ho_Rectangle, ho_Image;

	// Local control variables
	HTuple  hv_WindowHandleBuffer, hv_Exception;

	OpenWindow(0, 0, 1, 1, 0, "buffer", "", &hv_WindowHandleBuffer);
	SetPart(hv_WindowHandleBuffer, 0, 0, -1, -1);
	GenRectangle1(&ho_Rectangle, 0, 0, 0, 0);
	try
	{
		SetColor(hv_WindowHandleBuffer, hv_Color);
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		hv_Exception = "Wrong value of control parameter Color (must be a valid color string)";
		throw HException(hv_Exception);
	}
	DispObj(ho_Rectangle, hv_WindowHandleBuffer);
	DumpWindowImage(&ho_Image, hv_WindowHandleBuffer);
	CloseWindow(hv_WindowHandleBuffer);
	GetGrayval(ho_Image, 0, 0, &(*hv_RGB));
	(*hv_RGB) += ((HTuple(0).Append(0)).Append(0));
	return;
}

// Chapter: Graphics / Parameters
void color_string_to_rgb_visualize_object_model_3d(HTuple hv_Color, HTuple *hv_RGB)
{

	// Local iconic variables
	HObject  ho_Rectangle, ho_Image;

	// Local control variables
	HTuple  hv_WindowHandleBuffer, hv_Exception;

	OpenWindow(0, 0, 1, 1, 0, "buffer", "", &hv_WindowHandleBuffer);
	SetPart(hv_WindowHandleBuffer, 0, 0, -1, -1);
	GenRectangle1(&ho_Rectangle, 0, 0, 0, 0);
	try
	{
		SetColor(hv_WindowHandleBuffer, hv_Color);
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		hv_Exception = "Wrong value of control parameter Color (must be a valid color string)";
		throw HException(hv_Exception);
	}
	DispObj(ho_Rectangle, hv_WindowHandleBuffer);
	DumpWindowImage(&ho_Image, hv_WindowHandleBuffer);
	CloseWindow(hv_WindowHandleBuffer);
	GetGrayval(ho_Image, 0, 0, &(*hv_RGB));
	(*hv_RGB) += ((HTuple(0).Append(0)).Append(0));
	return;
}

void create_visualization_message_queues(HTuple *hv_MessageQueues)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_QueueHandleInMouse, hv_QueueHandleInEvents;
	HTuple  hv_QueueHandleOut;

	CreateMessageQueue(&hv_QueueHandleInMouse);
	CreateMessageQueue(&hv_QueueHandleInEvents);
	CreateMessageQueue(&hv_QueueHandleOut);
	SetMessageQueueParam(hv_QueueHandleInMouse, "max_message_num", 1);
	(*hv_MessageQueues).Clear();
	(*hv_MessageQueues).Append(hv_QueueHandleInMouse);
	(*hv_MessageQueues).Append(hv_QueueHandleInEvents);
	(*hv_MessageQueues).Append(hv_QueueHandleOut);
	return;

}

// Chapter: 3D Matching / Surface-Based
// Short Description: Inspect the parameters for surface-based matching. 
void debug_find_surface_model(HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DModel,
	HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID, HTuple *hv_CreateSurfaceModelParamName,
	HTuple *hv_CreateSurfaceModelParamValue, HTuple *hv_FindSurfaceModelParamName,
	HTuple *hv_FindSurfaceModelParamValue)
{

	// Local iconic variables
	HObject  ho_MenuRegions;

	// Local control variables
	HTuple  hv_WindowScaling, hv_WindowSize, hv_FontSize;
	HTuple  hv_WidthMenu, hv_HeightMenu, hv_WindowHandleMenu;
	HTuple  hv_Row, hv_Column, hv_Width, hv_Height, hv_HasEdges;
	HTuple  hv_MenuText, hv_MenuCode, hv_TopBottom, hv_NumCols;
	HTuple  hv_NumRows, hv_PercentageHeight, hv_CheckedCase;
	HTuple  hv_Case, hv_RowButtons0, hv_ColumnButtons0, hv_RowButtons1;
	HTuple  hv_ColumnButtons1, hv_MenuBottom, hv_RelSamplingDistance;
	HTuple  hv_KeyPointFraction, hv_MinScore, hv_GenParamNames;
	HTuple  hv_GenParamValues, hv_NumPoses, hv_Pose, hv_Score;
	HTuple  hv_Index, hv_CurrPose, hv_CurrScore, hv_Exception;
	HTuple  hv_CasesDone, hv_CurrentCase, hv_MaxGap, hv_MinAmplitudeAbs;
	HTuple  hv_Viewpoint, hv_UserProvidedEdges, hv_ModelDiameter;
	HTuple  hv_ViewpointStr, hv_MinAmplitudeRel, hv_OM3DProvidedEdges;
	HTuple  hv_NormalParamsSet, hv_Message, hv_WindowHandle1;
	HTuple  hv_WindowHandle2, hv_CreateName, hv_CreateValue;
	HTuple  hv_FindNames, hv_FindValues, hv_EdgeParamsSet;

	//Please adjust the WindowScaling parameter in order to zoom the window size as desired
	hv_WindowScaling = 1.2;
	//
	hv_WindowSize = (512 * hv_WindowScaling).TupleInt();
	hv_FontSize = 13.5*hv_WindowScaling;
	//
	hv_WidthMenu = hv_WindowSize * 2;
	hv_HeightMenu = hv_WindowSize / 3;
	//
	SetWindowAttr("background_color", "black");
	OpenWindow(0, 0, hv_WidthMenu, hv_HeightMenu, 0, "visible", "", &hv_WindowHandleMenu);
	HDevWindowStack::Push(hv_WindowHandleMenu);
	//
	GetWindowExtents(hv_WindowHandleMenu, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
	set_display_font(hv_WindowHandleMenu, hv_FontSize, "mono", "true", "false");
	//
	//Define the entries in the menu
	GetSurfaceModelParam(hv_SurfaceModelID, "3d_edges_trained", &hv_HasEdges);
	if (0 != ((hv_SurfaceMatchingResultID.TupleLength()) == 0))
	{
		if (0 != (hv_HasEdges == HTuple("true")))
		{
			hv_MenuText.Clear();
			hv_MenuText[0] = "Automatic Value Check";
			hv_MenuText[1] = "Inspect Model Edges";
			hv_MenuText[2] = "Exit";
			hv_MenuCode.Clear();
			hv_MenuCode[0] = "check";
			hv_MenuCode[1] = "model_edges";
			hv_MenuCode[2] = "exit";
		}
		else
		{
			hv_MenuText.Clear();
			hv_MenuText[0] = "Automatic Value Check";
			hv_MenuText[1] = "Normal Directions";
			hv_MenuText[2] = "Exit";
			hv_MenuCode.Clear();
			hv_MenuCode[0] = "check";
			hv_MenuCode[1] = "normals";
			hv_MenuCode[2] = "exit";
		}
	}
	else
	{
		if (0 != (hv_HasEdges == HTuple("true")))
		{
			hv_MenuText.Clear();
			hv_MenuText[0] = "Automatic Value Check";
			hv_MenuText[1] = "Inspect Model Edges";
			hv_MenuText[2] = "Normal Directions";
			hv_MenuText[3] = "3D Edge Extraction";
			hv_MenuText[4] = "3D Edge Directions";
			hv_MenuText[5] = "Matching Results";
			hv_MenuText[6] = "Exit";
			hv_MenuCode.Clear();
			hv_MenuCode[0] = "check";
			hv_MenuCode[1] = "model_edges";
			hv_MenuCode[2] = "normals";
			hv_MenuCode[3] = "scene_edge_params";
			hv_MenuCode[4] = "scene_edge_dirs";
			hv_MenuCode[5] = "results";
			hv_MenuCode[6] = "exit";
		}
		else
		{
			hv_MenuText.Clear();
			hv_MenuText[0] = "Automatic Value Check";
			hv_MenuText[1] = "Normal Directions";
			hv_MenuText[2] = "Matching Results";
			hv_MenuText[3] = "Exit";
			hv_MenuCode.Clear();
			hv_MenuCode[0] = "check";
			hv_MenuCode[1] = "normals";
			hv_MenuCode[2] = "results";
			hv_MenuCode[3] = "exit";
		}
	}
	//Generate the menu buttons
	hv_TopBottom = "top";
	hv_NumCols = 4;
	hv_NumRows = 1 + (((hv_MenuText.TupleLength()) - 1) / hv_NumCols);
	hv_PercentageHeight = 20 * hv_NumRows;
	hv_CheckedCase = hv_NumCols + 1;
	hv_Case = hv_NumCols + 1;
	gen_menu_regions_ext(&ho_MenuRegions, hv_TopBottom, hv_WindowHandleMenu, hv_PercentageHeight,
		hv_NumRows, hv_NumCols);
	//
	SmallestRectangle1(ho_MenuRegions, &hv_RowButtons0, &hv_ColumnButtons0, &hv_RowButtons1,
		&hv_ColumnButtons1);
	hv_MenuBottom = hv_RowButtons1.TupleMax();
	SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
	write_note(hv_WindowHandleMenu, "instruction", "Handlungsanweisung");
	//
	if (0 != ((hv_SurfaceMatchingResultID.TupleLength())>0))
	{
		try
		{
			GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampling_rate", 0, &hv_RelSamplingDistance);
			GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "refpt_rate", 0, &hv_KeyPointFraction);
			GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "min_score", 0, &hv_MinScore);
			GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "param_names", 0, &hv_GenParamNames);
			GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "param_values", 0, &hv_GenParamValues);
			GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "num_poses", 0, &hv_NumPoses);
			hv_Pose = HTuple();
			hv_Score = HTuple();
			{
				HTuple end_val57 = hv_NumPoses - 1;
				HTuple step_val57 = 1;
				for (hv_Index = 0; hv_Index.Continue(end_val57, step_val57); hv_Index += step_val57)
				{
					GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "pose", hv_Index, &hv_CurrPose);
					hv_Pose = hv_Pose.TupleConcat(hv_CurrPose);
					GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "score", hv_Index, &hv_CurrScore);
					hv_Score = hv_Score.TupleConcat(hv_CurrScore);
				}
			}
		}
		// catch (Exception) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception);
			//Result handle is invalid, or we are in an unsupported HALCON version
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			if (HDevWindowStack::IsOpen())
				ClearWindow(HDevWindowStack::GetActive());
			disp_message(hv_WindowHandleMenu, HTuple("Error: This version of HALCON is not supported by this procedure, or the given result handle\n was not created with find_surface_model"),
				"window", 12, 12, "red", "false");
			wait_continue_button(hv_WindowHandleMenu);
			if (HDevWindowStack::IsOpen())
				CloseWindow(HDevWindowStack::Pop());
			return;
		}
		if (0 != (hv_RelSamplingDistance == 0))
		{
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			if (HDevWindowStack::IsOpen())
				ClearWindow(HDevWindowStack::GetActive());
			disp_message(hv_WindowHandleMenu, "Error: The given result handle was not created with find_surface_model. Please pass a result handle\n created by find_surface_model.",
				"window", 12, 12, "red", "false");
			wait_continue_button(hv_WindowHandleMenu);
			if (HDevWindowStack::IsOpen())
				CloseWindow(HDevWindowStack::Pop());
			return;
		}
	}
	else
	{
		hv_GenParamNames = HTuple();
		hv_GenParamValues = HTuple();
	}
	//
	hv_CasesDone = HTuple();
	hv_CurrentCase = HTuple();
	//
	//Find the parameters used for the edge extraction
	hv_MaxGap = HTuple();
	hv_MinAmplitudeAbs = HTuple();
	hv_Viewpoint = HTuple();
	hv_UserProvidedEdges = 0;
	if (0 != (HTuple(hv_HasEdges == HTuple("true")).TupleAnd((hv_SurfaceMatchingResultID.TupleLength())>0)))
	{
		GetSurfaceModelParam(hv_SurfaceModelID, "diameter", &hv_ModelDiameter);
		get_find_parameter(hv_GenParamNames, hv_GenParamValues, "viewpoint", "0 0 0",
			&hv_ViewpointStr);
		hv_Viewpoint = (hv_ViewpointStr.TupleSplit(" ")).TupleNumber();
		get_find_parameter(hv_GenParamNames, hv_GenParamValues, "max_gap", 30, &hv_MaxGap);
		get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edge_min_amplitude_rel",
			HTuple(), &hv_MinAmplitudeRel);
		if (0 != (hv_MinAmplitudeRel != HTuple()))
		{
			hv_MinAmplitudeAbs = hv_MinAmplitudeRel*hv_ModelDiameter;
		}
		else
		{
			get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edge_min_amplitude_abs",
				0.05*hv_ModelDiameter, &hv_MinAmplitudeAbs);
		}
		//
		get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edges", HTuple(),
			&hv_OM3DProvidedEdges);
		hv_UserProvidedEdges = (hv_OM3DProvidedEdges.TupleLength())>0;
	}
	hv_NormalParamsSet = 0;
	//
	while (0 != 1)
	{
		ClearWindow(hv_WindowHandleMenu);
		disp_menu_ext(ho_MenuRegions, hv_WindowHandleMenu, hv_MenuText, hv_CasesDone,
			HTuple());
		SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
		write_note(hv_WindowHandleMenu, "info", "Please consider the limitations of this procedure as described in its documentation.");
		write_note(hv_WindowHandleMenu, "instruction", "Select a test from above. It is recommended to start with the Automatic Value Check.");
		if (0 != ((hv_SurfaceMatchingResultID.TupleLength()) == 0))
		{
			write_note(hv_WindowHandleMenu, "warning", HTuple("No result handle was provided. To enable more tests, run find_surface_model() with 'ReturnResultHandle' set to 'true' beforehand and pass the result handle to this procedure."));
		}
		if (0 != hv_UserProvidedEdges)
		{
			write_note(hv_WindowHandleMenu, "warning", HTuple("Edges were passed to find_surface_model manually with the '3d_edges' parameter. Some checks of scene edges might be incorrect, since they assume that edges are extracted by find_surface_model."));
		}
		select_case(ho_MenuRegions, hv_WindowHandleMenu, hv_MenuText, &hv_CurrentCase);
		if (0 != (hv_CurrentCase == -1))
		{
			//Window was closed -> abort
			break;
		}
		if (0 != (HTuple(hv_MenuCode[hv_CurrentCase]) == HTuple("exit")))
		{
			break;
		}
		TupleUnion(hv_CasesDone, hv_CurrentCase, &hv_CasesDone);
		disp_menu_ext(ho_MenuRegions, hv_WindowHandleMenu, hv_MenuText, hv_CasesDone,
			hv_CurrentCase);
		//
		//****************************
		//Inspect Normal Directions *
		//****************************
		if (0 != (HTuple(hv_MenuCode[hv_CurrentCase]) == HTuple("normals")))
		{
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
			hv_Message = HTuple("Check visually, if the normals of the model point approximately in the same direction as the normals of the scene by moving the model and the scene accordingly");
			write_note(hv_WindowHandleMenu, "instruction", hv_Message);
			//
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, 0, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle1);
			HDevWindowStack::Push(hv_WindowHandle1);
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, hv_WindowSize, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle2);
			HDevWindowStack::Push(hv_WindowHandle2);
			set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
			set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
			//
			inspect_normal_direction(ho_MenuRegions, hv_WindowHandle1, hv_WindowHandle2,
				hv_WindowHandleMenu, hv_SurfaceModelID, hv_ObjectModel3DScene, hv_RelSamplingDistance,
				hv_KeyPointFraction, hv_MinScore, hv_GenParamNames, hv_GenParamValues,
				hv_SurfaceMatchingResultID, hv_MenuText, hv_CurrentCase, hv_CasesDone,
				hv_FontSize, &hv_CreateName, &hv_CreateValue, &hv_FindNames, &hv_FindValues);
			hv_NormalParamsSet = 1;
			//
			dev_close_window_if_open(hv_WindowHandle1);
			dev_close_window_if_open(hv_WindowHandle2);
		}
		//
		//***************************
		//Check the data structure *
		//***************************
		//
		if (0 != (HTuple(hv_MenuCode[hv_CurrentCase]) == HTuple("check")))
		{
			//Update the visualization of the menue
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
			write_note(hv_WindowHandleMenu, "instruction", "Please wait while an automatic check of parameters and values is performed");
			//
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, 0, hv_WindowSize * 2, hv_WindowSize, 0, "visible", "", &hv_WindowHandle1);
			HDevWindowStack::Push(hv_WindowHandle1);
			set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
			//
			check_find_surface_model_params(hv_WindowHandle1, hv_SurfaceModelID, hv_ObjectModel3DScene,
				hv_GenParamNames, hv_GenParamValues);
			//
			dev_close_window_if_open(hv_WindowHandle1);
		}
		//
		//****************
		//Prepare edges *
		//****************
		//
		if (0 != (HTuple(hv_MenuCode[hv_CurrentCase]) == HTuple("scene_edge_params")))
		{
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
			hv_Message = "Find the 3D edges by adjusting the MinAmplitude and the MaxGap accordingly";
			write_note(hv_WindowHandleMenu, "instruction", hv_Message);
			//
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, 0, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle1);
			HDevWindowStack::Push(hv_WindowHandle1);
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, hv_WindowSize, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle2);
			HDevWindowStack::Push(hv_WindowHandle2);
			set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
			set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
			//
			inspect_scene_edge_parameters(hv_WindowHandle1, hv_WindowHandle2, hv_SurfaceModelID,
				hv_ObjectModel3DScene, hv_SurfaceMatchingResultID, hv_MaxGap, hv_MinAmplitudeAbs,
				hv_Viewpoint, &hv_MaxGap, &hv_MinAmplitudeAbs);
			hv_EdgeParamsSet = 1;
			//
			dev_close_window_if_open(hv_WindowHandle1);
			dev_close_window_if_open(hv_WindowHandle2);
		}
		//
		//******************
		//Edge Directions *
		//******************
		//
		if (0 != (HTuple(hv_MenuCode[hv_CurrentCase]) == HTuple("scene_edge_dirs")))
		{
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
			hv_Message = HTuple(HTuple("Move the left view such that you see the scene from the direction of the sensor (viewpoint, default is [0,0,0]). ") + HTuple("The right view shows the extracted edges, viewing directions (green) and edge directions (red). The viewing directions show away from the viewpoint. ")) + "The edge directions should be perpendicular to the edges and point outward.";
			write_note(hv_WindowHandleMenu, "instruction", hv_Message);
			//
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, 0, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle1);
			HDevWindowStack::Push(hv_WindowHandle1);
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, hv_WindowSize, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle2);
			HDevWindowStack::Push(hv_WindowHandle2);
			set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
			set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
			//
			inspect_scene_edge_directions(hv_WindowHandle1, hv_WindowHandle2, hv_SurfaceModelID,
				hv_ObjectModel3DScene, hv_SurfaceMatchingResultID, hv_MaxGap, hv_MinAmplitudeAbs,
				hv_Viewpoint, &hv_Viewpoint);
			//
			dev_close_window_if_open(hv_WindowHandle1);
			dev_close_window_if_open(hv_WindowHandle2);
		}
		//
		//***************************
		//Inspect Model Edges      *
		//***************************
		//
		if (0 != (HTuple(hv_MenuCode[hv_CurrentCase]) == HTuple("model_edges")))
		{
			//Update the visualization of the menue
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
			write_note(hv_WindowHandleMenu, "info", "This tool allows to inspect the edges that create_surface_model found in the object.");
			write_note(hv_WindowHandleMenu, "instruction", "Use the left window to move the viewpoint and the right window to inspect the edges.");
			write_note(hv_WindowHandleMenu, "info", "The visualized \"edge directions\" should be perpendicular to the direction of the model edges and point outward.");
			//
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, 0, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle1);
			HDevWindowStack::Push(hv_WindowHandle1);
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, hv_WindowSize, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle2);
			HDevWindowStack::Push(hv_WindowHandle2);
			set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
			set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
			//
			check_model_edges(hv_SurfaceModelID, hv_ObjectModel3DModel, hv_WindowHandle1,
				hv_WindowHandle2);
			//
			dev_close_window_if_open(hv_WindowHandle1);
			dev_close_window_if_open(hv_WindowHandle2);
		}
		//
		//***************************
		//Inspect Matching Results *
		//***************************
		//
		if (0 != (HTuple(hv_MenuCode[hv_CurrentCase]) == HTuple("results")))
		{
			//Update the visualization of the menue
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			SetTposition(hv_WindowHandleMenu, hv_MenuBottom + 6, 1);
			write_note(hv_WindowHandleMenu, "instruction", "Inspect the matching results below.");
			//
			SetWindowAttr("background_color", "black");
			OpenWindow(hv_HeightMenu + 50, 0, hv_WindowSize, hv_WindowSize, 0, "visible", "", &hv_WindowHandle1);
			HDevWindowStack::Push(hv_WindowHandle1);
			set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
			//
			dev_display_surface_matching_results(hv_WindowHandle1, hv_SurfaceMatchingResultID,
				hv_ObjectModel3DModel, hv_ObjectModel3DScene, hv_Score, hv_Pose, hv_HasEdges);
			//
			dev_close_window_if_open(hv_WindowHandle1);
		}
	}
	//
	dev_close_window_if_open(hv_WindowHandleMenu);
	//
	//Construct the parameters
	(*hv_CreateSurfaceModelParamName) = HTuple();
	(*hv_CreateSurfaceModelParamValue) = HTuple();
	(*hv_FindSurfaceModelParamName) = HTuple();
	(*hv_FindSurfaceModelParamValue) = HTuple();

	if (0 != hv_NormalParamsSet)
	{
		(*hv_CreateSurfaceModelParamName) = (*hv_CreateSurfaceModelParamName).TupleConcat(hv_CreateName);
		(*hv_CreateSurfaceModelParamValue) = (*hv_CreateSurfaceModelParamValue).TupleConcat(hv_CreateValue);
		(*hv_FindSurfaceModelParamName) = (*hv_FindSurfaceModelParamName).TupleConcat(hv_FindNames);
		(*hv_FindSurfaceModelParamValue) = (*hv_FindSurfaceModelParamValue).TupleConcat(hv_FindValues);
	}

	if (0 != (hv_MaxGap != HTuple()))
	{
		(*hv_FindSurfaceModelParamName) = (*hv_FindSurfaceModelParamName).TupleConcat((HTuple("3d_edge_min_amplitude_abs").Append("max_gap")));
		(*hv_FindSurfaceModelParamValue) = ((*hv_FindSurfaceModelParamValue).TupleConcat(hv_MinAmplitudeAbs)).TupleConcat(hv_MaxGap);
	}

	if (0 != (hv_Viewpoint != HTuple()))
	{
		(*hv_FindSurfaceModelParamName) = (*hv_FindSurfaceModelParamName).TupleConcat("viewpoint");
		(*hv_FindSurfaceModelParamValue) = (*hv_FindSurfaceModelParamValue).TupleConcat((((HTuple(hv_Viewpoint[0]) + " ") + HTuple(hv_Viewpoint[1])) + " ") + HTuple(hv_Viewpoint[2]));
	}

}

// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance(HTuple hv_ObjectModel3DID, HTuple hv_CamParam,
	HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_NumModels, hv_Rows, hv_Cols, hv_MinMinZ;
	HTuple  hv_BB, hv_Seq, hv_DXMax, hv_DYMax, hv_DZMax, hv_Diameter;
	HTuple  hv_ZAdd, hv_IBB, hv_BB0, hv_BB1, hv_BB2, hv_BB3;
	HTuple  hv_BB4, hv_BB5, hv_X, hv_Y, hv_Z, hv_PoseInter;
	HTuple  hv_HomMat3D, hv_QX, hv_QY, hv_QZ, hv_Cx, hv_Cy;
	HTuple  hv_DR, hv_DC, hv_MaxDist, hv_HomMat3DRotate, hv_ImageWidth;
	HTuple  hv_ImageHeight, hv_MinImageSize, hv_Zs, hv_ZDiff;
	HTuple  hv_ScaleZ, hv_ZNew;

	//Determine the optimum distance of the object to obtain
	//a reasonable visualization
	//
	hv_NumModels = hv_ObjectModel3DID.TupleLength();
	hv_Rows = HTuple();
	hv_Cols = HTuple();
	hv_MinMinZ = 1e30;
	GetObjectModel3dParams(hv_ObjectModel3DID, "bounding_box1", &hv_BB);
	//Calculate diameter over all objects to be visualized
	hv_Seq = HTuple::TupleGenSequence(0, (hv_BB.TupleLength()) - 1, 6);
	hv_DXMax = (HTuple(hv_BB[hv_Seq + 3]).TupleMax()) - (HTuple(hv_BB[hv_Seq]).TupleMin());
	hv_DYMax = (HTuple(hv_BB[hv_Seq + 4]).TupleMax()) - (HTuple(hv_BB[hv_Seq + 1]).TupleMin());
	hv_DZMax = (HTuple(hv_BB[hv_Seq + 5]).TupleMax()) - (HTuple(hv_BB[hv_Seq + 2]).TupleMin());
	hv_Diameter = (((hv_DXMax*hv_DXMax) + (hv_DYMax*hv_DYMax)) + (hv_DZMax*hv_DZMax)).TupleSqrt();
	if (0 != (((hv_BB.TupleAbs()).TupleSum()) == 0.0))
	{
		hv_BB.Clear();
		hv_BB.Append(-(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs()));
		hv_BB.Append(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs());
	}
	//Allow the visualization of single points or extremely small objects
	hv_ZAdd = 0.0;
	if (0 != ((hv_Diameter.TupleMax())<1e-10))
	{
		hv_ZAdd = 0.01;
	}
	//Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead
	//to projection errors
	if (0 != ((hv_Diameter.TupleMin())<1e-10))
	{
		hv_Diameter = hv_Diameter - (((((hv_Diameter - 1e-10).TupleSgn()) - 1).TupleSgn())*1e-10);
	}
	hv_IBB = HTuple::TupleGenSequence(0, (hv_BB.TupleLength()) - 1, 6);
	hv_BB0 = HTuple(hv_BB[hv_IBB]);
	hv_BB1 = HTuple(hv_BB[hv_IBB + 1]);
	hv_BB2 = HTuple(hv_BB[hv_IBB + 2]);
	hv_BB3 = HTuple(hv_BB[hv_IBB + 3]);
	hv_BB4 = HTuple(hv_BB[hv_IBB + 4]);
	hv_BB5 = HTuple(hv_BB[hv_IBB + 5]);
	hv_X.Clear();
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB3);
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB3);
	hv_X.Append(hv_BB3);
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB3);
	hv_Y.Clear();
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB4);
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB4);
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB4);
	hv_Y.Append(hv_BB4);
	hv_Z.Clear();
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB5);
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB5);
	hv_Z.Append(hv_BB5);
	hv_Z.Append(hv_BB5);
	hv_PoseInter = hv_PoseIn.TupleReplace(2, (-(hv_Z.TupleMin())) + (2 * (hv_Diameter.TupleMax())));
	PoseToHomMat3d(hv_PoseInter, &hv_HomMat3D);
	//Determine the maximum extension of the projection
	AffineTransPoint3d(hv_HomMat3D, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
	Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
	hv_MinMinZ = hv_QZ.TupleMin();
	get_cam_par_data(hv_CamParam, "cx", &hv_Cx);
	get_cam_par_data(hv_CamParam, "cy", &hv_Cy);
	hv_DR = hv_Rows - hv_Cy;
	hv_DC = hv_Cols - hv_Cx;
	hv_DR = (hv_DR.TupleMax()) - (hv_DR.TupleMin());
	hv_DC = (hv_DC.TupleMax()) - (hv_DC.TupleMin());
	hv_MaxDist = ((hv_DR*hv_DR) + (hv_DC*hv_DC)).TupleSqrt();
	//
	if (0 != (hv_MaxDist<1e-10))
	{
		//If the object has no extension in the above projection (looking along
		//a line), we determine the extension of the object in a rotated view
		HomMat3dRotateLocal(hv_HomMat3D, HTuple(90).TupleRad(), "x", &hv_HomMat3DRotate);
		AffineTransPoint3d(hv_HomMat3DRotate, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
		Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
		hv_DR = hv_Rows - hv_Cy;
		hv_DC = hv_Cols - hv_Cx;
		hv_DR = (hv_DR.TupleMax()) - (hv_DR.TupleMin());
		hv_DC = (hv_DC.TupleMax()) - (hv_DC.TupleMin());
		hv_MaxDist = (hv_MaxDist.TupleConcat(((hv_DR*hv_DR) + (hv_DC*hv_DC)).TupleSqrt())).TupleMax();
	}
	//
	get_cam_par_data(hv_CamParam, "image_width", &hv_ImageWidth);
	get_cam_par_data(hv_CamParam, "image_height", &hv_ImageHeight);
	hv_MinImageSize = (hv_ImageWidth.TupleConcat(hv_ImageHeight)).TupleMin();
	//
	hv_Z = ((const HTuple&)hv_PoseInter)[2];
	hv_Zs = hv_MinMinZ;
	hv_ZDiff = hv_Z - hv_Zs;
	hv_ScaleZ = hv_MaxDist / (((0.5*hv_MinImageSize)*hv_ImageCoverage)*2.0);
	hv_ZNew = ((hv_ScaleZ*hv_Zs) + hv_ZDiff) + hv_ZAdd;
	(*hv_PoseOut) = hv_PoseInter.TupleReplace(2, hv_ZNew);
	//
	return;
}

// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance_visualize_object_model_3d(HTuple hv_ObjectModel3DID,
	HTuple hv_CamParam, HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_NumModels, hv_Rows, hv_Cols, hv_MinMinZ;
	HTuple  hv_BB, hv_Seq, hv_DXMax, hv_DYMax, hv_DZMax, hv_Diameter;
	HTuple  hv_ZAdd, hv_IBB, hv_BB0, hv_BB1, hv_BB2, hv_BB3;
	HTuple  hv_BB4, hv_BB5, hv_X, hv_Y, hv_Z, hv_PoseInter;
	HTuple  hv_HomMat3D, hv_QX, hv_QY, hv_QZ, hv_Cx, hv_Cy;
	HTuple  hv_DR, hv_DC, hv_MaxDist, hv_HomMat3DRotate, hv_ImageWidth;
	HTuple  hv_ImageHeight, hv_MinImageSize, hv_Zs, hv_ZDiff;
	HTuple  hv_ScaleZ, hv_ZNew;

	//Determine the optimum distance of the object to obtain
	//a reasonable visualization
	//
	hv_NumModels = hv_ObjectModel3DID.TupleLength();
	hv_Rows = HTuple();
	hv_Cols = HTuple();
	hv_MinMinZ = 1e30;
	GetObjectModel3dParams(hv_ObjectModel3DID, "bounding_box1", &hv_BB);
	//Calculate diameter over all objects to be visualized
	hv_Seq = HTuple::TupleGenSequence(0, (hv_BB.TupleLength()) - 1, 6);
	hv_DXMax = (HTuple(hv_BB[hv_Seq + 3]).TupleMax()) - (HTuple(hv_BB[hv_Seq]).TupleMin());
	hv_DYMax = (HTuple(hv_BB[hv_Seq + 4]).TupleMax()) - (HTuple(hv_BB[hv_Seq + 1]).TupleMin());
	hv_DZMax = (HTuple(hv_BB[hv_Seq + 5]).TupleMax()) - (HTuple(hv_BB[hv_Seq + 2]).TupleMin());
	hv_Diameter = (((hv_DXMax*hv_DXMax) + (hv_DYMax*hv_DYMax)) + (hv_DZMax*hv_DZMax)).TupleSqrt();
	if (0 != (((hv_BB.TupleAbs()).TupleSum()) == 0.0))
	{
		hv_BB.Clear();
		hv_BB.Append(-(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs()));
		hv_BB.Append(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs());
	}
	//Allow the visualization of single points or extremely small objects
	hv_ZAdd = 0.0;
	if (0 != ((hv_Diameter.TupleMax())<1e-10))
	{
		hv_ZAdd = 0.01;
	}
	//Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead
	//to projection errors
	if (0 != ((hv_Diameter.TupleMin())<1e-10))
	{
		hv_Diameter = hv_Diameter - (((((hv_Diameter - 1e-10).TupleSgn()) - 1).TupleSgn())*1e-10);
	}
	hv_IBB = HTuple::TupleGenSequence(0, (hv_BB.TupleLength()) - 1, 6);
	hv_BB0 = HTuple(hv_BB[hv_IBB]);
	hv_BB1 = HTuple(hv_BB[hv_IBB + 1]);
	hv_BB2 = HTuple(hv_BB[hv_IBB + 2]);
	hv_BB3 = HTuple(hv_BB[hv_IBB + 3]);
	hv_BB4 = HTuple(hv_BB[hv_IBB + 4]);
	hv_BB5 = HTuple(hv_BB[hv_IBB + 5]);
	hv_X.Clear();
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB3);
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB3);
	hv_X.Append(hv_BB3);
	hv_X.Append(hv_BB0);
	hv_X.Append(hv_BB3);
	hv_Y.Clear();
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB4);
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB4);
	hv_Y.Append(hv_BB1);
	hv_Y.Append(hv_BB4);
	hv_Y.Append(hv_BB4);
	hv_Z.Clear();
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB5);
	hv_Z.Append(hv_BB2);
	hv_Z.Append(hv_BB5);
	hv_Z.Append(hv_BB5);
	hv_Z.Append(hv_BB5);
	hv_PoseInter = hv_PoseIn.TupleReplace(2, (-(hv_Z.TupleMin())) + (2 * (hv_Diameter.TupleMax())));
	PoseToHomMat3d(hv_PoseInter, &hv_HomMat3D);
	//Determine the maximum extension of the projection
	AffineTransPoint3d(hv_HomMat3D, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
	Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
	hv_MinMinZ = hv_QZ.TupleMin();
	get_cam_par_data(hv_CamParam, "cx", &hv_Cx);
	get_cam_par_data(hv_CamParam, "cy", &hv_Cy);
	hv_DR = hv_Rows - hv_Cy;
	hv_DC = hv_Cols - hv_Cx;
	hv_DR = (hv_DR.TupleMax()) - (hv_DR.TupleMin());
	hv_DC = (hv_DC.TupleMax()) - (hv_DC.TupleMin());
	hv_MaxDist = ((hv_DR*hv_DR) + (hv_DC*hv_DC)).TupleSqrt();
	//
	if (0 != (hv_MaxDist<1e-10))
	{
		//If the object has no extension in the above projection (looking along
		//a line), we determine the extension of the object in a rotated view
		HomMat3dRotateLocal(hv_HomMat3D, HTuple(90).TupleRad(), "x", &hv_HomMat3DRotate);
		AffineTransPoint3d(hv_HomMat3DRotate, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
		Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
		hv_DR = hv_Rows - hv_Cy;
		hv_DC = hv_Cols - hv_Cx;
		hv_DR = (hv_DR.TupleMax()) - (hv_DR.TupleMin());
		hv_DC = (hv_DC.TupleMax()) - (hv_DC.TupleMin());
		hv_MaxDist = (hv_MaxDist.TupleConcat(((hv_DR*hv_DR) + (hv_DC*hv_DC)).TupleSqrt())).TupleMax();
	}
	//
	get_cam_par_data(hv_CamParam, "image_width", &hv_ImageWidth);
	get_cam_par_data(hv_CamParam, "image_height", &hv_ImageHeight);
	hv_MinImageSize = (hv_ImageWidth.TupleConcat(hv_ImageHeight)).TupleMin();
	//
	hv_Z = ((const HTuple&)hv_PoseInter)[2];
	hv_Zs = hv_MinMinZ;
	hv_ZDiff = hv_Z - hv_Zs;
	hv_ScaleZ = hv_MaxDist / (((0.5*hv_MinImageSize)*hv_ImageCoverage)*2.0);
	hv_ZNew = ((hv_ScaleZ*hv_Zs) + hv_ZDiff) + hv_ZAdd;
	(*hv_PoseOut) = hv_PoseInter.TupleReplace(2, hv_ZNew);
	//
	return;
}

// Short Description: Closes the window if it is still open. 
void dev_close_window_if_open(HTuple hv_WindowHandle)
{

	// Local control variables
	HTuple  hv_CurrWindowHandle;

	HDevWindowStack::SetActive(hv_WindowHandle);
	if (HDevWindowStack::IsOpen())
		hv_CurrWindowHandle = HDevWindowStack::GetActive();
	if (0 != (hv_CurrWindowHandle == hv_WindowHandle))
	{
		if (HDevWindowStack::IsOpen())
			CloseWindow(HDevWindowStack::Pop());
	}
	return;
}

void dev_display_surface_matching_results(HTuple hv_WindowHandle1, HTuple hv_SurfaceMatchingResultID,
	HTuple hv_ObjectModel3DModel, HTuple hv_ObjectModel3DScene, HTuple hv_Score,
	HTuple hv_Pose, HTuple hv_EdgesTrained)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_SampledEdges, hv_KeyPoints, hv_SampledScene;
	HTuple  hv_Instructions, hv_Colors, hv_Number, hv_ObjectModel3DResult;
	HTuple  hv_ColorsVis, hv_Message, hv_PoseOut;

	//
	//Get Matching data
	if (0 != (hv_EdgesTrained == HTuple("true")))
	{
		GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_edges", HTuple(),
			&hv_SampledEdges);
	}
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "key_points", HTuple(), &hv_KeyPoints);
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", HTuple(),
		&hv_SampledScene);
	//
	hv_Instructions[0] = "Rotate: Left button";
	hv_Instructions[1] = "Zoom:   Shift + left button";
	hv_Instructions[2] = "Move:   Ctrl  + left button";
	//
	//Generate color vector for visualization
	hv_Colors.Clear();
	hv_Colors[0] = "red";
	hv_Colors[1] = "green";
	hv_Colors[2] = "blue";
	hv_Colors[3] = "cyan";
	hv_Colors[4] = "magenta";
	hv_Colors[5] = "yellow";
	hv_Colors[6] = "medium slate blue";
	hv_Colors[7] = "coral";
	hv_Colors[8] = "slate blue";
	hv_Colors[9] = "orange red";
	hv_Colors[10] = "dark olive green";
	//
	//Number of Matches
	hv_Number = hv_Score.TupleLength();
	//
	//Move the model into the scene
	RigidTransObjectModel3d(hv_ObjectModel3DModel, hv_Pose, &hv_ObjectModel3DResult);
	hv_ColorsVis = HTuple(hv_Colors[HTuple::TupleGenSequence(0, hv_Number - 1, 1) % (hv_Colors.TupleLength())]);
	//
	//Visualize results
	if (0 != (hv_EdgesTrained == HTuple("true")))
	{
		hv_Message = "Original scene points (gray)";
		hv_Message[1] = "Sampled scene points (cyan)";
		hv_Message[2] = "Key points (yellow)";
		hv_Message[3] = "Sampled 3d edges (green)";
		hv_Message[4] = hv_Number + " objects are found ";
		visualize_object_model_3d(hv_WindowHandle1, (((hv_ObjectModel3DScene.TupleConcat(hv_SampledEdges)).TupleConcat(hv_SampledScene)).TupleConcat(hv_KeyPoints)).TupleConcat(hv_ObjectModel3DResult),
			HTuple(), HTuple(), (("color_" + HTuple::TupleGenSequence(0, hv_Number + 3, 1)).TupleConcat(HTuple("point_size_") + (((HTuple(0).Append(1)).Append(2)).Append(3)))).TupleConcat((HTuple("disp_pose").Append("alpha"))),
			((((HTuple("gray").Append("green")).Append("cyan")).Append("yellow")).TupleConcat(hv_ColorsVis)).TupleConcat((((((HTuple(1.0).Append(3.0)).Append(3.0)).Append(5.0)).Append("true")).Append(0.5))),
			hv_Message, (((HTuple("").Append("")).Append("")).Append("")).TupleConcat(hv_Score),
			hv_Instructions, &hv_PoseOut);
	}
	else
	{
		hv_Message = "Final Results:";
		hv_Message[1] = "Original scene points (gray)";
		hv_Message[2] = "Sampled scene points (cyan)";
		hv_Message[3] = "Key points (yellow)";
		hv_Message[4] = hv_Number + " objects are found";
		visualize_object_model_3d(hv_WindowHandle1, ((hv_ObjectModel3DScene.TupleConcat(hv_SampledScene)).TupleConcat(hv_KeyPoints)).TupleConcat(hv_ObjectModel3DResult),
			HTuple(), HTuple(), (("color_" + HTuple::TupleGenSequence(0, hv_Number + 2, 1)).TupleConcat(HTuple("point_size_") + ((HTuple(0).Append(1)).Append(2)))).TupleConcat((HTuple("disp_pose").Append("alpha"))),
			(((HTuple("gray").Append("cyan")).Append("yellow")).TupleConcat(hv_ColorsVis)).TupleConcat(((((HTuple(1.0).Append(3.0)).Append(5.0)).Append("true")).Append(0.5))),
			hv_Message, ((HTuple("").Append("")).Append("")).TupleConcat(hv_Score), hv_Instructions,
			&hv_PoseOut);
	}
	HDevWindowStack::SetActive(hv_WindowHandle1);
	if (HDevWindowStack::IsOpen())
		ClearWindow(HDevWindowStack::GetActive());
	return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off()
{

	//This procedure sets different update settings to 'off'.
	//This is useful to get the best performance and reduce overhead.
	//
	// dev_update_pc(...); only in hdevelop
	// dev_update_var(...); only in hdevelop
	// dev_update_window(...); only in hdevelop
	return;
}

// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_buttons(HTuple hv_Parameters, HTuple hv_WindowHandle)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_gButtons, hv_idx, hv_Message;

	//This procedure displays all Buttons in the window.
	//
	//Input parameters:
	//WindowHandle: The window, where the text shall be displayed
	//
	//Use the buttons set in the global variable gButtons.
	GetMessageTuple(hv_Parameters, "gButtons", &hv_gButtons);

	{
		HTuple end_val8 = (hv_gButtons.TupleLength()) - 1;
		HTuple step_val8 = 5;
		for (hv_idx = 0; hv_idx.Continue(end_val8, step_val8); hv_idx += step_val8)
		{
			//Display the continue button
			hv_Message = HTuple(hv_gButtons[hv_idx + 0]);
			disp_text_button(hv_WindowHandle, hv_Message, "window", HTuple(hv_gButtons[hv_idx + 2]),
				HTuple(hv_gButtons[hv_idx + 1]), "black", "#f28f26");
			//Debug the computed area
			//gen_rectangle1 (Rectangle, gButtons[idx + 2], gButtons[idx + 1], gButtons[idx + 4], gButtons[idx + 3])
			//set_color (WindowHandle, 'white')
			//set_color (WindowHandle, '#ffffFFEE')
			//disp_obj (Rectangle, WindowHandle)
		}
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_continue_button(HTuple hv_WindowHandle)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_ContinueMessage, hv_Exception, hv_Row;
	HTuple  hv_Column, hv_Width, hv_Height, hv_Ascent, hv_Descent;
	HTuple  hv_TextWidth, hv_TextHeight;

	//This procedure displays a 'Continue' text button
	//in the lower right corner of the screen.
	//It uses the procedure disp_message.
	//
	//Input parameters:
	//WindowHandle: The window, where the text shall be displayed
	//
	//Use the continue message set in the global variable gTerminationButtonLabel.
	//If this variable is not defined, set a standard text instead.
	//global tuple gTerminationButtonLabel
	try
	{
		hv_ContinueMessage = ExpGetGlobalVar_gTerminationButtonLabel();
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		hv_ContinueMessage = "Continue";
	}
	//Display the continue button
	GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
	GetStringExtents(hv_WindowHandle, (" " + hv_ContinueMessage) + " ", &hv_Ascent, &hv_Descent,
		&hv_TextWidth, &hv_TextHeight);
	disp_text_button_visualize_object_model_3d(hv_WindowHandle, hv_ContinueMessage,
		"window", (hv_Height - hv_TextHeight) - 22, (hv_Width - hv_TextWidth) - 12, "black",
		"#f28f26");
	return;
}

void disp_menu_ext(HObject ho_MenuRegions, HTuple hv_WindowHandleMenu, HTuple hv_MenuText,
	HTuple hv_CasesDone, HTuple hv_CurrentCase)
{

	// Local iconic variables
	HObject  ho_MenuRegion, ho_RegionBorder, ho_Contour;

	// Local control variables
	HTuple  hv_NumberRegions, hv_NumberTexts, hv_Row;
	HTuple  hv_Column, hv_Width1, hv_Height1, hv_i, hv_Text;
	HTuple  hv_Rows, hv_Cols, hv_Indices, hv_Done, hv_Ascent;
	HTuple  hv_Descent, hv_Width, hv_Height, hv_Col, hv_Scale;

	//Display the previously created menu buttons
	CountObj(ho_MenuRegions, &hv_NumberRegions);
	hv_NumberTexts = hv_MenuText.TupleLength();
	if (0 != (hv_NumberRegions<hv_NumberTexts))
	{
		throw HException((("Too few regions for the given number of texts: " + hv_NumberRegions) + " vs. ") + hv_NumberTexts);
	}

	ClearWindow(hv_WindowHandleMenu);
	GetWindowExtents(hv_WindowHandleMenu, &hv_Row, &hv_Column, &hv_Width1, &hv_Height1);

	{
		HTuple end_val10 = hv_NumberTexts;
		HTuple step_val10 = 1;
		for (hv_i = 1; hv_i.Continue(end_val10, step_val10); hv_i += step_val10)
		{
			SelectObj(ho_MenuRegions, &ho_MenuRegion, hv_i);
			hv_Text = HTuple(hv_MenuText[hv_i - 1]);
			SetColor(hv_WindowHandleMenu, "light gray");
			HDevWindowStack::SetActive(hv_WindowHandleMenu);
			if (HDevWindowStack::IsOpen())
				SetDraw(HDevWindowStack::GetActive(), "fill");
			if (HDevWindowStack::IsOpen())
				SetColor(HDevWindowStack::GetActive(), "light gray");
			DispRegion(ho_MenuRegion, hv_WindowHandleMenu);
			GetRegionContour(ho_MenuRegion, &hv_Rows, &hv_Cols);
			SetColor(hv_WindowHandleMenu, "dim gray");
			GenRegionPoints(&ho_RegionBorder, hv_Rows, hv_Cols);
			DispRegion(ho_RegionBorder, hv_WindowHandleMenu);
			//
			TupleFind(hv_CasesDone, hv_i - 1, &hv_Indices);
			hv_Done = 0;
			if (0 != ((hv_i - 1) == hv_CurrentCase))
			{
				SetColor(hv_WindowHandleMenu, "#FA8072");
			}
			else if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
			{
				SetColor(hv_WindowHandleMenu, "#228B22");
				hv_Done = 1;
			}
			else
			{
				SetColor(hv_WindowHandleMenu, "#B22222");
			}
			GetStringExtents(hv_WindowHandleMenu, hv_Text, &hv_Ascent, &hv_Descent, &hv_Width,
				&hv_Height);
			SetTposition(hv_WindowHandleMenu, (hv_Rows.TupleMin()) + 6, (((hv_Cols.TupleMax()) + (hv_Cols.TupleMin())) / 2) - (hv_Width / 2));
			WriteString(hv_WindowHandleMenu, hv_Text);
			if (0 != hv_Done)
			{
				hv_Row = 0.5*((hv_Rows.TupleMax()) + (hv_Rows.TupleMin()));
				hv_Col = ((((hv_Cols.TupleMax()) + (hv_Cols.TupleMin())) / 2) + (hv_Width / 2)) + 15;
				hv_Scale = (hv_Rows.TupleMax()) - (hv_Rows.TupleMin());
				GenContourPolygonXld(&ho_Contour, hv_Row + ((((-hv_Scale)*0.2).TupleConcat(0)).TupleConcat((-hv_Scale)*0.35)),
					hv_Col + ((HTuple(0).TupleConcat(hv_Scale*0.12)).TupleConcat(hv_Scale*0.24)));
				SetLineWidth(hv_WindowHandleMenu, 2);
				DispObj(ho_Contour, hv_WindowHandleMenu);
			}
		}
	}
	return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_GenParamName, hv_GenParamValue;

	//This procedure displays text in a graphics window.
	//
	//Input parameters:
	//WindowHandle: The WindowHandle of the graphics window, where
	//   the message should be displayed
	//String: A tuple of strings containing the text message to be displayed
	//CoordSystem: If set to 'window', the text position is given
	//   with respect to the window coordinate system.
	//   If set to 'image', image coordinates are used.
	//   (This may be useful in zoomed images.)
	//Row: The row coordinate of the desired text position
	//   A tuple of values is allowed to display text at different
	//   positions.
	//Column: The column coordinate of the desired text position
	//   A tuple of values is allowed to display text at different
	//   positions.
	//Color: defines the color of the text as string.
	//   If set to [], '' or 'auto' the currently set color is used.
	//   If a tuple of strings is passed, the colors are used cyclically...
	//   - if |Row| == |Column| == 1: for each new textline
	//   = else for each text position.
	//Box: If Box[0] is set to 'true', the text is written within an orange box.
	//     If set to' false', no box is displayed.
	//     If set to a color string (e.g. 'white', '#FF00CC', etc.),
	//       the text is written in a box of that color.
	//     An optional second value for Box (Box[1]) controls if a shadow is displayed:
	//       'true' -> display a shadow in a default color
	//       'false' -> display no shadow
	//       otherwise -> use given string as color string for the shadow color
	//
	//It is possible to display multiple text strings in a single call.
	//In this case, some restrictions apply:
	//- Multiple text positions can be defined by specifying a tuple
	//  with multiple Row and/or Column coordinates, i.e.:
	//  - |Row| == n, |Column| == n
	//  - |Row| == n, |Column| == 1
	//  - |Row| == 1, |Column| == n
	//- If |Row| == |Column| == 1,
	//  each element of String is display in a new textline.
	//- If multiple positions or specified, the number of Strings
	//  must match the number of positions, i.e.:
	//  - Either |String| == n (each string is displayed at the
	//                          corresponding position),
	//  - or     |String| == 1 (The string is displayed n times).
	//
	//
	//Convert the parameters for disp_text.
	if (0 != (HTuple(hv_Row == HTuple()).TupleOr(hv_Column == HTuple())))
	{
		return;
	}
	if (0 != (hv_Row == -1))
	{
		hv_Row = 12;
	}
	if (0 != (hv_Column == -1))
	{
		hv_Column = 12;
	}
	//
	//Convert the parameter Box to generic parameters.
	hv_GenParamName = HTuple();
	hv_GenParamValue = HTuple();
	if (0 != ((hv_Box.TupleLength())>0))
	{
		if (0 != (HTuple(hv_Box[0]) == HTuple("false")))
		{
			//Display no box
			hv_GenParamName = hv_GenParamName.TupleConcat("box");
			hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
		}
		else if (0 != (HTuple(hv_Box[0]) != HTuple("true")))
		{
			//Set a color other than the default.
			hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
			hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
		}
	}
	if (0 != ((hv_Box.TupleLength())>1))
	{
		if (0 != (HTuple(hv_Box[1]) == HTuple("false")))
		{
			//Display no shadow.
			hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
			hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
		}
		else if (0 != (HTuple(hv_Box[1]) != HTuple("true")))
		{
			//Set a shadow color other than the default.
			hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
			hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
		}
	}
	//Restore default CoordSystem behavior.
	if (0 != (hv_CoordSystem != HTuple("window")))
	{
		hv_CoordSystem = "image";
	}
	//
	if (0 != (hv_Color == HTuple("")))
	{
		//disp_text does not accept an empty string for Color.
		hv_Color = HTuple();
	}
	//
	DispText(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column, hv_Color,
		hv_GenParamName, hv_GenParamValue);
	return;
}

// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl(HObject *ho_ModelContours, HTuple hv_ObjectModel3DID,
	HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer,
	HTuple hv_CamParam, HTuple hv_PosesOut)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Idx, hv_CustomParamName, hv_CustomParamValue;
	HTuple  hv_Font, hv_IndicesDispBackGround, hv_Indices, hv_ImageWidth;
	HTuple  hv_HasPolygons, hv_HasTri, hv_HasPoints, hv_HasLines;
	HTuple  hv_NumPoints, hv_IsPrimitive, hv_Center, hv_Diameter;
	HTuple  hv_OpenGlHiddenSurface, hv_CenterX, hv_CenterY;
	HTuple  hv_CenterZ, hv_PosObjectsZ, hv_I, hv_Pose, hv_HomMat3DObj;
	HTuple  hv_PosObjCenterX, hv_PosObjCenterY, hv_PosObjCenterZ;
	HTuple  hv_PosObjectsX, hv_PosObjectsY, hv_Color, hv_Indices1;
	HTuple  hv_Indices2, hv_J, hv_Indices3, hv_HomMat3D, hv_SampledObjectModel3D;
	HTuple  hv_X, hv_Y, hv_Z, hv_HomMat3D1, hv_Qx, hv_Qy, hv_Qz;
	HTuple  hv_Row, hv_Column, hv_ObjectModel3DConvexHull, hv_Exception;

	//This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d
	//call for small objects. Large objects are sampled down to display.
	hv_Idx = hv_GenParamName.TupleFind("point_size");
	if (0 != (HTuple(hv_Idx.TupleLength()).TupleAnd(hv_Idx != -1)))
	{
		hv_CustomParamName = "point_size";
		hv_CustomParamValue = HTuple(hv_GenParamValue[hv_Idx]);
		if (0 != (hv_CustomParamValue == 1))
		{
			hv_CustomParamValue = 0;
		}
	}
	else
	{
		hv_CustomParamName = HTuple();
		hv_CustomParamValue = HTuple();
	}
	GetFont(hv_WindowHandleBuffer, &hv_Font);
	TupleFind(hv_GenParamName, "disp_background", &hv_IndicesDispBackGround);
	if (0 != (hv_IndicesDispBackGround != -1))
	{
		TupleFind(HTuple(hv_GenParamName[hv_IndicesDispBackGround]), "false", &hv_Indices);
		if (0 != (hv_Indices != -1))
		{
			ClearWindow(hv_WindowHandleBuffer);
		}
	}
	set_display_font(hv_WindowHandleBuffer, 11, "mono", "false", "false");
	get_cam_par_data(hv_CamParam, "image_width", &hv_ImageWidth);
	disp_message(hv_WindowHandleBuffer, "OpenGL missing!", "image", 5, hv_ImageWidth - 130,
		"red", "false");
	SetFont(hv_WindowHandleBuffer, hv_Font);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_polygons", &hv_HasPolygons);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_triangles", &hv_HasTri);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_points", &hv_HasPoints);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_lines", &hv_HasLines);
	GetObjectModel3dParams(hv_ObjectModel3DID, "num_points", &hv_NumPoints);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_primitive_data", &hv_IsPrimitive);
	GetObjectModel3dParams(hv_ObjectModel3DID, "center", &hv_Center);
	GetObjectModel3dParams(hv_ObjectModel3DID, "diameter", &hv_Diameter);
	GetSystem("opengl_hidden_surface_removal_enable", &hv_OpenGlHiddenSurface);
	SetSystem("opengl_hidden_surface_removal_enable", "false");
	//Sort the objects by inverse z
	hv_CenterX = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0, (hv_Center.TupleLength()) - 1, 3)];
	hv_CenterY = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0, (hv_Center.TupleLength()) - 1, 3) + 1];
	hv_CenterZ = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0, (hv_Center.TupleLength()) - 1, 3) + 2];
	hv_PosObjectsZ = HTuple();
	if (0 != ((hv_PosesOut.TupleLength())>7))
	{
		{
			HTuple end_val41 = (hv_ObjectModel3DID.TupleLength()) - 1;
			HTuple step_val41 = 1;
			for (hv_I = 0; hv_I.Continue(end_val41, step_val41); hv_I += step_val41)
			{
				hv_Pose = hv_PosesOut.TupleSelectRange(hv_I * 7, (hv_I * 7) + 6);
				PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
				AffineTransPoint3d(hv_HomMat3DObj, HTuple(hv_CenterX[hv_I]), HTuple(hv_CenterY[hv_I]),
					HTuple(hv_CenterZ[hv_I]), &hv_PosObjCenterX, &hv_PosObjCenterY, &hv_PosObjCenterZ);
				hv_PosObjectsZ = hv_PosObjectsZ.TupleConcat(hv_PosObjCenterZ);
			}
		}
	}
	else
	{
		hv_Pose = hv_PosesOut.TupleSelectRange(0, 6);
		PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
		AffineTransPoint3d(hv_HomMat3DObj, hv_CenterX, hv_CenterY, hv_CenterZ, &hv_PosObjectsX,
			&hv_PosObjectsY, &hv_PosObjectsZ);
	}
	hv_Idx = HTuple(hv_PosObjectsZ.TupleSortIndex()).TupleInverse();
	hv_Color = "white";
	SetColor(hv_WindowHandleBuffer, hv_Color);
	if (0 != ((hv_GenParamName.TupleLength())>0))
	{
		TupleFind(hv_GenParamName, "colored", &hv_Indices1);
		TupleFind(hv_GenParamName, "color", &hv_Indices2);
		if (0 != (HTuple(hv_Indices1[0]) != -1))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])]) == 3))
			{
				hv_Color.Clear();
				hv_Color[0] = "red";
				hv_Color[1] = "green";
				hv_Color[2] = "blue";
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])]) == 6))
			{
				hv_Color.Clear();
				hv_Color[0] = "red";
				hv_Color[1] = "green";
				hv_Color[2] = "blue";
				hv_Color[3] = "cyan";
				hv_Color[4] = "magenta";
				hv_Color[5] = "yellow";
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])]) == 12))
			{
				hv_Color.Clear();
				hv_Color[0] = "red";
				hv_Color[1] = "green";
				hv_Color[2] = "blue";
				hv_Color[3] = "cyan";
				hv_Color[4] = "magenta";
				hv_Color[5] = "yellow";
				hv_Color[6] = "coral";
				hv_Color[7] = "slate blue";
				hv_Color[8] = "spring green";
				hv_Color[9] = "orange red";
				hv_Color[10] = "pink";
				hv_Color[11] = "gold";
			}
		}
		else if (0 != (HTuple(hv_Indices2[0]) != -1))
		{
			hv_Color = HTuple(hv_GenParamValue[HTuple(hv_Indices2[0])]);
		}
	}
	{
		HTuple end_val70 = (hv_ObjectModel3DID.TupleLength()) - 1;
		HTuple step_val70 = 1;
		for (hv_J = 0; hv_J.Continue(end_val70, step_val70); hv_J += step_val70)
		{
			hv_I = HTuple(hv_Idx[hv_J]);
			if (0 != (HTuple(HTuple(HTuple(HTuple(hv_HasPolygons[hv_I]) == HTuple("true")).TupleOr(HTuple(hv_HasTri[hv_I]) == HTuple("true"))).TupleOr(HTuple(hv_HasPoints[hv_I]) == HTuple("true"))).TupleOr(HTuple(hv_HasLines[hv_I]) == HTuple("true"))))
			{
				if (0 != ((hv_GenParamName.TupleLength())>0))
				{
					TupleFind(hv_GenParamName, "color_" + hv_I, &hv_Indices3);
					if (0 != (HTuple(hv_Indices3[0]) != -1))
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
					}
					else
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I % (hv_Color.TupleLength())]));
					}
				}
				if (0 != ((hv_PosesOut.TupleLength()) >= ((hv_I * 7) + 6)))
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(hv_I * 7, (hv_I * 7) + 6);
				}
				else
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(0, 6);
				}
				if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
				{
					ProjectObjectModel3d(&(*ho_ModelContours), HTuple(hv_ObjectModel3DID[hv_I]),
						hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
					DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
				}
				else
				{
					PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
					SampleObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), "fast", 0.01*HTuple(hv_Diameter[hv_I]),
						HTuple(), HTuple(), &hv_SampledObjectModel3D);
					ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam,
						hv_Pose, "point_size", 1);
					GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_x", &hv_X);
					GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_y", &hv_Y);
					GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_z", &hv_Z);
					PoseToHomMat3d(hv_Pose, &hv_HomMat3D1);
					AffineTransPoint3d(hv_HomMat3D1, hv_X, hv_Y, hv_Z, &hv_Qx, &hv_Qy, &hv_Qz);
					Project3dPoint(hv_Qx, hv_Qy, hv_Qz, hv_CamParam, &hv_Row, &hv_Column);
					DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
					ClearObjectModel3d(hv_SampledObjectModel3D);
				}
			}
			else
			{
				if (0 != ((hv_GenParamName.TupleLength())>0))
				{
					TupleFind(hv_GenParamName, "color_" + hv_I, &hv_Indices3);
					if (0 != (HTuple(hv_Indices3[0]) != -1))
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
					}
					else
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I % (hv_Color.TupleLength())]));
					}
				}
				if (0 != ((hv_PosesOut.TupleLength()) >= ((hv_I * 7) + 6)))
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(hv_I * 7, (hv_I * 7) + 6);
				}
				else
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(0, 6);
				}
				if (0 != (HTuple(hv_IsPrimitive[hv_I]) == HTuple("true")))
				{
					try
					{
						ConvexHullObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), &hv_ObjectModel3DConvexHull);
						if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
						{
							ProjectObjectModel3d(&(*ho_ModelContours), hv_ObjectModel3DConvexHull,
								hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
							DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
						}
						else
						{
							PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
							SampleObjectModel3d(hv_ObjectModel3DConvexHull, "fast", 0.01*HTuple(hv_Diameter[hv_I]),
								HTuple(), HTuple(), &hv_SampledObjectModel3D);
							ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam,
								hv_Pose, "point_size", 1);
							DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
							ClearObjectModel3d(hv_SampledObjectModel3D);
						}
						ClearObjectModel3d(hv_ObjectModel3DConvexHull);
					}
					// catch (Exception) 
					catch (HException &HDevExpDefaultException)
					{
						HDevExpDefaultException.ToHTuple(&hv_Exception);
					}
				}
			}
		}
	}
	SetSystem("opengl_hidden_surface_removal_enable", hv_OpenGlHiddenSurface);
	return;
}

// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl_visualize_object_model_3d(HObject *ho_ModelContours,
	HTuple hv_ObjectModel3DID, HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer,
	HTuple hv_CamParam, HTuple hv_PosesOut)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Idx, hv_CustomParamName, hv_CustomParamValue;
	HTuple  hv_Font, hv_IndicesDispBackGround, hv_Indices, hv_ImageWidth;
	HTuple  hv_HasPolygons, hv_HasTri, hv_HasPoints, hv_HasLines;
	HTuple  hv_NumPoints, hv_IsPrimitive, hv_Center, hv_Diameter;
	HTuple  hv_OpenGlHiddenSurface, hv_CenterX, hv_CenterY;
	HTuple  hv_CenterZ, hv_PosObjectsZ, hv_I, hv_Pose, hv_HomMat3DObj;
	HTuple  hv_PosObjCenterX, hv_PosObjCenterY, hv_PosObjCenterZ;
	HTuple  hv_PosObjectsX, hv_PosObjectsY, hv_Color, hv_Indices1;
	HTuple  hv_Indices2, hv_J, hv_Indices3, hv_HomMat3D, hv_SampledObjectModel3D;
	HTuple  hv_X, hv_Y, hv_Z, hv_HomMat3D1, hv_Qx, hv_Qy, hv_Qz;
	HTuple  hv_Row, hv_Column, hv_ObjectModel3DConvexHull, hv_Exception;

	//This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d
	//call for small objects. Large objects are sampled down to display.
	hv_Idx = hv_GenParamName.TupleFind("point_size");
	if (0 != (HTuple(hv_Idx.TupleLength()).TupleAnd(hv_Idx != -1)))
	{
		hv_CustomParamName = "point_size";
		hv_CustomParamValue = HTuple(hv_GenParamValue[hv_Idx]);
		if (0 != (hv_CustomParamValue == 1))
		{
			hv_CustomParamValue = 0;
		}
	}
	else
	{
		hv_CustomParamName = HTuple();
		hv_CustomParamValue = HTuple();
	}
	GetFont(hv_WindowHandleBuffer, &hv_Font);
	TupleFind(hv_GenParamName, "disp_background", &hv_IndicesDispBackGround);
	if (0 != (hv_IndicesDispBackGround != -1))
	{
		TupleFind(HTuple(hv_GenParamName[hv_IndicesDispBackGround]), "false", &hv_Indices);
		if (0 != (hv_Indices != -1))
		{
			ClearWindow(hv_WindowHandleBuffer);
		}
	}
	set_display_font(hv_WindowHandleBuffer, 11, "mono", "false", "false");
	get_cam_par_data(hv_CamParam, "image_width", &hv_ImageWidth);
	disp_message(hv_WindowHandleBuffer, "OpenGL missing!", "image", 5, hv_ImageWidth - 130,
		"red", "false");
	SetFont(hv_WindowHandleBuffer, hv_Font);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_polygons", &hv_HasPolygons);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_triangles", &hv_HasTri);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_points", &hv_HasPoints);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_lines", &hv_HasLines);
	GetObjectModel3dParams(hv_ObjectModel3DID, "num_points", &hv_NumPoints);
	GetObjectModel3dParams(hv_ObjectModel3DID, "has_primitive_data", &hv_IsPrimitive);
	GetObjectModel3dParams(hv_ObjectModel3DID, "center", &hv_Center);
	GetObjectModel3dParams(hv_ObjectModel3DID, "diameter", &hv_Diameter);
	GetSystem("opengl_hidden_surface_removal_enable", &hv_OpenGlHiddenSurface);
	SetSystem("opengl_hidden_surface_removal_enable", "false");
	//Sort the objects by inverse z
	hv_CenterX = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0, (hv_Center.TupleLength()) - 1, 3)];
	hv_CenterY = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0, (hv_Center.TupleLength()) - 1, 3) + 1];
	hv_CenterZ = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0, (hv_Center.TupleLength()) - 1, 3) + 2];
	hv_PosObjectsZ = HTuple();
	if (0 != ((hv_PosesOut.TupleLength())>7))
	{
		{
			HTuple end_val41 = (hv_ObjectModel3DID.TupleLength()) - 1;
			HTuple step_val41 = 1;
			for (hv_I = 0; hv_I.Continue(end_val41, step_val41); hv_I += step_val41)
			{
				hv_Pose = hv_PosesOut.TupleSelectRange(hv_I * 7, (hv_I * 7) + 6);
				PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
				AffineTransPoint3d(hv_HomMat3DObj, HTuple(hv_CenterX[hv_I]), HTuple(hv_CenterY[hv_I]),
					HTuple(hv_CenterZ[hv_I]), &hv_PosObjCenterX, &hv_PosObjCenterY, &hv_PosObjCenterZ);
				hv_PosObjectsZ = hv_PosObjectsZ.TupleConcat(hv_PosObjCenterZ);
			}
		}
	}
	else
	{
		hv_Pose = hv_PosesOut.TupleSelectRange(0, 6);
		PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
		AffineTransPoint3d(hv_HomMat3DObj, hv_CenterX, hv_CenterY, hv_CenterZ, &hv_PosObjectsX,
			&hv_PosObjectsY, &hv_PosObjectsZ);
	}
	hv_Idx = HTuple(hv_PosObjectsZ.TupleSortIndex()).TupleInverse();
	hv_Color = "white";
	SetColor(hv_WindowHandleBuffer, hv_Color);
	if (0 != ((hv_GenParamName.TupleLength())>0))
	{
		TupleFind(hv_GenParamName, "colored", &hv_Indices1);
		TupleFind(hv_GenParamName, "color", &hv_Indices2);
		if (0 != (HTuple(hv_Indices1[0]) != -1))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])]) == 3))
			{
				hv_Color.Clear();
				hv_Color[0] = "red";
				hv_Color[1] = "green";
				hv_Color[2] = "blue";
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])]) == 6))
			{
				hv_Color.Clear();
				hv_Color[0] = "red";
				hv_Color[1] = "green";
				hv_Color[2] = "blue";
				hv_Color[3] = "cyan";
				hv_Color[4] = "magenta";
				hv_Color[5] = "yellow";
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])]) == 12))
			{
				hv_Color.Clear();
				hv_Color[0] = "red";
				hv_Color[1] = "green";
				hv_Color[2] = "blue";
				hv_Color[3] = "cyan";
				hv_Color[4] = "magenta";
				hv_Color[5] = "yellow";
				hv_Color[6] = "coral";
				hv_Color[7] = "slate blue";
				hv_Color[8] = "spring green";
				hv_Color[9] = "orange red";
				hv_Color[10] = "pink";
				hv_Color[11] = "gold";
			}
		}
		else if (0 != (HTuple(hv_Indices2[0]) != -1))
		{
			hv_Color = HTuple(hv_GenParamValue[HTuple(hv_Indices2[0])]);
		}
	}
	{
		HTuple end_val70 = (hv_ObjectModel3DID.TupleLength()) - 1;
		HTuple step_val70 = 1;
		for (hv_J = 0; hv_J.Continue(end_val70, step_val70); hv_J += step_val70)
		{
			hv_I = HTuple(hv_Idx[hv_J]);
			if (0 != (HTuple(HTuple(HTuple(HTuple(hv_HasPolygons[hv_I]) == HTuple("true")).TupleOr(HTuple(hv_HasTri[hv_I]) == HTuple("true"))).TupleOr(HTuple(hv_HasPoints[hv_I]) == HTuple("true"))).TupleOr(HTuple(hv_HasLines[hv_I]) == HTuple("true"))))
			{
				if (0 != ((hv_GenParamName.TupleLength())>0))
				{
					TupleFind(hv_GenParamName, "color_" + hv_I, &hv_Indices3);
					if (0 != (HTuple(hv_Indices3[0]) != -1))
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
					}
					else
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I % (hv_Color.TupleLength())]));
					}
				}
				if (0 != ((hv_PosesOut.TupleLength()) >= ((hv_I * 7) + 6)))
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(hv_I * 7, (hv_I * 7) + 6);
				}
				else
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(0, 6);
				}
				if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
				{
					ProjectObjectModel3d(&(*ho_ModelContours), HTuple(hv_ObjectModel3DID[hv_I]),
						hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
					DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
				}
				else
				{
					PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
					SampleObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), "fast", 0.01*HTuple(hv_Diameter[hv_I]),
						HTuple(), HTuple(), &hv_SampledObjectModel3D);
					ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam,
						hv_Pose, "point_size", 1);
					GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_x", &hv_X);
					GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_y", &hv_Y);
					GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_z", &hv_Z);
					PoseToHomMat3d(hv_Pose, &hv_HomMat3D1);
					AffineTransPoint3d(hv_HomMat3D1, hv_X, hv_Y, hv_Z, &hv_Qx, &hv_Qy, &hv_Qz);
					Project3dPoint(hv_Qx, hv_Qy, hv_Qz, hv_CamParam, &hv_Row, &hv_Column);
					DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
					ClearObjectModel3d(hv_SampledObjectModel3D);
				}
			}
			else
			{
				if (0 != ((hv_GenParamName.TupleLength())>0))
				{
					TupleFind(hv_GenParamName, "color_" + hv_I, &hv_Indices3);
					if (0 != (HTuple(hv_Indices3[0]) != -1))
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
					}
					else
					{
						SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I % (hv_Color.TupleLength())]));
					}
				}
				if (0 != ((hv_PosesOut.TupleLength()) >= ((hv_I * 7) + 6)))
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(hv_I * 7, (hv_I * 7) + 6);
				}
				else
				{
					hv_Pose = hv_PosesOut.TupleSelectRange(0, 6);
				}
				if (0 != (HTuple(hv_IsPrimitive[hv_I]) == HTuple("true")))
				{
					try
					{
						ConvexHullObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), &hv_ObjectModel3DConvexHull);
						if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
						{
							ProjectObjectModel3d(&(*ho_ModelContours), hv_ObjectModel3DConvexHull,
								hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
							DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
						}
						else
						{
							PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
							SampleObjectModel3d(hv_ObjectModel3DConvexHull, "fast", 0.01*HTuple(hv_Diameter[hv_I]),
								HTuple(), HTuple(), &hv_SampledObjectModel3D);
							ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam,
								hv_Pose, "point_size", 1);
							DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
							ClearObjectModel3d(hv_SampledObjectModel3D);
						}
						ClearObjectModel3d(hv_ObjectModel3DConvexHull);
					}
					// catch (Exception) 
					catch (HException &HDevExpDefaultException)
					{
						HDevExpDefaultException.ToHTuple(&hv_Exception);
					}
				}
			}
		}
	}
	SetSystem("opengl_hidden_surface_removal_enable", hv_OpenGlHiddenSurface);
	return;
}

void disp_slider(HTuple hv_WindowHandle, HTuple hv_Row, HTuple hv_TotalHeight, HTuple hv_ColLabel,
	HTuple hv_ColValue, HTuple hv_ColSliderStart, HTuple hv_ColSliderEnd, HTuple hv_Label,
	HTuple hv_ValueStart, HTuple hv_ValueEnd, HTuple hv_ValueCurr, HTuple hv_FormatString)
{

	// Local iconic variables
	HObject  ho_ButtonRegion, ho_RegionBorder;

	// Local control variables
	HTuple  hv_BarHeight, hv_ButtonHeight, hv_ButtonWidth;
	HTuple  hv_RowMid, hv_SliderPosRel, hv_SliderColMid, hv_Rows;
	HTuple  hv_Cols;

	hv_BarHeight = 2;
	hv_ButtonHeight = hv_TotalHeight*0.6;
	hv_ButtonWidth = 3;

	hv_RowMid = hv_Row + (hv_TotalHeight / 2);
	//dev_get_window (WindowHandle)
	//dev_clear_window ()

	//The long bar of the slider
	SetColor(hv_WindowHandle, "light gray");
	DispLine(hv_WindowHandle, hv_RowMid, hv_ColSliderStart, hv_RowMid, hv_ColSliderEnd);
	DispLine(hv_WindowHandle, hv_RowMid - (hv_ButtonHeight / 2), hv_ColSliderStart, hv_RowMid + (hv_ButtonHeight / 2),
		hv_ColSliderStart);
	DispLine(hv_WindowHandle, hv_RowMid - (hv_ButtonHeight / 2), hv_ColSliderEnd, hv_RowMid + (hv_ButtonHeight / 2),
		hv_ColSliderEnd);

	//The slider itself
	hv_SliderPosRel = ((hv_ValueCurr - hv_ValueStart)*1.0) / (hv_ValueEnd - hv_ValueStart);
	if (0 != (hv_SliderPosRel<0))
	{
		hv_SliderPosRel = 0;
	}
	else if (0 != (hv_SliderPosRel>1))
	{
		hv_SliderPosRel = 1;
	}
	hv_SliderColMid = hv_ColSliderStart + (hv_SliderPosRel*(hv_ColSliderEnd - hv_ColSliderStart));
	GenRectangle1(&ho_ButtonRegion, hv_RowMid - (hv_ButtonHeight / 2), hv_SliderColMid - (hv_ButtonWidth / 2),
		hv_RowMid + (hv_ButtonHeight / 2), hv_SliderColMid + (hv_ButtonWidth / 2));
	SetDraw(hv_WindowHandle, "fill");
	SetColor(hv_WindowHandle, "dark olive green");
	DispRegion(ho_ButtonRegion, hv_WindowHandle);
	GetRegionContour(ho_ButtonRegion, &hv_Rows, &hv_Cols);
	SetColor(hv_WindowHandle, "dim gray");
	GenRegionPoints(&ho_RegionBorder, hv_Rows, hv_Cols);
	DispRegion(ho_RegionBorder, hv_WindowHandle);

	//Label
	DispText(hv_WindowHandle, hv_Label, "window", hv_Row, hv_ColLabel, "white", "box",
		"false");

	//Value
	DispText(hv_WindowHandle, hv_ValueCurr.TupleString(hv_FormatString), "window",
		hv_Row, hv_ColValue, "white", "box", "false");

	return;

}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor, HTuple hv_ButtonColor)
{

	// Local iconic variables
	HObject  ho_UpperLeft, ho_LowerRight, ho_Rectangle;

	// Local control variables
	HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
	HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
	HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_Exception;
	HTuple  hv_Fac, hv_RGB, hv_RGBL, hv_RGBD, hv_ButtonColorBorderL;
	HTuple  hv_ButtonColorBorderD, hv_MaxAscent, hv_MaxDescent;
	HTuple  hv_MaxWidth, hv_MaxHeight, hv_R1, hv_C1, hv_FactorRow;
	HTuple  hv_FactorColumn, hv_Width, hv_Index, hv_Ascent;
	HTuple  hv_Descent, hv_W, hv_H, hv_FrameHeight, hv_FrameWidth;
	HTuple  hv_R2, hv_C2, hv_ClipRegion, hv_DrawMode, hv_BorderWidth;
	HTuple  hv_CurrentColor;

	//This procedure displays text in a graphics window.
	//
	//Input parameters:
	//WindowHandle: The WindowHandle of the graphics window, where
	//   the message should be displayed
	//String: A tuple of strings containing the text message to be displayed
	//CoordSystem: If set to 'window', the text position is given
	//   with respect to the window coordinate system.
	//   If set to 'image', image coordinates are used.
	//   (This may be useful in zoomed images.)
	//Row: The row coordinate of the desired text position
	//   If set to -1, a default value of 12 is used.
	//Column: The column coordinate of the desired text position
	//   If set to -1, a default value of 12 is used.
	//Color: defines the color of the text as string.
	//   If set to [], '' or 'auto' the currently set color is used.
	//   If a tuple of strings is passed, the colors are used cyclically
	//   for each new textline.
	//ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).
	//             The text is written in a box of that color.
	//
	//Prepare window.
	GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
	GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
	GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
	SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
	//
	//Default settings.
	if (0 != (hv_Row == -1))
	{
		hv_Row = 12;
	}
	if (0 != (hv_Column == -1))
	{
		hv_Column = 12;
	}
	if (0 != (hv_TextColor == HTuple()))
	{
		hv_TextColor = "";
	}
	//
	try
	{
		color_string_to_rgb(hv_ButtonColor, &hv_RGB);
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		hv_Exception = "Wrong value of control parameter ButtonColor (must be a valid color string)";
		throw HException(hv_Exception);
	}
	hv_Fac = 0.4;
	hv_RGBL = hv_RGB + ((((255.0 - hv_RGB)*hv_Fac) + 0.5).TupleInt());
	hv_RGBD = hv_RGB - (((hv_RGB*hv_Fac) + 0.5).TupleInt());
	hv_ButtonColorBorderL = "#" + (("" + (hv_RGBL.TupleString("02x"))).TupleSum());
	hv_ButtonColorBorderD = "#" + (("" + (hv_RGBD.TupleString("02x"))).TupleSum());
	//
	hv_String = (("" + hv_String) + "").TupleSplit("\n");
	//
	//Estimate extentions of text depending on font size.
	GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
	if (0 != (hv_CoordSystem == HTuple("window")))
	{
		hv_R1 = hv_Row;
		hv_C1 = hv_Column;
	}
	else
	{
		//Transform image to window coordinates.
		hv_FactorRow = (1.*hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
		hv_FactorColumn = (1.*hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
		hv_R1 = ((hv_Row - hv_Row1Part) + 0.5)*hv_FactorRow;
		hv_C1 = ((hv_Column - hv_Column1Part) + 0.5)*hv_FactorColumn;
	}
	//
	//Display text box depending on text size.
	//
	//Calculate box extents.
	hv_String = (" " + hv_String) + " ";
	hv_Width = HTuple();
	{
		HTuple end_val70 = (hv_String.TupleLength()) - 1;
		HTuple step_val70 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val70, step_val70); hv_Index += step_val70)
		{
			GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, &hv_Descent,
				&hv_W, &hv_H);
			hv_Width = hv_Width.TupleConcat(hv_W);
		}
	}
	hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
	hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
	hv_R2 = hv_R1 + hv_FrameHeight;
	hv_C2 = hv_C1 + hv_FrameWidth;
	//Display rectangles.
	GetSystem("clip_region", &hv_ClipRegion);
	SetSystem("clip_region", "false");
	GetDraw(hv_WindowHandle, &hv_DrawMode);
	SetDraw(hv_WindowHandle, "fill");
	hv_BorderWidth = 2;
	GenRegionPolygonFilled(&ho_UpperLeft, ((((hv_R1 - hv_BorderWidth).TupleConcat(hv_R1 - hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2 + hv_BorderWidth),
		((((hv_C1 - hv_BorderWidth).TupleConcat(hv_C2 + hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1 - hv_BorderWidth));
	GenRegionPolygonFilled(&ho_LowerRight, ((((hv_R2 + hv_BorderWidth).TupleConcat(hv_R1 - hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2 + hv_BorderWidth),
		((((hv_C2 + hv_BorderWidth).TupleConcat(hv_C2 + hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1 - hv_BorderWidth));
	GenRectangle1(&ho_Rectangle, hv_R1, hv_C1, hv_R2, hv_C2);
	SetColor(hv_WindowHandle, hv_ButtonColorBorderL);
	DispObj(ho_UpperLeft, hv_WindowHandle);
	SetColor(hv_WindowHandle, hv_ButtonColorBorderD);
	DispObj(ho_LowerRight, hv_WindowHandle);
	SetColor(hv_WindowHandle, hv_ButtonColor);
	DispObj(ho_Rectangle, hv_WindowHandle);
	SetDraw(hv_WindowHandle, hv_DrawMode);
	SetSystem("clip_region", hv_ClipRegion);
	//Write text.
	{
		HTuple end_val96 = (hv_String.TupleLength()) - 1;
		HTuple step_val96 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val96, step_val96); hv_Index += step_val96)
		{
			hv_CurrentColor = HTuple(hv_TextColor[hv_Index % (hv_TextColor.TupleLength())]);
			if (0 != (HTuple(hv_CurrentColor != HTuple("")).TupleAnd(hv_CurrentColor != HTuple("auto"))))
			{
				SetColor(hv_WindowHandle, hv_CurrentColor);
			}
			else
			{
				SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
			}
			hv_Row = hv_R1 + (hv_MaxHeight*hv_Index);
			DispText(hv_WindowHandle, HTuple(hv_String[hv_Index]), "window", hv_Row, hv_C1,
				hv_CurrentColor, "box", "false");
		}
	}
	//Reset changed window settings.
	SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
	SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
	return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button_visualize_object_model_3d(HTuple hv_WindowHandle, HTuple hv_String,
	HTuple hv_CoordSystem, HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor,
	HTuple hv_ButtonColor)
{

	// Local iconic variables
	HObject  ho_UpperLeft, ho_LowerRight, ho_Rectangle;

	// Local control variables
	HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
	HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
	HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_Exception;
	HTuple  hv_Fac, hv_RGB, hv_RGBL, hv_RGBD, hv_ButtonColorBorderL;
	HTuple  hv_ButtonColorBorderD, hv_MaxAscent, hv_MaxDescent;
	HTuple  hv_MaxWidth, hv_MaxHeight, hv_R1, hv_C1, hv_FactorRow;
	HTuple  hv_FactorColumn, hv_Width, hv_Index, hv_Ascent;
	HTuple  hv_Descent, hv_W, hv_H, hv_FrameHeight, hv_FrameWidth;
	HTuple  hv_R2, hv_C2, hv_ClipRegion, hv_DrawMode, hv_BorderWidth;
	HTuple  hv_CurrentColor;

	//This procedure displays text in a graphics window.
	//
	//Input parameters:
	//WindowHandle: The WindowHandle of the graphics window, where
	//   the message should be displayed
	//String: A tuple of strings containing the text message to be displayed
	//CoordSystem: If set to 'window', the text position is given
	//   with respect to the window coordinate system.
	//   If set to 'image', image coordinates are used.
	//   (This may be useful in zoomed images.)
	//Row: The row coordinate of the desired text position
	//   If set to -1, a default value of 12 is used.
	//Column: The column coordinate of the desired text position
	//   If set to -1, a default value of 12 is used.
	//Color: defines the color of the text as string.
	//   If set to [], '' or 'auto' the currently set color is used.
	//   If a tuple of strings is passed, the colors are used cyclically
	//   for each new textline.
	//ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).
	//             The text is written in a box of that color.
	//
	//Prepare window.
	GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
	GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
	GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
	SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
	//
	//Default settings.
	if (0 != (hv_Row == -1))
	{
		hv_Row = 12;
	}
	if (0 != (hv_Column == -1))
	{
		hv_Column = 12;
	}
	if (0 != (hv_TextColor == HTuple()))
	{
		hv_TextColor = "";
	}
	//
	try
	{
		color_string_to_rgb_visualize_object_model_3d(hv_ButtonColor, &hv_RGB);
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		hv_Exception = "Wrong value of control parameter ButtonColor (must be a valid color string)";
		throw HException(hv_Exception);
	}
	hv_Fac = 0.4;
	hv_RGBL = hv_RGB + ((((255.0 - hv_RGB)*hv_Fac) + 0.5).TupleInt());
	hv_RGBD = hv_RGB - (((hv_RGB*hv_Fac) + 0.5).TupleInt());
	hv_ButtonColorBorderL = "#" + (("" + (hv_RGBL.TupleString("02x"))).TupleSum());
	hv_ButtonColorBorderD = "#" + (("" + (hv_RGBD.TupleString("02x"))).TupleSum());
	//
	hv_String = (("" + hv_String) + "").TupleSplit("\n");
	//
	//Estimate extentions of text depending on font size.
	GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
	if (0 != (hv_CoordSystem == HTuple("window")))
	{
		hv_R1 = hv_Row;
		hv_C1 = hv_Column;
	}
	else
	{
		//Transform image to window coordinates.
		hv_FactorRow = (1.*hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
		hv_FactorColumn = (1.*hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
		hv_R1 = ((hv_Row - hv_Row1Part) + 0.5)*hv_FactorRow;
		hv_C1 = ((hv_Column - hv_Column1Part) + 0.5)*hv_FactorColumn;
	}
	//
	//Display text box depending on text size.
	//
	//Calculate box extents.
	hv_String = (" " + hv_String) + " ";
	hv_Width = HTuple();
	{
		HTuple end_val70 = (hv_String.TupleLength()) - 1;
		HTuple step_val70 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val70, step_val70); hv_Index += step_val70)
		{
			GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, &hv_Descent,
				&hv_W, &hv_H);
			hv_Width = hv_Width.TupleConcat(hv_W);
		}
	}
	hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
	hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
	hv_R2 = hv_R1 + hv_FrameHeight;
	hv_C2 = hv_C1 + hv_FrameWidth;
	//Display rectangles.
	GetSystem("clip_region", &hv_ClipRegion);
	SetSystem("clip_region", "false");
	GetDraw(hv_WindowHandle, &hv_DrawMode);
	SetDraw(hv_WindowHandle, "fill");
	hv_BorderWidth = 2;
	GenRegionPolygonFilled(&ho_UpperLeft, ((((hv_R1 - hv_BorderWidth).TupleConcat(hv_R1 - hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2 + hv_BorderWidth),
		((((hv_C1 - hv_BorderWidth).TupleConcat(hv_C2 + hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1 - hv_BorderWidth));
	GenRegionPolygonFilled(&ho_LowerRight, ((((hv_R2 + hv_BorderWidth).TupleConcat(hv_R1 - hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2 + hv_BorderWidth),
		((((hv_C2 + hv_BorderWidth).TupleConcat(hv_C2 + hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1 - hv_BorderWidth));
	GenRectangle1(&ho_Rectangle, hv_R1, hv_C1, hv_R2, hv_C2);
	SetColor(hv_WindowHandle, hv_ButtonColorBorderL);
	DispObj(ho_UpperLeft, hv_WindowHandle);
	SetColor(hv_WindowHandle, hv_ButtonColorBorderD);
	DispObj(ho_LowerRight, hv_WindowHandle);
	SetColor(hv_WindowHandle, hv_ButtonColor);
	DispObj(ho_Rectangle, hv_WindowHandle);
	SetDraw(hv_WindowHandle, hv_DrawMode);
	SetSystem("clip_region", hv_ClipRegion);
	//Write text.
	{
		HTuple end_val96 = (hv_String.TupleLength()) - 1;
		HTuple step_val96 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val96, step_val96); hv_Index += step_val96)
		{
			hv_CurrentColor = HTuple(hv_TextColor[hv_Index % (hv_TextColor.TupleLength())]);
			if (0 != (HTuple(hv_CurrentColor != HTuple("")).TupleAnd(hv_CurrentColor != HTuple("auto"))))
			{
				SetColor(hv_WindowHandle, hv_CurrentColor);
			}
			else
			{
				SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
			}
			hv_Row = hv_R1 + (hv_MaxHeight*hv_Index);
			DispText(hv_WindowHandle, HTuple(hv_String[hv_Index]), "window", hv_Row, hv_C1,
				hv_CurrentColor, "box", "false");
		}
	}
	//Reset changed window settings.
	SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
	SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
	return;
}

// Chapter: Graphics / Output
void disp_title_and_information(HTuple hv_Parameters, HTuple hv_WindowHandle, HTuple hv_Title,
	HTuple hv_Information)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_gInfoDecor, hv_gInfoPos, hv_gTitlePos;
	HTuple  hv_gTitleDecor, hv_WinRow, hv_WinColumn, hv_WinWidth;
	HTuple  hv_WinHeight, hv_NumTitleLines, hv_Row, hv_Column;
	HTuple  hv_TextWidth, hv_NumInfoLines, hv_Ascent, hv_Descent;
	HTuple  hv_Width, hv_Height;

	GetMessageTuple(hv_Parameters, "gInfoDecor", &hv_gInfoDecor);
	GetMessageTuple(hv_Parameters, "gInfoPos", &hv_gInfoPos);
	GetMessageTuple(hv_Parameters, "gTitlePos", &hv_gTitlePos);
	GetMessageTuple(hv_Parameters, "gTitleDecor", &hv_gTitleDecor);
	//
	GetWindowExtents(hv_WindowHandle, &hv_WinRow, &hv_WinColumn, &hv_WinWidth, &hv_WinHeight);
	hv_Title = (("" + hv_Title) + "").TupleSplit("\n");
	hv_NumTitleLines = hv_Title.TupleLength();
	if (0 != (hv_NumTitleLines>0))
	{
		hv_Row = 12;
		if (0 != (hv_gTitlePos == HTuple("UpperLeft")))
		{
			hv_Column = 12;
		}
		else if (0 != (hv_gTitlePos == HTuple("UpperCenter")))
		{
			max_line_width(hv_WindowHandle, hv_Title, &hv_TextWidth);
			hv_Column = (hv_WinWidth / 2) - (hv_TextWidth / 2);
		}
		else if (0 != (hv_gTitlePos == HTuple("UpperRight")))
		{
			if (0 != (HTuple(hv_gTitleDecor[1]) == HTuple("true")))
			{
				max_line_width(hv_WindowHandle, hv_Title + "  ", &hv_TextWidth);
			}
			else
			{
				max_line_width(hv_WindowHandle, hv_Title, &hv_TextWidth);
			}
			hv_Column = (hv_WinWidth - hv_TextWidth) - 10;
		}
		else
		{
			//Unknown position!
			// stop(...); only in hdevelop
		}
		disp_message(hv_WindowHandle, hv_Title, "window", hv_Row, hv_Column, HTuple(hv_gTitleDecor[0]),
			HTuple(hv_gTitleDecor[1]));
	}
	hv_Information = (("" + hv_Information) + "").TupleSplit("\n");
	hv_NumInfoLines = hv_Information.TupleLength();
	if (0 != (hv_NumInfoLines>0))
	{
		if (0 != (hv_gInfoPos == HTuple("UpperLeft")))
		{
			hv_Row = 12;
			hv_Column = 12;
		}
		else if (0 != (hv_gInfoPos == HTuple("UpperRight")))
		{
			if (0 != (HTuple(hv_gInfoDecor[1]) == HTuple("true")))
			{
				max_line_width(hv_WindowHandle, hv_Information + "  ", &hv_TextWidth);
			}
			else
			{
				max_line_width(hv_WindowHandle, hv_Information, &hv_TextWidth);
			}
			hv_Row = 12;
			hv_Column = (hv_WinWidth - hv_TextWidth) - 12;
		}
		else if (0 != (hv_gInfoPos == HTuple("LowerLeft")))
		{
			GetStringExtents(hv_WindowHandle, hv_Information, &hv_Ascent, &hv_Descent,
				&hv_Width, &hv_Height);
			hv_Row = (hv_WinHeight - (((HTuple(0).TupleMax2(hv_NumInfoLines - 1))*(hv_Ascent + hv_Descent)) + hv_Height)) - 70;
			hv_Column = 12;
		}
		else
		{
			//Unknown position!
			// stop(...); only in hdevelop
		}
		disp_message(hv_WindowHandle, hv_Information, "window", hv_Row, hv_Column, HTuple(hv_gInfoDecor[0]),
			HTuple(hv_gInfoDecor[1]));
	}
	//
	return;
}

// Chapter: Graphics / Output
void disp_title_and_information_visualize_object_model_3d(HTuple hv_WindowHandle,
	HTuple hv_Title, HTuple hv_Information)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_WinRow, hv_WinColumn, hv_WinWidth;
	HTuple  hv_WinHeight, hv_NumTitleLines, hv_Row, hv_Column;
	HTuple  hv_TextWidth, hv_NumInfoLines, hv_Ascent, hv_Descent;
	HTuple  hv_Width, hv_Height;

	//global tuple gInfoDecor
	//global tuple gInfoPos
	//global tuple gTitlePos
	//global tuple gTitleDecor
	//
	GetWindowExtents(hv_WindowHandle, &hv_WinRow, &hv_WinColumn, &hv_WinWidth, &hv_WinHeight);
	hv_Title = (("" + hv_Title) + "").TupleSplit("\n");
	hv_NumTitleLines = hv_Title.TupleLength();
	if (0 != (hv_NumTitleLines>0))
	{
		hv_Row = 12;
		if (0 != (ExpGetGlobalVar_gTitlePos() == HTuple("UpperLeft")))
		{
			hv_Column = 12;
		}
		else if (0 != (ExpGetGlobalVar_gTitlePos() == HTuple("UpperCenter")))
		{
			max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Title, &hv_TextWidth);
			hv_Column = (hv_WinWidth / 2) - (hv_TextWidth / 2);
		}
		else if (0 != (ExpGetGlobalVar_gTitlePos() == HTuple("UpperRight")))
		{
			if (0 != (HTuple(ExpGetGlobalVar_gTitleDecor()[1]) == HTuple("true")))
			{
				max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Title + "  ",
					&hv_TextWidth);
			}
			else
			{
				max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Title, &hv_TextWidth);
			}
			hv_Column = (hv_WinWidth - hv_TextWidth) - 10;
		}
		else
		{
			//Unknown position!
			// stop(...); only in hdevelop
		}
		disp_message(hv_WindowHandle, hv_Title, "window", hv_Row, hv_Column, HTuple(ExpGetGlobalVar_gTitleDecor()[0]),
			HTuple(ExpGetGlobalVar_gTitleDecor()[1]));
	}
	hv_Information = (("" + hv_Information) + "").TupleSplit("\n");
	hv_NumInfoLines = hv_Information.TupleLength();
	if (0 != (hv_NumInfoLines>0))
	{
		if (0 != (ExpGetGlobalVar_gInfoPos() == HTuple("UpperLeft")))
		{
			hv_Row = 12;
			hv_Column = 12;
		}
		else if (0 != (ExpGetGlobalVar_gInfoPos() == HTuple("UpperRight")))
		{
			if (0 != (HTuple(ExpGetGlobalVar_gInfoDecor()[1]) == HTuple("true")))
			{
				max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Information + "  ",
					&hv_TextWidth);
			}
			else
			{
				max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Information,
					&hv_TextWidth);
			}
			hv_Row = 12;
			hv_Column = (hv_WinWidth - hv_TextWidth) - 12;
		}
		else if (0 != (ExpGetGlobalVar_gInfoPos() == HTuple("LowerLeft")))
		{
			GetStringExtents(hv_WindowHandle, hv_Information, &hv_Ascent, &hv_Descent,
				&hv_Width, &hv_Height);
			hv_Row = (hv_WinHeight - (((HTuple(0).TupleMax2(hv_NumInfoLines - 1))*(hv_Ascent + hv_Descent)) + hv_Height)) - 12;
			hv_Column = 12;
		}
		else
		{
			//Unknown position!
			// stop(...); only in hdevelop
		}
		disp_message(hv_WindowHandle, hv_Information, "window", hv_Row, hv_Column, HTuple(ExpGetGlobalVar_gInfoDecor()[0]),
			HTuple(ExpGetGlobalVar_gInfoDecor()[1]));
	}
	//
	return;
}

// Chapter: Graphics / Output
// Short Description: Renders 3D object models in a buffer window. 
void dump_image_output(HObject ho_BackgroundImage, HTuple hv_Parameters, HTuple hv_WindowHandleBuffer,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage,
	HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball,
	HTuple hv_DisplayButtons, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol,
	HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter,
	HTuple hv_RotationCenter, HTuple hv_Type, HTuple hv_Message, HTuple hv_DispViewPoint,
	HTuple hv_ViewPoint)
{

	// Local iconic variables
	HObject  ho_ModelContours, ho_TrackballContour;
	HObject  ho_CrossRotCenter;

	// Local control variables
	HTuple  hv_gUsesOpenGL, hv_gAlphaDeselected, hv_gButtons;
	HTuple  hv_Exception, hv_Index, hv_Exception1, hv_DeselectedIdx;
	HTuple  hv_DeselectedName, hv_DeselectedValue, hv_gLabelsDecor;
	HTuple  hv_Pose, hv_HomMat3D, hv_Center, hv_CenterCamX;
	HTuple  hv_CenterCamY, hv_CenterCamZ, hv_CenterRow, hv_CenterCol;
	HTuple  hv_Label, hv_Ascent, hv_Descent, hv_TextWidth, hv_TextHeight;
	HTuple  hv_gDispObjOffset, hv_RotCenterRow, hv_RotCenterCol;
	HTuple  hv_Orientation, hv_Colors, hv_Type1, hv_Message1;
	HTuple  hv_Type2, hv_Message2;

	GetMessageTuple(hv_Parameters, "gUsesOpenGL", &hv_gUsesOpenGL);
	GetMessageTuple(hv_Parameters, "gAlphaDeselected", &hv_gAlphaDeselected);
	GetMessageTuple(hv_Parameters, "gButtons", &hv_gButtons);

	//
	//Display background image
	ClearWindow(hv_WindowHandleBuffer);
	if (0 != hv_ColorImage)
	{
		DispColor(ho_BackgroundImage, hv_WindowHandleBuffer);
	}
	else
	{
		DispImage(ho_BackgroundImage, hv_WindowHandleBuffer);
	}
	//
	//Display objects
	if (0 != ((hv_SelectedObject.TupleSum()) == (hv_SelectedObject.TupleLength())))
	{
		if (0 != (hv_gUsesOpenGL == HTuple("true")))
		{
			try
			{
				DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
				if (0 != (HTuple(HTuple(HTuple(hv_Exception[0]) == 5185).TupleOr(HTuple(hv_Exception[0]) == 5188)).TupleOr(HTuple(hv_Exception[0]) == 5187)))
				{
					hv_gUsesOpenGL = "false";
					SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
				}
				else
				{
					throw HException(hv_Exception);
				}
			}
		}
		if (0 != (hv_gUsesOpenGL == HTuple("false")))
		{
			//* NO OpenGL, use fallback
			disp_object_model_no_opengl(&ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName,
				hv_GenParamValue, hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
		}
	}
	else
	{
		{
			HTuple end_val32 = (hv_AlphaOrig.TupleLength()) - 1;
			HTuple step_val32 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val32, step_val32); hv_Index += step_val32)
			{
				if (0 != (HTuple(hv_SelectedObject[hv_Index]) == 1))
				{
					SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
				}
				else
				{
					SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", hv_gAlphaDeselected);
				}
			}
		}
		try
		{
			if (0 != (hv_gUsesOpenGL == HTuple("false")))
			{
				throw HException(HTuple());
			}
			DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
		}
		// catch (Exception1) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception1);
			//* NO OpenGL, use fallback
			hv_DeselectedIdx = hv_SelectedObject.TupleFind(0);
			if (0 != (hv_DeselectedIdx != -1))
			{
				hv_DeselectedName = "color_" + hv_DeselectedIdx;
				hv_DeselectedValue = HTuple(hv_DeselectedName.TupleLength(), "gray");
			}
			disp_object_model_no_opengl(&ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName.TupleConcat(hv_DeselectedName),
				hv_GenParamValue.TupleConcat(hv_DeselectedValue), hv_WindowHandleBuffer,
				hv_CamParam, hv_Poses);
		}
		{
			HTuple end_val53 = (hv_AlphaOrig.TupleLength()) - 1;
			HTuple step_val53 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val53, step_val53); hv_Index += step_val53)
			{
				SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
			}
		}
	}
	//
	//Display labels
	if (0 != (hv_Labels != 0))
	{
		GetMessageTuple(hv_Parameters, "gLabelsDecor", &hv_gLabelsDecor);
		SetColor(hv_WindowHandleBuffer, HTuple(hv_gLabelsDecor[0]));
		{
			HTuple end_val62 = (hv_ObjectModel3DID.TupleLength()) - 1;
			HTuple step_val62 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val62, step_val62); hv_Index += step_val62)
			{
				//Project the center point of the current model
				hv_Pose = hv_Poses.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
				PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
				GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_Index]), "center", &hv_Center);
				AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]),
					HTuple(hv_Center[2]), &hv_CenterCamX, &hv_CenterCamY, &hv_CenterCamZ);
				Project3dPoint(hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, hv_CamParam, &hv_CenterRow,
					&hv_CenterCol);
				hv_Label = HTuple(hv_Labels[hv_Index]);
				if (0 != (hv_Label != HTuple("")))
				{
					GetStringExtents(hv_WindowHandleBuffer, hv_Label, &hv_Ascent, &hv_Descent,
						&hv_TextWidth, &hv_TextHeight);
					GetMessageTuple(hv_Parameters, "gDispObjOffset", &hv_gDispObjOffset);
					disp_message(hv_WindowHandleBuffer, hv_Label, "window", (hv_CenterRow - (hv_TextHeight / 2)) + HTuple(hv_gDispObjOffset[0]),
						(hv_CenterCol - (hv_TextWidth / 2)) + HTuple(hv_gDispObjOffset[1]), HTuple(),
						HTuple(hv_gLabelsDecor[1]));
				}
			}
		}
	}
	//
	//Visualize the trackball if desired
	if (0 != hv_VisualizeTrackball)
	{
		SetLineWidth(hv_WindowHandleBuffer, 1);
		GenEllipseContourXld(&ho_TrackballContour, hv_TrackballCenterRow, hv_TrackballCenterCol,
			0, hv_TrackballRadiusPixel, hv_TrackballRadiusPixel, 0, 6.28318, "positive",
			1.5);
		SetColor(hv_WindowHandleBuffer, "dim gray");
		DispXld(ho_TrackballContour, hv_WindowHandleBuffer);
	}
	//
	//Visualize the rotation center if desired
	if (0 != (HTuple(hv_VisualizeRotationCenter != 0).TupleAnd((hv_RotationCenter.TupleLength()) == 3)))
	{
		if (0 != (HTuple(hv_RotationCenter[2])<1e-10))
		{
			hv_RotationCenter[2] = 1e-10;
		}
		Project3dPoint(HTuple(hv_RotationCenter[0]), HTuple(hv_RotationCenter[1]), HTuple(hv_RotationCenter[2]),
			hv_CamParam, &hv_RotCenterRow, &hv_RotCenterCol);
		hv_Orientation = HTuple(90).TupleRad();
		if (0 != (hv_VisualizeRotationCenter == 1))
		{
			hv_Orientation = HTuple(45).TupleRad();
		}
		GenCrossContourXld(&ho_CrossRotCenter, hv_RotCenterRow, hv_RotCenterCol, hv_TrackballRadiusPixel / 25.0,
			hv_Orientation);
		SetLineWidth(hv_WindowHandleBuffer, 3);
		QueryColor(hv_WindowHandleBuffer, &hv_Colors);
		SetColor(hv_WindowHandleBuffer, "light gray");
		DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
		SetLineWidth(hv_WindowHandleBuffer, 1);
		SetColor(hv_WindowHandleBuffer, "dim gray");
		DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
	}
	//
	//Display title
	if (0 != ((hv_Type.TupleLength()) == 1))
	{
		hv_Type1 = hv_Type;
		hv_Message1 = hv_Message;
		write_note(hv_WindowHandleBuffer, hv_Type1, hv_Message1);
	}
	else if (0 != ((hv_Type.TupleLength()) == 2))
	{
		hv_Type1 = ((const HTuple&)hv_Type)[0];
		hv_Type2 = ((const HTuple&)hv_Type)[1];
		hv_Message1 = ((const HTuple&)hv_Message)[0];
		hv_Message2 = hv_Message.TupleSelectRange(1, (hv_Message.TupleLength()) - 1);
		write_note(hv_WindowHandleBuffer, hv_Type1, hv_Message1);
		SetTposition(hv_WindowHandleBuffer, 1, 12);
		write_note(hv_WindowHandleBuffer, hv_Type2, hv_Message2);
	}
	if (0 != (hv_DispViewPoint == HTuple("true")))
	{
		disp_message(hv_WindowHandleBuffer, (((("ViewPoint [m]\n   X :" + (HTuple(hv_ViewPoint[0]).TupleString(".2f"))) + "\n   Y: ") + (HTuple(hv_ViewPoint[1]).TupleString(".2f"))) + "\n   Z: ") + (HTuple(hv_ViewPoint[2]).TupleString(".2f")),
			"window", 300, 12, "#FFA500", "false");
	}

	disp_title_and_information(hv_Parameters, hv_WindowHandleBuffer, hv_Title, hv_Information);
	//
	//Display the 'Exit' button
	if (0 != (hv_DisplayButtons == HTuple("true")))
	{
		disp_buttons(hv_Parameters, hv_WindowHandleBuffer);
	}
	//
	return;
}

// Chapter: Graphics / Output
// Short Description: Renders 3D object models in a buffer window. 
void dump_image_output_visualize_object_model_3d(HObject ho_BackgroundImage, HTuple hv_WindowHandleBuffer,
	HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName,
	HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage,
	HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball,
	HTuple hv_DisplayContinueButton, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol,
	HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter,
	HTuple hv_RotationCenter)
{

	// Local iconic variables
	HObject  ho_TrackballContour, ho_CrossRotCenter;
	HObject  ho_ModelContours;

	// Local control variables
	HTuple  ExpTmpLocalVar_gUsesOpenGL, hv_Exception;
	HTuple  hv_Index, hv_Exception1, hv_DeselectedIdx, hv_DeselectedName;
	HTuple  hv_DeselectedValue, hv_Pose, hv_HomMat3D, hv_Center;
	HTuple  hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, hv_CenterRow;
	HTuple  hv_CenterCol, hv_Label, hv_Ascent, hv_Descent, hv_TextWidth;
	HTuple  hv_TextHeight, hv_RotCenterRow, hv_RotCenterCol;
	HTuple  hv_Orientation, hv_Colors;

	//global tuple gAlphaDeselected
	//global tuple gTerminationButtonLabel
	//global tuple gDispObjOffset
	//global tuple gLabelsDecor
	//global tuple gUsesOpenGL
	//
	//Display background image
	ClearWindow(hv_WindowHandleBuffer);
	if (0 != hv_ColorImage)
	{
		DispColor(ho_BackgroundImage, hv_WindowHandleBuffer);
	}
	else
	{
		DispImage(ho_BackgroundImage, hv_WindowHandleBuffer);
	}
	//
	//Display objects
	if (0 != ((hv_SelectedObject.TupleSum()) == (hv_SelectedObject.TupleLength())))
	{
		if (0 != (ExpGetGlobalVar_gUsesOpenGL() == HTuple("true")))
		{
			try
			{
				DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
				if (0 != (HTuple(HTuple(HTuple(hv_Exception[0]) == 5185).TupleOr(HTuple(hv_Exception[0]) == 5188)).TupleOr(HTuple(hv_Exception[0]) == 5187)))
				{
					ExpTmpLocalVar_gUsesOpenGL = "false";
					ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
				}
				else
				{
					throw HException(hv_Exception);
				}
			}
		}
		if (0 != (ExpGetGlobalVar_gUsesOpenGL() == HTuple("false")))
		{
			//* NO OpenGL, use fallback
			disp_object_model_no_opengl_visualize_object_model_3d(&ho_ModelContours, hv_ObjectModel3DID,
				hv_GenParamName, hv_GenParamValue, hv_WindowHandleBuffer, hv_CamParam,
				hv_Poses);
		}
	}
	else
	{
		{
			HTuple end_val32 = (hv_AlphaOrig.TupleLength()) - 1;
			HTuple step_val32 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val32, step_val32); hv_Index += step_val32)
			{
				if (0 != (HTuple(hv_SelectedObject[hv_Index]) == 1))
				{
					SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
				}
				else
				{
					SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", ExpGetGlobalVar_gAlphaDeselected());
				}
			}
		}
		try
		{
			if (0 != (ExpGetGlobalVar_gUsesOpenGL() == HTuple("false")))
			{
				throw HException(HTuple());
			}
			DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
		}
		// catch (Exception1) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception1);
			//* NO OpenGL, use fallback
			hv_DeselectedIdx = hv_SelectedObject.TupleFind(0);
			if (0 != (hv_DeselectedIdx != -1))
			{
				hv_DeselectedName = "color_" + hv_DeselectedIdx;
				hv_DeselectedValue = HTuple(hv_DeselectedName.TupleLength(), "gray");
			}
			disp_object_model_no_opengl_visualize_object_model_3d(&ho_ModelContours, hv_ObjectModel3DID,
				hv_GenParamName.TupleConcat(hv_DeselectedName), hv_GenParamValue.TupleConcat(hv_DeselectedValue),
				hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
		}
		{
			HTuple end_val53 = (hv_AlphaOrig.TupleLength()) - 1;
			HTuple step_val53 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val53, step_val53); hv_Index += step_val53)
			{
				SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
			}
		}
	}
	//
	//Display labels
	if (0 != (hv_Labels != 0))
	{
		SetColor(hv_WindowHandleBuffer, HTuple(ExpGetGlobalVar_gLabelsDecor()[0]));
		{
			HTuple end_val61 = (hv_ObjectModel3DID.TupleLength()) - 1;
			HTuple step_val61 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val61, step_val61); hv_Index += step_val61)
			{
				//Project the center point of the current model
				hv_Pose = hv_Poses.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
				PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
				GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_Index]), "center", &hv_Center);
				AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]),
					HTuple(hv_Center[2]), &hv_CenterCamX, &hv_CenterCamY, &hv_CenterCamZ);
				Project3dPoint(hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, hv_CamParam, &hv_CenterRow,
					&hv_CenterCol);
				hv_Label = HTuple(hv_Labels[hv_Index]);
				if (0 != (hv_Label != HTuple("")))
				{
					GetStringExtents(hv_WindowHandleBuffer, hv_Label, &hv_Ascent, &hv_Descent,
						&hv_TextWidth, &hv_TextHeight);
					disp_message(hv_WindowHandleBuffer, hv_Label, "window", (hv_CenterRow - (hv_TextHeight / 2)) + HTuple(ExpGetGlobalVar_gDispObjOffset()[0]),
						(hv_CenterCol - (hv_TextWidth / 2)) + HTuple(ExpGetGlobalVar_gDispObjOffset()[1]),
						HTuple(), HTuple(ExpGetGlobalVar_gLabelsDecor()[1]));
				}
			}
		}
	}
	//
	//Visualize the trackball if desired
	if (0 != hv_VisualizeTrackball)
	{
		SetLineWidth(hv_WindowHandleBuffer, 1);
		GenEllipseContourXld(&ho_TrackballContour, hv_TrackballCenterRow, hv_TrackballCenterCol,
			0, hv_TrackballRadiusPixel, hv_TrackballRadiusPixel, 0, 6.28318, "positive",
			1.5);
		SetColor(hv_WindowHandleBuffer, "dim gray");
		DispXld(ho_TrackballContour, hv_WindowHandleBuffer);
	}
	//
	//Visualize the rotation center if desired
	if (0 != (HTuple(hv_VisualizeRotationCenter != 0).TupleAnd((hv_RotationCenter.TupleLength()) == 3)))
	{
		if (0 != (HTuple(hv_RotationCenter[2])<1e-10))
		{
			hv_RotationCenter[2] = 1e-10;
		}
		Project3dPoint(HTuple(hv_RotationCenter[0]), HTuple(hv_RotationCenter[1]), HTuple(hv_RotationCenter[2]),
			hv_CamParam, &hv_RotCenterRow, &hv_RotCenterCol);
		hv_Orientation = HTuple(90).TupleRad();
		if (0 != (hv_VisualizeRotationCenter == 1))
		{
			hv_Orientation = HTuple(45).TupleRad();
		}
		GenCrossContourXld(&ho_CrossRotCenter, hv_RotCenterRow, hv_RotCenterCol, hv_TrackballRadiusPixel / 25.0,
			hv_Orientation);
		SetLineWidth(hv_WindowHandleBuffer, 3);
		QueryColor(hv_WindowHandleBuffer, &hv_Colors);
		SetColor(hv_WindowHandleBuffer, "light gray");
		DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
		SetLineWidth(hv_WindowHandleBuffer, 1);
		SetColor(hv_WindowHandleBuffer, "dim gray");
		DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
	}
	//
	//Display title
	disp_title_and_information_visualize_object_model_3d(hv_WindowHandleBuffer, hv_Title,
		hv_Information);
	//
	//Display the 'Exit' button
	if (0 != (hv_DisplayContinueButton == HTuple("true")))
	{
		disp_continue_button(hv_WindowHandleBuffer);
	}
	//
	return;
}

void estimate_noise_real(HObject ho_Image, HTuple hv_OutlierRemovalAmount, HTuple *hv_Sigma)
{

	// Local iconic variables
	HObject  ho_ImageFiltered, ho_RegionErosion;

	// Local control variables
	HTuple  hv_Rows, hv_Columns, hv_Grayval, hv_NumToRemove;
	HTuple  hv_Exception;

	//See documentation of estimate_noise for more information
	//about the used immerkaer noise estimation method.

	ConvolImage(ho_Image, &ho_ImageFiltered, (((((((((((HTuple(3).Append(3)).Append(1)).Append(1)).Append(-2)).Append(1)).Append(-2)).Append(4)).Append(-2)).Append(1)).Append(-2)).Append(1)),
		"mirrored");

	//convol_image will use parts of the background, which might have undefined pixels
	//Remove those parts
	ErosionRectangle1(ho_Image, &ho_RegionErosion, 3, 3);

	GetRegionPoints(ho_RegionErosion, &hv_Rows, &hv_Columns);
	if (0 != ((hv_Rows.TupleLength())<30))
	{
		//Too few points for a robust noise estimation
		//This can happen, for example, if the points are very sparse in the XYZ images
		(*hv_Sigma) = -1;
	}
	else
	{
		GetGrayval(ho_ImageFiltered, hv_Rows, hv_Columns, &hv_Grayval);
		hv_Grayval = hv_Grayval.TupleAbs();
		//Instead of the original formula, we use the more robust median
		//to avoid false negatives
		if (0 != (hv_OutlierRemovalAmount>0))
		{
			TupleSort(hv_Grayval, &hv_Grayval);
			hv_NumToRemove = (((hv_Grayval.TupleLength())*hv_OutlierRemovalAmount)*0.5).TupleInt();
			//Catch some special cases
			try
			{
				hv_Grayval = hv_Grayval.TupleSelectRange(hv_NumToRemove, ((hv_Grayval.TupleLength()) - hv_NumToRemove) - 1);
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
				//Catch the special case when we'd remove all values
				hv_Grayval = hv_Grayval.TupleMedian();
			}
		}
		(*hv_Sigma) = ((HTuple((HTuple(180).TupleRad()) / 2.0).TupleSqrt())*(1.0 / 6.0))*((hv_Grayval.TupleAbs()).TupleMean());
	}

	return;

}

void estimate_visualization_pose(HTuple hv_SampledModel, HTuple hv_WindowHandleModel,
	HTuple *hv_PoseEstimated)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Center, hv_RowNotUsed, hv_ColumnNotUsed;
	HTuple  hv_Width, hv_Height, hv_WPRow1, hv_WPColumn1, hv_WPRow2;
	HTuple  hv_WPColumn2, hv_CamParam, hv_PoseIn, hv_Moments;
	HTuple  hv_PoseInvert, hv_ObjectModel3DRigidTrans;

	get_object_models_center(hv_SampledModel, &hv_Center);
	GetWindowExtents(hv_WindowHandleModel, &hv_RowNotUsed, &hv_ColumnNotUsed, &hv_Width,
		&hv_Height);
	GetPart(hv_WindowHandleModel, &hv_WPRow1, &hv_WPColumn1, &hv_WPRow2, &hv_WPColumn2);
	SetPart(hv_WindowHandleModel, 0, 0, hv_Height - 1, hv_Width - 1);
	gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width / 2, hv_Height / 2,
		hv_Width, hv_Height, &hv_CamParam);
	CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]),
		0, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
	//
	MomentsObjectModel3d(hv_SampledModel, "principal_axes", &hv_Moments);
	PoseInvert(hv_Moments, &hv_PoseInvert);
	RigidTransObjectModel3d(hv_SampledModel, hv_PoseInvert, &hv_ObjectModel3DRigidTrans);
	determine_optimum_pose_distance(hv_ObjectModel3DRigidTrans, hv_CamParam, 0.9, hv_PoseIn,
		&(*hv_PoseEstimated));
	(*hv_PoseEstimated) = (((((HTuple((*hv_PoseEstimated)[0]).TupleConcat(-HTuple(hv_Moments[2]))).TupleConcat(HTuple((*hv_PoseEstimated)[2]))).TupleConcat(HTuple((*hv_PoseEstimated)[3]) - 90)).TupleConcat(HTuple((*hv_PoseEstimated)[4]))).TupleConcat(HTuple((*hv_PoseEstimated)[5]))).TupleConcat(0);

	return;
}

void estimate_visualization_pose_simple(HTuple hv_SampledModel, HTuple hv_WindowHandleModel,
	HTuple *hv_PoseEstimated)
{

	// Local control variables
	HTuple  hv_Center, hv_RowNotUsed, hv_ColumnNotUsed;
	HTuple  hv_Width, hv_Height, hv_WPRow1, hv_WPColumn1, hv_WPRow2;
	HTuple  hv_WPColumn2, hv_CamParam, hv_PoseIn;

	get_object_models_center(hv_SampledModel, &hv_Center);
	GetWindowExtents(hv_WindowHandleModel, &hv_RowNotUsed, &hv_ColumnNotUsed, &hv_Width,
		&hv_Height);
	GetPart(hv_WindowHandleModel, &hv_WPRow1, &hv_WPColumn1, &hv_WPRow2, &hv_WPColumn2);
	SetPart(hv_WindowHandleModel, 0, 0, hv_Height - 1, hv_Width - 1);
	gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width / 2, hv_Height / 2,
		hv_Width, hv_Height, &hv_CamParam);
	CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]),
		0, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
	//
	determine_optimum_pose_distance(hv_SampledModel, hv_CamParam, 0.9, hv_PoseIn, &(*hv_PoseEstimated));

	return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model. 
void gen_cam_par_area_scan_division(HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx,
	HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight,
	HTuple *hv_CameraParam)
{

	// Local iconic variables

	//Generate a camera parameter tuple for an area scan camera
	//with distortions modeled by the division model.
	//
	(*hv_CameraParam).Clear();
	(*hv_CameraParam)[0] = "area_scan_division";
	(*hv_CameraParam).Append(hv_Focus);
	(*hv_CameraParam).Append(hv_Kappa);
	(*hv_CameraParam).Append(hv_Sx);
	(*hv_CameraParam).Append(hv_Sy);
	(*hv_CameraParam).Append(hv_Cx);
	(*hv_CameraParam).Append(hv_Cy);
	(*hv_CameraParam).Append(hv_ImageWidth);
	(*hv_CameraParam).Append(hv_ImageHeight);
	return;
}

void gen_camera_facing_scene(HTuple hv_Viewpoint, HTuple hv_Center, HTuple hv_DiameterModel,
	HTuple *hv_OM3DCamera)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Direction, hv_DirectionLength, hv_DirNorm;
	HTuple  hv_Axis, hv_AxisNorm, hv_HomMat3DIdentity, hv_HomMat3DRotate;
	HTuple  hv_Pose;

	hv_Direction = hv_Viewpoint - hv_Center;
	hv_DirectionLength = ((hv_Direction*hv_Direction).TupleSum()).TupleSqrt();
	if (0 != (hv_DirectionLength<(1e-1*hv_DiameterModel)))
	{
		hv_DirectionLength = 0;
		GenSphereObjectModel3d(hv_Viewpoint.TupleConcat((((HTuple(0).Append(0)).Append(0)).Append(0))),
			hv_DiameterModel*0.1, &(*hv_OM3DCamera));
	}
	else
	{
		//Create a rotation such that the camera faces the center of gravity of the scene
		hv_DirNorm = hv_Direction / hv_DirectionLength;
		if (0 != (((hv_DirNorm*((HTuple(0).Append(0)).Append(-1))).TupleSum())>-0.99999))
		{
			//Angle between the vectors is > 0.25
			hv_Axis = hv_DirNorm + ((HTuple(0).Append(0)).Append(-1));
			hv_AxisNorm = hv_Axis / (((hv_Axis*hv_Axis).TupleSum()).TupleSqrt());
		}
		else
		{
			hv_Axis.Clear();
			hv_Axis[0] = 0;
			hv_Axis[1] = 1;
			hv_Axis[2] = 0;
		}
		HomMat3dIdentity(&hv_HomMat3DIdentity);
		HomMat3dRotateLocal(hv_HomMat3DIdentity, HTuple(180).TupleRad(), hv_Axis, &hv_HomMat3DRotate);
		HomMat3dToPose(hv_HomMat3DRotate, &hv_Pose);
		hv_Pose[HTuple::TupleGenSequence(0, 2, 1)] = hv_Viewpoint;
		gen_camera_object_model_3d(hv_Pose, hv_DiameterModel*0.1, &(*hv_OM3DCamera));
	}
	return;
}

// Short Description: Create a 3D object model that resembles a camera 
void gen_camera_object_model_3d(HTuple hv_Pose, HTuple hv_Size, HTuple *hv_OM3DCamera)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_OM3DBox, hv_OM3DBoxTriangulated, hv_Information;
	HTuple  hv_OM3DCylinder, hv_OMSampledCylinder, hv_CX, hv_CY;
	HTuple  hv_CZ, hv_Lin, hv_Fac, hv_OM3DCylinder2;

	//Create the box
	GenBoxObjectModel3d(((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)),
		hv_Size, hv_Size, hv_Size, &hv_OM3DBox);
	TriangulateObjectModel3d(hv_OM3DBox, "greedy", HTuple(), HTuple(), &hv_OM3DBoxTriangulated,
		&hv_Information);
	//Create the cone frustum
	GenCylinderObjectModel3d(((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)),
		hv_Size*0.5, hv_Size*0.5, hv_Size * 1, &hv_OM3DCylinder);
	SampleObjectModel3d(hv_OM3DCylinder, "fast", hv_Size*0.02, HTuple(), HTuple(),
		&hv_OMSampledCylinder);
	GetObjectModel3dParams(hv_OMSampledCylinder, "point_coord_x", &hv_CX);
	GetObjectModel3dParams(hv_OMSampledCylinder, "point_coord_y", &hv_CY);
	GetObjectModel3dParams(hv_OMSampledCylinder, "point_coord_z", &hv_CZ);
	hv_Lin = (hv_CZ - (hv_Size*0.5)) / ((hv_CZ.TupleMax()) - (hv_CZ.TupleMin()));
	hv_Fac = (hv_Lin*0.5) + 0.5;
	SetObjectModel3dAttribMod(hv_OMSampledCylinder, "point_coord_x", HTuple(), hv_CX*hv_Fac);
	SetObjectModel3dAttribMod(hv_OMSampledCylinder, "point_coord_y", HTuple(), hv_CY*hv_Fac);
	ConvexHullObjectModel3d(hv_OMSampledCylinder, &hv_OM3DCylinder2);
	//
	//Make it a single model and move to desired pose
	UnionObjectModel3d(hv_OM3DBoxTriangulated.TupleConcat(hv_OM3DCylinder2), "points_surface",
		&(*hv_OM3DCamera));
	RigidTransObjectModel3d((*hv_OM3DCamera), hv_Pose, &(*hv_OM3DCamera));
	return;
}

void gen_menu_regions_ext(HObject *ho_MenuRegions, HTuple hv_TopBottom, HTuple hv_WindowHandleMenu,
	HTuple hv_PercentageHeight, HTuple hv_NumRows, HTuple hv_NumCols)
{

	// Local iconic variables
	HObject  ho_Rectangle;

	// Local control variables
	HTuple  hv_PartRow1, hv_PartCol1, hv_PartRow2;
	HTuple  hv_PartCol2, hv_Height, hv_Width, hv_MenuHeight;
	HTuple  hv_MenuWidth, hv_ButtonHeight, hv_ButtonWidth, hv_Row0;
	HTuple  hv_Col0, hv_r, hv_c;

	if (0 != (HTuple(hv_TopBottom != HTuple("top")).TupleAnd(hv_TopBottom != HTuple("bottom"))))
	{
		throw HException("Invalid parameter: TopBottom must be \"top\" or \"bottom\"");
	}

	GetPart(hv_WindowHandleMenu, &hv_PartRow1, &hv_PartCol1, &hv_PartRow2, &hv_PartCol2);
	hv_Height = (hv_PartRow2 - hv_PartRow1) + 1;
	hv_Width = (hv_PartCol2 - hv_PartCol1) + 1;
	hv_MenuHeight = (hv_Height*hv_PercentageHeight) / 100.0;
	hv_MenuWidth = hv_Width;
	hv_ButtonHeight = hv_MenuHeight / hv_NumRows;
	hv_ButtonWidth = hv_MenuWidth / hv_NumCols;
	if (0 != (hv_TopBottom == HTuple("top")))
	{
		hv_Row0 = hv_PartRow1;
	}
	if (0 != (hv_TopBottom == HTuple("bottom")))
	{
		hv_Row0 = hv_PartRow2 - hv_MenuHeight;
	}
	hv_Col0 = hv_PartCol1;
	SetSystem("clip_region", "false");
	GenEmptyObj(&(*ho_MenuRegions));
	{
		HTuple end_val20 = hv_NumRows - 1;
		HTuple step_val20 = 1;
		for (hv_r = 0; hv_r.Continue(end_val20, step_val20); hv_r += step_val20)
		{
			{
				HTuple end_val21 = hv_NumCols - 1;
				HTuple step_val21 = 1;
				for (hv_c = 0; hv_c.Continue(end_val21, step_val21); hv_c += step_val21)
				{
					GenRectangle1(&ho_Rectangle, hv_Row0 + (hv_r*hv_ButtonHeight), hv_Col0 + (hv_c*hv_ButtonWidth),
						((hv_Row0 + (hv_r*hv_ButtonHeight)) + hv_ButtonHeight) - 1, ((hv_Col0 + (hv_c*hv_ButtonWidth)) + hv_ButtonWidth) - 1);
					ConcatObj((*ho_MenuRegions), ho_Rectangle, &(*ho_MenuRegions));
				}
			}
		}
	}
	return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Get the value of a specified camera parameter from the camera parameter tuple. 
void get_cam_par_data(HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_CameraType, hv_CameraParamNames, hv_Index;
	HTuple  hv_ParamNameInd, hv_I;

	//get_cam_par_data returns in ParamValue the value of the
	//parameter that is given in ParamName from the tuple of
	//camera parameters that is given in CameraParam.
	//
	//Get the parameter names that correspond to the
	//elements in the input camera parameter tuple.
	get_cam_par_names(hv_CameraParam, &hv_CameraType, &hv_CameraParamNames);
	//
	//Find the index of the requested camera data and return
	//the corresponding value.
	(*hv_ParamValue) = HTuple();
	{
		HTuple end_val11 = (hv_ParamName.TupleLength()) - 1;
		HTuple step_val11 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val11, step_val11); hv_Index += step_val11)
		{
			hv_ParamNameInd = HTuple(hv_ParamName[hv_Index]);
			if (0 != (hv_ParamNameInd == HTuple("camera_type")))
			{
				(*hv_ParamValue) = (*hv_ParamValue).TupleConcat(hv_CameraType);
				continue;
			}
			hv_I = hv_CameraParamNames.TupleFind(hv_ParamNameInd);
			if (0 != (hv_I != -1))
			{
				(*hv_ParamValue) = (*hv_ParamValue).TupleConcat(HTuple(hv_CameraParam[hv_I]));
			}
			else
			{
				throw HException("Unknown camera parameter " + hv_ParamNameInd);
			}
		}
	}
	return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Get the names of the parameters in a camera parameter tuple. 
void get_cam_par_names(HTuple hv_CameraParam, HTuple *hv_CameraType, HTuple *hv_ParamNames)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_CameraParamAreaScanDivision, hv_CameraParamAreaScanPolynomial;
	HTuple  hv_CameraParamAreaScanTelecentricDivision, hv_CameraParamAreaScanTelecentricPolynomial;
	HTuple  hv_CameraParamAreaScanTiltDivision, hv_CameraParamAreaScanTiltPolynomial;
	HTuple  hv_CameraParamAreaScanImageSideTelecentricTiltDivision;
	HTuple  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial;
	HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltDivision;
	HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial;
	HTuple  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision;
	HTuple  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial;
	HTuple  hv_CameraParamAreaScanHypercentricDivision, hv_CameraParamAreaScanHypercentricPolynomial;
	HTuple  hv_CameraParamLinesScan, hv_CameraParamAreaScanTiltDivisionLegacy;
	HTuple  hv_CameraParamAreaScanTiltPolynomialLegacy, hv_CameraParamAreaScanTelecentricDivisionLegacy;
	HTuple  hv_CameraParamAreaScanTelecentricPolynomialLegacy;
	HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy;
	HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy;

	//get_cam_par_names returns for each element in the camera
	//parameter tuple that is passed in CameraParam the name
	//of the respective camera parameter. The parameter names
	//are returned in ParamNames. Additionally, the camera
	//type is returned in CameraType. Alternatively, instead of
	//the camera parameters, the camera type can be passed in
	//CameraParam in form of one of the following strings:
	//  - 'area_scan_division'
	//  - 'area_scan_polynomial'
	//  - 'area_scan_tilt_division'
	//  - 'area_scan_tilt_polynomial'
	//  - 'area_scan_telecentric_division'
	//  - 'area_scan_telecentric_polynomial'
	//  - 'area_scan_tilt_bilateral_telecentric_division'
	//  - 'area_scan_tilt_bilateral_telecentric_polynomial'
	//  - 'area_scan_tilt_object_side_telecentric_division'
	//  - 'area_scan_tilt_object_side_telecentric_polynomial'
	//  - 'area_scan_hypercentric_division'
	//  - 'area_scan_hypercentric_polynomial'
	//  - 'line_scan'
	//
	hv_CameraParamAreaScanDivision.Clear();
	hv_CameraParamAreaScanDivision[0] = "focus";
	hv_CameraParamAreaScanDivision[1] = "kappa";
	hv_CameraParamAreaScanDivision[2] = "sx";
	hv_CameraParamAreaScanDivision[3] = "sy";
	hv_CameraParamAreaScanDivision[4] = "cx";
	hv_CameraParamAreaScanDivision[5] = "cy";
	hv_CameraParamAreaScanDivision[6] = "image_width";
	hv_CameraParamAreaScanDivision[7] = "image_height";
	hv_CameraParamAreaScanPolynomial.Clear();
	hv_CameraParamAreaScanPolynomial[0] = "focus";
	hv_CameraParamAreaScanPolynomial[1] = "k1";
	hv_CameraParamAreaScanPolynomial[2] = "k2";
	hv_CameraParamAreaScanPolynomial[3] = "k3";
	hv_CameraParamAreaScanPolynomial[4] = "p1";
	hv_CameraParamAreaScanPolynomial[5] = "p2";
	hv_CameraParamAreaScanPolynomial[6] = "sx";
	hv_CameraParamAreaScanPolynomial[7] = "sy";
	hv_CameraParamAreaScanPolynomial[8] = "cx";
	hv_CameraParamAreaScanPolynomial[9] = "cy";
	hv_CameraParamAreaScanPolynomial[10] = "image_width";
	hv_CameraParamAreaScanPolynomial[11] = "image_height";
	hv_CameraParamAreaScanTelecentricDivision.Clear();
	hv_CameraParamAreaScanTelecentricDivision[0] = "magnification";
	hv_CameraParamAreaScanTelecentricDivision[1] = "kappa";
	hv_CameraParamAreaScanTelecentricDivision[2] = "sx";
	hv_CameraParamAreaScanTelecentricDivision[3] = "sy";
	hv_CameraParamAreaScanTelecentricDivision[4] = "cx";
	hv_CameraParamAreaScanTelecentricDivision[5] = "cy";
	hv_CameraParamAreaScanTelecentricDivision[6] = "image_width";
	hv_CameraParamAreaScanTelecentricDivision[7] = "image_height";
	hv_CameraParamAreaScanTelecentricPolynomial.Clear();
	hv_CameraParamAreaScanTelecentricPolynomial[0] = "magnification";
	hv_CameraParamAreaScanTelecentricPolynomial[1] = "k1";
	hv_CameraParamAreaScanTelecentricPolynomial[2] = "k2";
	hv_CameraParamAreaScanTelecentricPolynomial[3] = "k3";
	hv_CameraParamAreaScanTelecentricPolynomial[4] = "p1";
	hv_CameraParamAreaScanTelecentricPolynomial[5] = "p2";
	hv_CameraParamAreaScanTelecentricPolynomial[6] = "sx";
	hv_CameraParamAreaScanTelecentricPolynomial[7] = "sy";
	hv_CameraParamAreaScanTelecentricPolynomial[8] = "cx";
	hv_CameraParamAreaScanTelecentricPolynomial[9] = "cy";
	hv_CameraParamAreaScanTelecentricPolynomial[10] = "image_width";
	hv_CameraParamAreaScanTelecentricPolynomial[11] = "image_height";
	hv_CameraParamAreaScanTiltDivision.Clear();
	hv_CameraParamAreaScanTiltDivision[0] = "focus";
	hv_CameraParamAreaScanTiltDivision[1] = "kappa";
	hv_CameraParamAreaScanTiltDivision[2] = "image_plane_dist";
	hv_CameraParamAreaScanTiltDivision[3] = "tilt";
	hv_CameraParamAreaScanTiltDivision[4] = "rot";
	hv_CameraParamAreaScanTiltDivision[5] = "sx";
	hv_CameraParamAreaScanTiltDivision[6] = "sy";
	hv_CameraParamAreaScanTiltDivision[7] = "cx";
	hv_CameraParamAreaScanTiltDivision[8] = "cy";
	hv_CameraParamAreaScanTiltDivision[9] = "image_width";
	hv_CameraParamAreaScanTiltDivision[10] = "image_height";
	hv_CameraParamAreaScanTiltPolynomial.Clear();
	hv_CameraParamAreaScanTiltPolynomial[0] = "focus";
	hv_CameraParamAreaScanTiltPolynomial[1] = "k1";
	hv_CameraParamAreaScanTiltPolynomial[2] = "k2";
	hv_CameraParamAreaScanTiltPolynomial[3] = "k3";
	hv_CameraParamAreaScanTiltPolynomial[4] = "p1";
	hv_CameraParamAreaScanTiltPolynomial[5] = "p2";
	hv_CameraParamAreaScanTiltPolynomial[6] = "image_plane_dist";
	hv_CameraParamAreaScanTiltPolynomial[7] = "tilt";
	hv_CameraParamAreaScanTiltPolynomial[8] = "rot";
	hv_CameraParamAreaScanTiltPolynomial[9] = "sx";
	hv_CameraParamAreaScanTiltPolynomial[10] = "sy";
	hv_CameraParamAreaScanTiltPolynomial[11] = "cx";
	hv_CameraParamAreaScanTiltPolynomial[12] = "cy";
	hv_CameraParamAreaScanTiltPolynomial[13] = "image_width";
	hv_CameraParamAreaScanTiltPolynomial[14] = "image_height";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision.Clear();
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[0] = "focus";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[1] = "kappa";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[2] = "tilt";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[3] = "rot";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[4] = "sx";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[5] = "sy";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[6] = "cx";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[7] = "cy";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[8] = "image_width";
	hv_CameraParamAreaScanImageSideTelecentricTiltDivision[9] = "image_height";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial.Clear();
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[0] = "focus";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[1] = "k1";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[2] = "k2";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[3] = "k3";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[4] = "p1";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[5] = "p2";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[6] = "tilt";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[7] = "rot";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[8] = "sx";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[9] = "sy";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[10] = "cx";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[11] = "cy";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[12] = "image_width";
	hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[13] = "image_height";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision.Clear();
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[0] = "magnification";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[1] = "kappa";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[2] = "tilt";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[3] = "rot";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[4] = "sx";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[5] = "sy";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[6] = "cx";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[7] = "cy";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[8] = "image_width";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivision[9] = "image_height";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial.Clear();
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[0] = "magnification";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[1] = "k1";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[2] = "k2";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[3] = "k3";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[4] = "p1";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[5] = "p2";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[6] = "tilt";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[7] = "rot";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[8] = "sx";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[9] = "sy";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[10] = "cx";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[11] = "cy";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[12] = "image_width";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[13] = "image_height";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision.Clear();
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[0] = "magnification";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[1] = "kappa";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[2] = "image_plane_dist";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[3] = "tilt";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[4] = "rot";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[5] = "sx";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[6] = "sy";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[7] = "cx";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[8] = "cy";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[9] = "image_width";
	hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[10] = "image_height";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial.Clear();
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[0] = "magnification";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[1] = "k1";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[2] = "k2";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[3] = "k3";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[4] = "p1";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[5] = "p2";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[6] = "image_plane_dist";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[7] = "tilt";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[8] = "rot";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[9] = "sx";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[10] = "sy";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[11] = "cx";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[12] = "cy";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[13] = "image_width";
	hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[14] = "image_height";
	hv_CameraParamAreaScanHypercentricDivision.Clear();
	hv_CameraParamAreaScanHypercentricDivision[0] = "focus";
	hv_CameraParamAreaScanHypercentricDivision[1] = "kappa";
	hv_CameraParamAreaScanHypercentricDivision[2] = "sx";
	hv_CameraParamAreaScanHypercentricDivision[3] = "sy";
	hv_CameraParamAreaScanHypercentricDivision[4] = "cx";
	hv_CameraParamAreaScanHypercentricDivision[5] = "cy";
	hv_CameraParamAreaScanHypercentricDivision[6] = "image_width";
	hv_CameraParamAreaScanHypercentricDivision[7] = "image_height";
	hv_CameraParamAreaScanHypercentricPolynomial.Clear();
	hv_CameraParamAreaScanHypercentricPolynomial[0] = "focus";
	hv_CameraParamAreaScanHypercentricPolynomial[1] = "k1";
	hv_CameraParamAreaScanHypercentricPolynomial[2] = "k2";
	hv_CameraParamAreaScanHypercentricPolynomial[3] = "k3";
	hv_CameraParamAreaScanHypercentricPolynomial[4] = "p1";
	hv_CameraParamAreaScanHypercentricPolynomial[5] = "p2";
	hv_CameraParamAreaScanHypercentricPolynomial[6] = "sx";
	hv_CameraParamAreaScanHypercentricPolynomial[7] = "sy";
	hv_CameraParamAreaScanHypercentricPolynomial[8] = "cx";
	hv_CameraParamAreaScanHypercentricPolynomial[9] = "cy";
	hv_CameraParamAreaScanHypercentricPolynomial[10] = "image_width";
	hv_CameraParamAreaScanHypercentricPolynomial[11] = "image_height";
	hv_CameraParamLinesScan.Clear();
	hv_CameraParamLinesScan[0] = "focus";
	hv_CameraParamLinesScan[1] = "kappa";
	hv_CameraParamLinesScan[2] = "sx";
	hv_CameraParamLinesScan[3] = "sy";
	hv_CameraParamLinesScan[4] = "cx";
	hv_CameraParamLinesScan[5] = "cy";
	hv_CameraParamLinesScan[6] = "image_width";
	hv_CameraParamLinesScan[7] = "image_height";
	hv_CameraParamLinesScan[8] = "vx";
	hv_CameraParamLinesScan[9] = "vy";
	hv_CameraParamLinesScan[10] = "vz";
	//Legacy parameter names
	hv_CameraParamAreaScanTiltDivisionLegacy.Clear();
	hv_CameraParamAreaScanTiltDivisionLegacy[0] = "focus";
	hv_CameraParamAreaScanTiltDivisionLegacy[1] = "kappa";
	hv_CameraParamAreaScanTiltDivisionLegacy[2] = "tilt";
	hv_CameraParamAreaScanTiltDivisionLegacy[3] = "rot";
	hv_CameraParamAreaScanTiltDivisionLegacy[4] = "sx";
	hv_CameraParamAreaScanTiltDivisionLegacy[5] = "sy";
	hv_CameraParamAreaScanTiltDivisionLegacy[6] = "cx";
	hv_CameraParamAreaScanTiltDivisionLegacy[7] = "cy";
	hv_CameraParamAreaScanTiltDivisionLegacy[8] = "image_width";
	hv_CameraParamAreaScanTiltDivisionLegacy[9] = "image_height";
	hv_CameraParamAreaScanTiltPolynomialLegacy.Clear();
	hv_CameraParamAreaScanTiltPolynomialLegacy[0] = "focus";
	hv_CameraParamAreaScanTiltPolynomialLegacy[1] = "k1";
	hv_CameraParamAreaScanTiltPolynomialLegacy[2] = "k2";
	hv_CameraParamAreaScanTiltPolynomialLegacy[3] = "k3";
	hv_CameraParamAreaScanTiltPolynomialLegacy[4] = "p1";
	hv_CameraParamAreaScanTiltPolynomialLegacy[5] = "p2";
	hv_CameraParamAreaScanTiltPolynomialLegacy[6] = "tilt";
	hv_CameraParamAreaScanTiltPolynomialLegacy[7] = "rot";
	hv_CameraParamAreaScanTiltPolynomialLegacy[8] = "sx";
	hv_CameraParamAreaScanTiltPolynomialLegacy[9] = "sy";
	hv_CameraParamAreaScanTiltPolynomialLegacy[10] = "cx";
	hv_CameraParamAreaScanTiltPolynomialLegacy[11] = "cy";
	hv_CameraParamAreaScanTiltPolynomialLegacy[12] = "image_width";
	hv_CameraParamAreaScanTiltPolynomialLegacy[13] = "image_height";
	hv_CameraParamAreaScanTelecentricDivisionLegacy.Clear();
	hv_CameraParamAreaScanTelecentricDivisionLegacy[0] = "focus";
	hv_CameraParamAreaScanTelecentricDivisionLegacy[1] = "kappa";
	hv_CameraParamAreaScanTelecentricDivisionLegacy[2] = "sx";
	hv_CameraParamAreaScanTelecentricDivisionLegacy[3] = "sy";
	hv_CameraParamAreaScanTelecentricDivisionLegacy[4] = "cx";
	hv_CameraParamAreaScanTelecentricDivisionLegacy[5] = "cy";
	hv_CameraParamAreaScanTelecentricDivisionLegacy[6] = "image_width";
	hv_CameraParamAreaScanTelecentricDivisionLegacy[7] = "image_height";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy.Clear();
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[0] = "focus";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[1] = "k1";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[2] = "k2";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[3] = "k3";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[4] = "p1";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[5] = "p2";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[6] = "sx";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[7] = "sy";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[8] = "cx";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[9] = "cy";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[10] = "image_width";
	hv_CameraParamAreaScanTelecentricPolynomialLegacy[11] = "image_height";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy.Clear();
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[0] = "focus";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[1] = "kappa";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[2] = "tilt";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[3] = "rot";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[4] = "sx";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[5] = "sy";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[6] = "cx";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[7] = "cy";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[8] = "image_width";
	hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[9] = "image_height";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy.Clear();
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[0] = "focus";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[1] = "k1";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[2] = "k2";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[3] = "k3";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[4] = "p1";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[5] = "p2";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[6] = "tilt";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[7] = "rot";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[8] = "sx";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[9] = "sy";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[10] = "cx";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[11] = "cy";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[12] = "image_width";
	hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[13] = "image_height";
	//
	//If the camera type is passed in CameraParam
	if (0 != (HTuple((hv_CameraParam.TupleLength()) == 1).TupleAnd(HTuple(hv_CameraParam[0]).TupleIsString())))
	{
		(*hv_CameraType) = ((const HTuple&)hv_CameraParam)[0];
		if (0 != ((*hv_CameraType) == HTuple("area_scan_division")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_polynomial")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_telecentric_division")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_telecentric_polynomial")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_division")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_polynomial")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_division")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_polynomial")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_division")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_polynomial")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_division")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_polynomial")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_hypercentric_division")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_hypercentric_polynomial")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("line_scan")))
		{
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamLinesScan);
		}
		else
		{
			throw HException(("Unknown camera type '" + (*hv_CameraType)) + "' passed in CameraParam.");
		}
		return;
	}
	//
	//If the camera parameters are passed in CameraParam
	if (0 != ((HTuple(hv_CameraParam[0]).TupleIsString()).TupleNot()))
	{
		//Format of camera parameters for HALCON 12 and earlier
		switch ((hv_CameraParam.TupleLength()).I())
		{
			//
			//Area Scan
		case 8:
			//CameraType: 'area_scan_division' or 'area_scan_telecentric_division'
			if (0 != (HTuple(hv_CameraParam[0]) != 0.0))
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanDivision;
				(*hv_CameraType) = "area_scan_division";
			}
			else
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanTelecentricDivisionLegacy;
				(*hv_CameraType) = "area_scan_telecentric_division";
			}
			break;
		case 10:
			//CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'
			if (0 != (HTuple(hv_CameraParam[0]) != 0.0))
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanTiltDivisionLegacy;
				(*hv_CameraType) = "area_scan_tilt_division";
			}
			else
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy;
				(*hv_CameraType) = "area_scan_tilt_bilateral_telecentric_division";
			}
			break;
		case 12:
			//CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'
			if (0 != (HTuple(hv_CameraParam[0]) != 0.0))
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanPolynomial;
				(*hv_CameraType) = "area_scan_polynomial";
			}
			else
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanTelecentricPolynomialLegacy;
				(*hv_CameraType) = "area_scan_telecentric_polynomial";
			}
			break;
		case 14:
			//CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'
			if (0 != (HTuple(hv_CameraParam[0]) != 0.0))
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanTiltPolynomialLegacy;
				(*hv_CameraType) = "area_scan_tilt_polynomial";
			}
			else
			{
				(*hv_ParamNames) = hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy;
				(*hv_CameraType) = "area_scan_tilt_bilateral_telecentric_polynomial";
			}
			break;
			//
			//Line Scan
		case 11:
			//CameraType: 'line_scan'
			(*hv_ParamNames) = hv_CameraParamLinesScan;
			(*hv_CameraType) = "line_scan";
			break;
		default:
			throw HException("Wrong number of values in CameraParam.");
		}
	}
	else
	{
		//Format of camera parameters since HALCON 13
		(*hv_CameraType) = ((const HTuple&)hv_CameraParam)[0];
		if (0 != ((*hv_CameraType) == HTuple("area_scan_division")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 9))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_polynomial")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 13))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_telecentric_division")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 9))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_telecentric_polynomial")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 13))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_division")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 12))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_polynomial")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 16))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_division")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 11))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_image_side_telecentric_polynomial")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 15))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_division")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 11))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_bilateral_telecentric_polynomial")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 15))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_division")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 12))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_tilt_object_side_telecentric_polynomial")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 16))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_hypercentric_division")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 9))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricDivision);
		}
		else if (0 != ((*hv_CameraType) == HTuple("area_scan_hypercentric_polynomial")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 13))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamAreaScanHypercentricPolynomial);
		}
		else if (0 != ((*hv_CameraType) == HTuple("line_scan")))
		{
			if (0 != ((hv_CameraParam.TupleLength()) != 12))
			{
				throw HException("Wrong number of values in CameraParam.");
			}
			(*hv_ParamNames).Clear();
			(*hv_ParamNames)[0] = "camera_type";
			(*hv_ParamNames).Append(hv_CameraParamLinesScan);
		}
		else
		{
			throw HException("Unknown camera type in CameraParam.");
		}
	}
	return;
}

void get_find_parameter(HTuple hv_GenParamNames, HTuple hv_GenParamValues, HTuple hv_ParamName,
	HTuple hv_DefaultValue, HTuple *hv_ParamValue)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Idx;

	(*hv_ParamValue) = hv_DefaultValue;
	TupleFind(hv_GenParamNames, hv_ParamName, &hv_Idx);
	if (0 != (HTuple(hv_Idx != -1).TupleAnd(hv_Idx != HTuple())))
	{
		(*hv_ParamValue) = HTuple(hv_GenParamValues[hv_Idx]);
	}
	return;
}

void get_image_direction(HObject ho_Image, HTuple *hv_MedianDirection)
{

	// Local iconic variables
	HObject  ho_Domain, ho_RegionTrans, ho_XWithNeighbor;

	// Local control variables
	HTuple  hv_Direction, hv_Rows, hv_Columns, hv_Grayval1;
	HTuple  hv_Grayval2, hv_Diff, hv_MedianDiff1, hv_MedianDiff2;

	hv_Direction.Clear();
	hv_Direction[0] = 1;
	hv_Direction[1] = 0;
	GetDomain(ho_Image, &ho_Domain);
	AffineTransRegion(ho_Domain, &ho_RegionTrans, (((HTuple(1).Append(0)).TupleConcat(HTuple(hv_Direction[1]))).TupleConcat((HTuple(0).Append(1)))).TupleConcat(HTuple(hv_Direction[0])),
		"false");
	Intersection(ho_Image, ho_RegionTrans, &ho_XWithNeighbor);
	GetRegionPoints(ho_XWithNeighbor, &hv_Rows, &hv_Columns);
	if (0 != ((hv_Columns.TupleLength())>0))
	{
		GetGrayval(ho_Image, hv_Rows - HTuple(hv_Direction[1]), hv_Columns - HTuple(hv_Direction[0]),
			&hv_Grayval1);
		GetGrayval(ho_Image, hv_Rows, hv_Columns, &hv_Grayval2);
		hv_Diff = hv_Grayval2 - hv_Grayval1;
		hv_MedianDiff1 = hv_Diff.TupleMedian();
	}
	else
	{
		(*hv_MedianDirection).Clear();
		(*hv_MedianDirection)[0] = 0;
		(*hv_MedianDirection)[1] = 0;
		return;
	}

	hv_Direction.Clear();
	hv_Direction[0] = 0;
	hv_Direction[1] = 1;
	AffineTransRegion(ho_Image, &ho_RegionTrans, (((HTuple(1).Append(0)).TupleConcat(HTuple(hv_Direction[1]))).TupleConcat((HTuple(0).Append(1)))).TupleConcat(HTuple(hv_Direction[0])),
		"nearest_neighbor");
	Intersection(ho_Image, ho_RegionTrans, &ho_XWithNeighbor);
	GetRegionPoints(ho_XWithNeighbor, &hv_Rows, &hv_Columns);
	if (0 != ((hv_Columns.TupleLength())>0))
	{
		GetGrayval(ho_Image, hv_Rows - HTuple(hv_Direction[1]), hv_Columns - HTuple(hv_Direction[0]),
			&hv_Grayval1);
		GetGrayval(ho_Image, hv_Rows, hv_Columns, &hv_Grayval2);
		hv_Diff = hv_Grayval2 - hv_Grayval1;
		hv_MedianDiff2 = hv_Diff.TupleMedian();
	}
	else
	{
		(*hv_MedianDirection).Clear();
		(*hv_MedianDirection)[0] = 0;
		(*hv_MedianDirection)[1] = 0;
		return;
	}

	(*hv_MedianDirection).Clear();
	(*hv_MedianDirection).Append(hv_MedianDiff1);
	(*hv_MedianDirection).Append(hv_MedianDiff2);

	return;
}

void get_mouse_info(HTuple hv_WindowHandle, HTuple hv_MessageQueue, HTuple hv_Timeout,
	HTuple *hv_Row, HTuple *hv_Column, HTuple *hv_Button)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_MessageHandle, hv_Exception, hv_H_ERR_TIMEOUT;
	HTuple  hv_MessageType;

	//Initialize as "no event"
	(*hv_Row) = -1;
	(*hv_Column) = -1;
	(*hv_Button) = -1;
	//
	if (0 != (hv_MessageQueue == HTuple()))
	{
		GetMpositionSubPix(hv_WindowHandle, &(*hv_Row), &(*hv_Column), &(*hv_Button));
	}
	else
	{
		//Queue-based visualization
		if (0 != (hv_Timeout == HTuple()))
		{
			DequeueMessage(HTuple(hv_MessageQueue[0]), HTuple(), HTuple(), &hv_MessageHandle);
		}
		else
		{
			try
			{
				DequeueMessage(HTuple(hv_MessageQueue[0]), "timeout", hv_Timeout, &hv_MessageHandle);
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
				hv_H_ERR_TIMEOUT = 9400;
				if (0 != (HTuple(hv_Exception[0]) == hv_H_ERR_TIMEOUT))
				{
					return;
				}
				else
				{
					throw HException(hv_Exception);
				}
			}
		}
		GetMessageTuple(hv_MessageHandle, "type", &hv_MessageType);
		if (0 != (hv_MessageType == HTuple("mouse_event")))
		{
			GetMessageTuple(hv_MessageHandle, "mouse_row", &(*hv_Row));
			GetMessageTuple(hv_MessageHandle, "mouse_col", &(*hv_Column));
			GetMessageTuple(hv_MessageHandle, "mouse_button", &(*hv_Button));
			ClearMessage(hv_MessageHandle);
		}
		else
		{
			ClearMessage(hv_MessageHandle);
			throw HException("Unknown or unexpected message type: " + hv_MessageType);
		}
	}

	//Normalize the button
	if (0 != ((*hv_Button) == HTuple()))
	{
		(*hv_Button) = 0;
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center(HTuple hv_ObjectModel3DID, HTuple *hv_Center)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Diameter, hv_MD, hv_Weight, hv_SumW;
	HTuple  hv_Index, hv_ObjectModel3DIDSelected, hv_C, hv_InvSum;

	//Compute the mean of all model centers (weighted by the diameter of the object models)
	if (0 != ((hv_ObjectModel3DID.TupleLength())>0))
	{
		GetObjectModel3dParams(hv_ObjectModel3DID, "diameter_axis_aligned_bounding_box",
			&hv_Diameter);
		//Normalize Diameter to use it as weights for a weighted mean of the individual centers
		hv_MD = hv_Diameter.TupleMean();
		if (0 != (hv_MD>1e-10))
		{
			hv_Weight = hv_Diameter / hv_MD;
		}
		else
		{
			hv_Weight = hv_Diameter;
		}
		hv_SumW = hv_Weight.TupleSum();
		if (0 != (hv_SumW<1e-10))
		{
			hv_Weight = HTuple(hv_Weight.TupleLength(), 1.0);
			hv_SumW = hv_Weight.TupleSum();
		}
		(*hv_Center).Clear();
		(*hv_Center)[0] = 0;
		(*hv_Center)[1] = 0;
		(*hv_Center)[2] = 0;
		{
			HTuple end_val16 = (hv_ObjectModel3DID.TupleLength()) - 1;
			HTuple step_val16 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val16, step_val16); hv_Index += step_val16)
			{
				hv_ObjectModel3DIDSelected = HTuple(hv_ObjectModel3DID[hv_Index]);
				GetObjectModel3dParams(hv_ObjectModel3DIDSelected, "center", &hv_C);
				(*hv_Center)[0] = HTuple((*hv_Center)[0]) + (HTuple(hv_C[0])*HTuple(hv_Weight[hv_Index]));
				(*hv_Center)[1] = HTuple((*hv_Center)[1]) + (HTuple(hv_C[1])*HTuple(hv_Weight[hv_Index]));
				(*hv_Center)[2] = HTuple((*hv_Center)[2]) + (HTuple(hv_C[2])*HTuple(hv_Weight[hv_Index]));
			}
		}
		hv_InvSum = 1.0 / hv_SumW;
		(*hv_Center)[0] = HTuple((*hv_Center)[0])*hv_InvSum;
		(*hv_Center)[1] = HTuple((*hv_Center)[1])*hv_InvSum;
		(*hv_Center)[2] = HTuple((*hv_Center)[2])*hv_InvSum;
	}
	else
	{
		(*hv_Center) = HTuple();
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center_visualize_object_model_3d(HTuple hv_ObjectModel3DID,
	HTuple *hv_Center)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Diameter, hv_MD, hv_Weight, hv_SumW;
	HTuple  hv_Index, hv_ObjectModel3DIDSelected, hv_C, hv_InvSum;

	//Compute the mean of all model centers (weighted by the diameter of the object models)
	if (0 != ((hv_ObjectModel3DID.TupleLength())>0))
	{
		GetObjectModel3dParams(hv_ObjectModel3DID, "diameter_axis_aligned_bounding_box",
			&hv_Diameter);
		//Normalize Diameter to use it as weights for a weighted mean of the individual centers
		hv_MD = hv_Diameter.TupleMean();
		if (0 != (hv_MD>1e-10))
		{
			hv_Weight = hv_Diameter / hv_MD;
		}
		else
		{
			hv_Weight = hv_Diameter;
		}
		hv_SumW = hv_Weight.TupleSum();
		if (0 != (hv_SumW<1e-10))
		{
			hv_Weight = HTuple(hv_Weight.TupleLength(), 1.0);
			hv_SumW = hv_Weight.TupleSum();
		}
		(*hv_Center).Clear();
		(*hv_Center)[0] = 0;
		(*hv_Center)[1] = 0;
		(*hv_Center)[2] = 0;
		{
			HTuple end_val16 = (hv_ObjectModel3DID.TupleLength()) - 1;
			HTuple step_val16 = 1;
			for (hv_Index = 0; hv_Index.Continue(end_val16, step_val16); hv_Index += step_val16)
			{
				hv_ObjectModel3DIDSelected = HTuple(hv_ObjectModel3DID[hv_Index]);
				GetObjectModel3dParams(hv_ObjectModel3DIDSelected, "center", &hv_C);
				(*hv_Center)[0] = HTuple((*hv_Center)[0]) + (HTuple(hv_C[0])*HTuple(hv_Weight[hv_Index]));
				(*hv_Center)[1] = HTuple((*hv_Center)[1]) + (HTuple(hv_C[1])*HTuple(hv_Weight[hv_Index]));
				(*hv_Center)[2] = HTuple((*hv_Center)[2]) + (HTuple(hv_C[2])*HTuple(hv_Weight[hv_Index]));
			}
		}
		hv_InvSum = 1.0 / hv_SumW;
		(*hv_Center)[0] = HTuple((*hv_Center)[0])*hv_InvSum;
		(*hv_Center)[1] = HTuple((*hv_Center)[1])*hv_InvSum;
		(*hv_Center)[2] = HTuple((*hv_Center)[2])*hv_InvSum;
	}
	else
	{
		(*hv_Center) = HTuple();
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center(HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel,
	HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_NumModels, hv_Centers, hv_Diameter;
	HTuple  hv_MD, hv_Weight, hv_SumW, hv_Index, hv_ObjectModel3DIDSelected;
	HTuple  hv_PoseSelected, hv_HomMat3D, hv_TBCenterCamX, hv_TBCenterCamY;
	HTuple  hv_TBCenterCamZ, hv_InvSum;

	hv_NumModels = hv_ObjectModel3D.TupleLength();
	(*hv_TBCenter)[0] = 0;
	(*hv_TBCenter)[1] = 0;
	(*hv_TBCenter)[2] = 0;
	GetObjectModel3dParams(hv_ObjectModel3D, "center", &hv_Centers);
	GetObjectModel3dParams(hv_ObjectModel3D, "diameter_axis_aligned_bounding_box",
		&hv_Diameter);
	//Normalize Diameter to use it as weights for a weighted mean of the individual centers
	hv_MD = hv_Diameter.TupleMean();
	if (0 != (hv_MD>1e-10))
	{
		hv_Weight = hv_Diameter / hv_MD;
	}
	else
	{
		hv_Weight = hv_Diameter;
	}
	hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
	if (0 != (hv_SumW<1e-10))
	{
		hv_Weight = HTuple(hv_Weight.TupleLength(), 1.0);
		hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
	}
	{
		HTuple end_val18 = hv_NumModels - 1;
		HTuple step_val18 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val18, step_val18); hv_Index += step_val18)
		{
			if (0 != (HTuple(hv_SelectedObject[hv_Index])))
			{
				hv_ObjectModel3DIDSelected = HTuple(hv_ObjectModel3D[hv_Index]);
				hv_PoseSelected = hv_Poses.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
				PoseToHomMat3d(hv_PoseSelected, &hv_HomMat3D);
				AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Centers[(hv_Index * 3) + 0]), HTuple(hv_Centers[(hv_Index * 3) + 1]),
					HTuple(hv_Centers[(hv_Index * 3) + 2]), &hv_TBCenterCamX, &hv_TBCenterCamY,
					&hv_TBCenterCamZ);
				(*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0]) + (hv_TBCenterCamX*HTuple(hv_Weight[hv_Index]));
				(*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1]) + (hv_TBCenterCamY*HTuple(hv_Weight[hv_Index]));
				(*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2]) + (hv_TBCenterCamZ*HTuple(hv_Weight[hv_Index]));
			}
		}
	}
	if (0 != ((hv_SelectedObject.TupleMax()) != 0))
	{
		hv_InvSum = 1.0 / hv_SumW;
		(*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0])*hv_InvSum;
		(*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1])*hv_InvSum;
		(*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2])*hv_InvSum;
		(*hv_TBSize) = (0.5 + ((0.5*(hv_SelectedObject.TupleSum())) / hv_NumModels))*hv_TrackballRadiusPixel;
	}
	else
	{
		(*hv_TBCenter) = HTuple();
		(*hv_TBSize) = 0;
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center_visualize_object_model_3d(HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel,
	HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_NumModels, hv_Centers, hv_Diameter;
	HTuple  hv_MD, hv_Weight, hv_SumW, hv_Index, hv_ObjectModel3DIDSelected;
	HTuple  hv_PoseSelected, hv_HomMat3D, hv_TBCenterCamX, hv_TBCenterCamY;
	HTuple  hv_TBCenterCamZ, hv_InvSum;

	hv_NumModels = hv_ObjectModel3D.TupleLength();
	(*hv_TBCenter)[0] = 0;
	(*hv_TBCenter)[1] = 0;
	(*hv_TBCenter)[2] = 0;
	GetObjectModel3dParams(hv_ObjectModel3D, "center", &hv_Centers);
	GetObjectModel3dParams(hv_ObjectModel3D, "diameter_axis_aligned_bounding_box",
		&hv_Diameter);
	//Normalize Diameter to use it as weights for a weighted mean of the individual centers
	hv_MD = hv_Diameter.TupleMean();
	if (0 != (hv_MD>1e-10))
	{
		hv_Weight = hv_Diameter / hv_MD;
	}
	else
	{
		hv_Weight = hv_Diameter;
	}
	hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
	if (0 != (hv_SumW<1e-10))
	{
		hv_Weight = HTuple(hv_Weight.TupleLength(), 1.0);
		hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
	}
	{
		HTuple end_val18 = hv_NumModels - 1;
		HTuple step_val18 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val18, step_val18); hv_Index += step_val18)
		{
			if (0 != (HTuple(hv_SelectedObject[hv_Index])))
			{
				hv_ObjectModel3DIDSelected = HTuple(hv_ObjectModel3D[hv_Index]);
				hv_PoseSelected = hv_Poses.TupleSelectRange(hv_Index * 7, (hv_Index * 7) + 6);
				PoseToHomMat3d(hv_PoseSelected, &hv_HomMat3D);
				AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Centers[(hv_Index * 3) + 0]), HTuple(hv_Centers[(hv_Index * 3) + 1]),
					HTuple(hv_Centers[(hv_Index * 3) + 2]), &hv_TBCenterCamX, &hv_TBCenterCamY,
					&hv_TBCenterCamZ);
				(*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0]) + (hv_TBCenterCamX*HTuple(hv_Weight[hv_Index]));
				(*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1]) + (hv_TBCenterCamY*HTuple(hv_Weight[hv_Index]));
				(*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2]) + (hv_TBCenterCamZ*HTuple(hv_Weight[hv_Index]));
			}
		}
	}
	if (0 != ((hv_SelectedObject.TupleMax()) != 0))
	{
		hv_InvSum = 1.0 / hv_SumW;
		(*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0])*hv_InvSum;
		(*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1])*hv_InvSum;
		(*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2])*hv_InvSum;
		(*hv_TBSize) = (0.5 + ((0.5*(hv_SelectedObject.TupleSum())) / hv_NumModels))*hv_TrackballRadiusPixel;
	}
	else
	{
		(*hv_TBCenter) = HTuple();
		(*hv_TBSize) = 0;
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed(HTuple hv_SelectedObject, HTuple hv_TrackballCenterRow,
	HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_Scene3D,
	HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, HTuple hv_CamParam,
	HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter, HTuple *hv_TBSize)
{

	// Local iconic variables
	HObject  ho_RegionCenter, ho_DistanceImage, ho_Domain;

	// Local control variables
	HTuple  hv_NumModels, hv_Width, hv_Height, hv_SelectPose;
	HTuple  hv_Index1, hv_Rows, hv_Columns, hv_Grayval, hv_IndicesG;
	HTuple  hv_Value, hv_Pos;

	//Determine the trackball center for the fixed trackball
	hv_NumModels = hv_ObjectModel3DID.TupleLength();
	get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
	get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
	//
	//Project the selected objects
	hv_SelectPose = HTuple();
	{
		HTuple end_val7 = (hv_SelectedObject.TupleLength()) - 1;
		HTuple step_val7 = 1;
		for (hv_Index1 = 0; hv_Index1.Continue(end_val7, step_val7); hv_Index1 += step_val7)
		{
			hv_SelectPose = hv_SelectPose.TupleConcat(HTuple(7, HTuple(hv_SelectedObject[hv_Index1])));
			if (0 != (HTuple(hv_SelectedObject[hv_Index1]) == 0))
			{
				SetScene3dInstanceParam(hv_Scene3D, hv_Index1, "visible", "false");
			}
		}
	}
	SetScene3dParam(hv_Scene3D, "depth_persistence", "true");
	DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
	SetScene3dParam(hv_Scene3D, "visible", "true");
	//
	//determine the depth of the object point that appears closest to the trackball
	//center
	GenRegionPoints(&ho_RegionCenter, hv_TrackballCenterRow, hv_TrackballCenterCol);
	DistanceTransform(ho_RegionCenter, &ho_DistanceImage, "chamfer-3-4-unnormalized",
		"false", hv_Width, hv_Height);
	GetDomain(ho_DistanceImage, &ho_Domain);
	GetRegionPoints(ho_Domain, &hv_Rows, &hv_Columns);
	GetGrayval(ho_DistanceImage, hv_Rows, hv_Columns, &hv_Grayval);
	TupleSortIndex(hv_Grayval, &hv_IndicesG);
	GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Rows.TupleSelect(hv_IndicesG),
		hv_Columns.TupleSelect(hv_IndicesG), "depth", &hv_Value);
	TupleFind(hv_Value.TupleSgn(), 1, &hv_Pos);
	//
	SetScene3dParam(hv_Scene3D, "depth_persistence", "false");
	//
	//
	//set TBCenter
	if (0 != (hv_Pos != -1))
	{
		//if the object is visible in the image
		(*hv_TBCenter).Clear();
		(*hv_TBCenter)[0] = 0;
		(*hv_TBCenter)[1] = 0;
		(*hv_TBCenter).Append(HTuple(hv_Value[HTuple(hv_Pos[0])]));
	}
	else
	{
		//if the object is not visible in the image, set the z coordinate to -1
		//to indicate, the the previous z value should be used instead
		(*hv_TBCenter).Clear();
		(*hv_TBCenter)[0] = 0;
		(*hv_TBCenter)[1] = 0;
		(*hv_TBCenter)[2] = -1;
	}
	//
	if (0 != ((hv_SelectedObject.TupleMax()) != 0))
	{
		(*hv_TBSize) = (0.5 + ((0.5*(hv_SelectedObject.TupleSum())) / hv_NumModels))*hv_TrackballRadiusPixel;
	}
	else
	{
		(*hv_TBCenter) = HTuple();
		(*hv_TBSize) = 0;
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed_visualize_object_model_3d(HTuple hv_SelectedObject,
	HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel,
	HTuple hv_Scene3D, HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer,
	HTuple hv_CamParam, HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter,
	HTuple *hv_TBSize)
{

	// Local iconic variables
	HObject  ho_RegionCenter, ho_DistanceImage, ho_Domain;

	// Local control variables
	HTuple  hv_NumModels, hv_Width, hv_Height, hv_SelectPose;
	HTuple  hv_Index1, hv_Rows, hv_Columns, hv_Grayval, hv_IndicesG;
	HTuple  hv_Value, hv_Pos;

	//Determine the trackball center for the fixed trackball
	hv_NumModels = hv_ObjectModel3DID.TupleLength();
	get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
	get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
	//
	//Project the selected objects
	hv_SelectPose = HTuple();
	{
		HTuple end_val7 = (hv_SelectedObject.TupleLength()) - 1;
		HTuple step_val7 = 1;
		for (hv_Index1 = 0; hv_Index1.Continue(end_val7, step_val7); hv_Index1 += step_val7)
		{
			hv_SelectPose = hv_SelectPose.TupleConcat(HTuple(7, HTuple(hv_SelectedObject[hv_Index1])));
			if (0 != (HTuple(hv_SelectedObject[hv_Index1]) == 0))
			{
				SetScene3dInstanceParam(hv_Scene3D, hv_Index1, "visible", "false");
			}
		}
	}
	SetScene3dParam(hv_Scene3D, "depth_persistence", "true");
	DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
	SetScene3dParam(hv_Scene3D, "visible", "true");
	//
	//determine the depth of the object point that appears closest to the trackball
	//center
	GenRegionPoints(&ho_RegionCenter, hv_TrackballCenterRow, hv_TrackballCenterCol);
	DistanceTransform(ho_RegionCenter, &ho_DistanceImage, "chamfer-3-4-unnormalized",
		"false", hv_Width, hv_Height);
	GetDomain(ho_DistanceImage, &ho_Domain);
	GetRegionPoints(ho_Domain, &hv_Rows, &hv_Columns);
	GetGrayval(ho_DistanceImage, hv_Rows, hv_Columns, &hv_Grayval);
	TupleSortIndex(hv_Grayval, &hv_IndicesG);
	GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Rows.TupleSelect(hv_IndicesG),
		hv_Columns.TupleSelect(hv_IndicesG), "depth", &hv_Value);
	TupleFind(hv_Value.TupleSgn(), 1, &hv_Pos);
	//
	SetScene3dParam(hv_Scene3D, "depth_persistence", "false");
	//
	//
	//set TBCenter
	if (0 != (hv_Pos != -1))
	{
		//if the object is visible in the image
		(*hv_TBCenter).Clear();
		(*hv_TBCenter)[0] = 0;
		(*hv_TBCenter)[1] = 0;
		(*hv_TBCenter).Append(HTuple(hv_Value[HTuple(hv_Pos[0])]));
	}
	else
	{
		//if the object is not visible in the image, set the z coordinate to -1
		//to indicate, the the previous z value should be used instead
		(*hv_TBCenter).Clear();
		(*hv_TBCenter)[0] = 0;
		(*hv_TBCenter)[1] = 0;
		(*hv_TBCenter)[2] = -1;
	}
	//
	if (0 != ((hv_SelectedObject.TupleMax()) != 0))
	{
		(*hv_TBSize) = (0.5 + ((0.5*(hv_SelectedObject.TupleSum())) / hv_NumModels))*hv_TrackballRadiusPixel;
	}
	else
	{
		(*hv_TBCenter) = HTuple();
		(*hv_TBSize) = 0;
	}
	return;
}

void inspect_normal_direction(HObject ho_MenuRegions, HTuple hv_WindowHandle1, HTuple hv_WindowHandle2,
	HTuple hv_WindowHandleMenu, HTuple hv_SurfaceModelID, HTuple hv_Scene, HTuple hv_RelSamplingDistance,
	HTuple hv_KeyPointFraction, HTuple hv_MinScore, HTuple hv_GenParamNames, HTuple hv_GenParamValues,
	HTuple hv_SurfaceMatchingResultID, HTuple hv_MenuText, HTuple hv_CurrentCase,
	HTuple hv_CasesDone, HTuple hv_FontSize, HTuple *hv_CreateNames, HTuple *hv_CreateValues,
	HTuple *hv_FindNames, HTuple *hv_FindValues)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Instructions, hv_SampledScene, hv_SampledModel;
	HTuple  hv_VC_P_Model, hv_Diameter, hv_VC_P_Scene, hv_NXYZOrig;
	HTuple  hv_MessageQueues1, hv_Buttons, hv_ShowNormals1;
	HTuple  hv_MessageQueues2, hv_ShowNormals2, hv_PreviousState1;
	HTuple  hv_PreviousState2, hv_DidFinish1, hv_DidFinish2;
	HTuple  hv_Row, hv_Column, hv_Width, hv_Height, hv_WindowHandleBufferMenu;
	HTuple  hv_SceneFast, hv_SceneMLS, hv_NormalsInverted, hv_ModelNormalsToggled;
	HTuple  hv_NormalCompMode, hv_SceneHasNormals, hv_FastMethod;
	HTuple  hv_Message, hv_MessageChanged, hv_ButtonPressed;
	HTuple  hv_Poses, hv_NXYZ, hv_MessageHandle, hv_Pose, hv_Score;
	HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_TIT;
	HTupleVector  hvec_TI(1);

	// +++ Threading variables 
	HDevThread*         hcppthread_handle;
	HDevThreadContext   hcppthread_context; // <-signals begin of procedure

											//
	hv_Instructions[0] = "Rotate: Left button";
	hv_Instructions[1] = "Zoom:   Shift + left button";
	hv_Instructions[2] = "Move:   Ctrl  + left button";
	//
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", HTuple(),
		&hv_SampledScene);
	GetSurfaceModelParam(hv_SurfaceModelID, "sampled_model", &hv_SampledModel);
	//
	//Visualization of the model's normals
	estimate_visualization_pose(hv_SampledModel, hv_WindowHandle1, &hv_VC_P_Model);
	//
	//Visualization of the scene's normals
	GetObjectModel3dParams(hv_SampledScene, "diameter", &hv_Diameter);
	//
	estimate_visualization_pose(hv_SampledScene, hv_WindowHandle2, &hv_VC_P_Scene);
	//
	GetObjectModel3dParams(hv_SampledModel, HTuple("point_normal_") + ((HTuple("x").Append("y")).Append("z")),
		&hv_NXYZOrig);
	//
	create_visualization_message_queues(&hv_MessageQueues1);
	hv_Buttons.Clear();
	hv_Buttons[0] = "Continue";
	hv_Buttons[1] = "right";
	hv_Buttons[2] = "bottom";
	hv_Buttons[3] = -1;
	hv_Buttons[4] = -1;
	hv_Buttons[5] = "Invert Normals";
	hv_Buttons[6] = "left";
	hv_Buttons[7] = "bottom";
	hv_Buttons[8] = -1;
	hv_Buttons[9] = -1;
	hv_Buttons[10] = "Hide Normals";
	hv_Buttons[11] = "center";
	hv_Buttons[12] = "bottom";
	hv_Buttons[13] = -1;
	hv_Buttons[14] = -1;
	hv_ShowNormals1 = 1;
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_visualize_object_model_3d_ext, 15, 0);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandle1);
	hcppthread_handle->SetInputCtrlParamTuple(1, hv_SampledModel);
	hcppthread_handle->SetInputCtrlParamTuple(2, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(3, hv_VC_P_Model);
	hcppthread_handle->SetInputCtrlParamTuple(4, (((HTuple("color_0").Append("normal_color_0")).Append("disp_normals")).Append("disp_pose")));
	hcppthread_handle->SetInputCtrlParamTuple(5, (((HTuple("cyan").Append("gray")).Append("true")).Append("true")));
	hcppthread_handle->SetInputCtrlParamTuple(6, "Model");
	hcppthread_handle->SetInputCtrlParamTuple(7, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(8, hv_Instructions);
	hcppthread_handle->SetInputCtrlParamTuple(9, hv_MessageQueues1);
	hcppthread_handle->SetInputCtrlParamTuple(10, hv_Buttons);
	hcppthread_handle->SetInputCtrlParamTuple(11, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(12, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(13, "false");
	hcppthread_handle->SetInputCtrlParamTuple(14, HTuple());

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[0].T());


	create_visualization_message_queues(&hv_MessageQueues2);
	hv_Buttons.Clear();
	hv_Buttons[0] = "Hide Normals";
	hv_Buttons[1] = "right";
	hv_Buttons[2] = "bottom";
	hv_Buttons[3] = -1;
	hv_Buttons[4] = -1;
	hv_Buttons[5] = "Normals: fast";
	hv_Buttons[6] = "left";
	hv_Buttons[7] = "bottom";
	hv_Buttons[8] = -1;
	hv_Buttons[9] = -1;
	hv_Buttons[10] = "Normals: mls";
	hv_Buttons[11] = "center";
	hv_Buttons[12] = "bottom";
	hv_Buttons[13] = -1;
	hv_Buttons[14] = -1;
	hv_ShowNormals2 = 1;
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_visualize_object_model_3d_ext, 15, 0);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandle2);
	hcppthread_handle->SetInputCtrlParamTuple(1, hv_SampledScene);
	hcppthread_handle->SetInputCtrlParamTuple(2, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(3, hv_VC_P_Scene);
	hcppthread_handle->SetInputCtrlParamTuple(4, (((HTuple("color_0").Append("normal_color_0")).Append("disp_normals")).Append("disp_pose")));
	hcppthread_handle->SetInputCtrlParamTuple(5, (((HTuple("cyan").Append("gray")).Append("true")).Append("true")));
	hcppthread_handle->SetInputCtrlParamTuple(6, "Scene");
	hcppthread_handle->SetInputCtrlParamTuple(7, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(8, hv_Instructions);
	hcppthread_handle->SetInputCtrlParamTuple(9, hv_MessageQueues2);
	hcppthread_handle->SetInputCtrlParamTuple(10, hv_Buttons);
	hcppthread_handle->SetInputCtrlParamTuple(11, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(12, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(13, "false");
	hcppthread_handle->SetInputCtrlParamTuple(14, HTuple());

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[1].T());

	hv_PreviousState1 = HTuple();
	hv_PreviousState2 = HTuple();
	hv_DidFinish1 = 0;
	hv_DidFinish2 = 0;
	//
	//Open a second (invisible) buffer window to avoid flickering
	GetWindowExtents(hv_WindowHandleMenu, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
	OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", &hv_WindowHandleBufferMenu);
	SetPart(hv_WindowHandleBufferMenu, 0, 0, hv_Height - 1, hv_Width - 1);
	set_display_font(hv_WindowHandleBufferMenu, hv_FontSize, "mono", "true", "false");
	//
	//Cached normals
	hv_SceneFast = HTuple();
	hv_SceneMLS = HTuple();
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "model_invert_normals", HTuple(),
		&hv_NormalsInverted);
	if (0 != (hv_NormalsInverted == HTuple("true")))
	{
		hv_ModelNormalsToggled = 1;
	}
	else
	{
		hv_ModelNormalsToggled = 0;
	}
	get_find_parameter(hv_GenParamNames, hv_GenParamValues, "scene_normal_computation",
		"fast", &hv_NormalCompMode);
	GetObjectModel3dParams(hv_Scene, "has_point_normals", &hv_SceneHasNormals);
	if (0 != (hv_SceneHasNormals == HTuple("true")))
	{
		hv_FastMethod = HTuple("(default, using existing scene normals)");
	}
	else
	{
		hv_FastMethod = HTuple("(default, using XYZ-mapping)");
	}
	(*hv_CreateNames) = HTuple();
	(*hv_CreateValues) = HTuple();
	(*hv_FindNames) = HTuple();
	(*hv_FindValues) = HTuple();
	//
	hv_Message[0] = HTuple("Check visually, if the normals of the model point approximately in the same direction as the normals of the scene by moving the model and the scene accordingly");
	if (0 != (hv_ModelNormalsToggled.TupleNot()))
	{
		hv_Message[1] = "Model normals are not inverted (default)";
	}
	else
	{
		hv_Message[1] = "Model normals are inverted";
	}
	if (0 != (hv_NormalCompMode == HTuple("fast")))
	{
		hv_Message[2] = "Scene normals are computed based on the fast method " + hv_FastMethod;
	}
	else if (0 != (hv_NormalCompMode == HTuple("mls")))
	{
		hv_Message[2] = "Scene normals are computed based on the mls method";
	}
	else
	{
		hv_Message[2] = "Scene normals are computed based on an unknown method";
	}
	hv_MessageChanged = 1;
	//
	do
	{
		//Process first visualization window
		process_visualize_events_generic(hv_WindowHandle1, hv_MessageQueues1, hv_PreviousState1,
			&hv_DidFinish1, &hv_PreviousState1, &hv_ButtonPressed, &hv_Poses);

		if (0 != (HTuple(hv_ButtonPressed == 0).TupleOr(hv_DidFinish1)))
		{
			//Exit-button
			break;
		}
		else if (0 != (hv_ButtonPressed == 1))
		{
			//Invert Normals
			GetObjectModel3dParams(hv_SampledModel, HTuple("point_normal_") + ((HTuple("x").Append("y")).Append("z")),
				&hv_NXYZ);
			SetObjectModel3dAttribMod(hv_SampledModel, HTuple("point_normal_") + ((HTuple("x").Append("y")).Append("z")),
				HTuple(), -hv_NXYZ);
			//Redraw to show the flipped normals
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "force_redraw");
			EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
			hv_ModelNormalsToggled = hv_ModelNormalsToggled.TupleNot();
			//Update parameter display
			if (0 != (hv_ModelNormalsToggled.TupleNot()))
			{
				hv_Message[1] = "Model normals are not inverted (default)";
				(*hv_CreateNames) = HTuple();
				(*hv_CreateValues) = HTuple();
			}
			else
			{
				hv_Message[1] = "Model normals are inverted";
				(*hv_CreateNames) = "model_invert_normals";
				(*hv_CreateValues) = "true";
			}
			hv_MessageChanged = 1;
		}
		else if (0 != (hv_ButtonPressed == 2))
		{
			//Toggle normals
			hv_ShowNormals1 = hv_ShowNormals1.TupleNot();
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
			SetMessageTuple(hv_MessageHandle, "param", "disp_normals");
			EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
			SetMessageTuple(hv_MessageHandle, "index", 2);
			if (0 != hv_ShowNormals1)
			{
				SetMessageTuple(hv_MessageHandle, "text", "Hide Normals");
			}
			else
			{
				SetMessageTuple(hv_MessageHandle, "text", "Show Normals");
			}
			EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
		}

		//Process second visualization window
		process_visualize_events_generic(hv_WindowHandle2, hv_MessageQueues2, hv_PreviousState2,
			&hv_DidFinish2, &hv_PreviousState2, &hv_ButtonPressed, &hv_Pose);

		if (0 != (hv_ButtonPressed == 0))
		{
			hv_ShowNormals2 = hv_ShowNormals2.TupleNot();
			//Toggle normals
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
			SetMessageTuple(hv_MessageHandle, "param", "disp_normals");
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
			SetMessageTuple(hv_MessageHandle, "index", 0);
			if (0 != hv_ShowNormals2)
			{
				SetMessageTuple(hv_MessageHandle, "text", "Hide Normals");
			}
			else
			{
				SetMessageTuple(hv_MessageHandle, "text", "Show Normals");
			}
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
		}
		else if (0 != (hv_ButtonPressed == 1))
		{
			//FAST
			//Use very fast find parameters, since we are only interested in the sampled scene
			if (0 != (hv_SceneFast == HTuple()))
			{
				FindSurfaceModel(hv_SurfaceModelID, hv_Scene, hv_RelSamplingDistance, 0.00001,
					0, "true", ((HTuple("dense_pose_refinement").Append("sparse_pose_refinement")).Append("scene_normal_computation")),
					((HTuple("false").Append("false")).Append("fast")), &hv_Pose, &hv_Score,
					&hv_SurfaceMatchingResultID);
				GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", 0,
					&hv_SceneFast);
			}
			//Send the new 3D object model to the visualization thread
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
			SetMessageTuple(hv_MessageHandle, "index", 0);
			SetMessageTuple(hv_MessageHandle, "model", hv_SceneFast);
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
			hv_Message[2] = "Scene normals are computed based on the fast method " + hv_FastMethod;
			hv_MessageChanged = 1;
			(*hv_FindNames) = HTuple();
			(*hv_FindValues) = HTuple();
		}
		else if (0 != (hv_ButtonPressed == 2))
		{
			//MLS
			if (0 != (hv_SceneMLS == HTuple()))
			{
				//Use very fast find parameters, since we are only interested in the sampled scene
				FindSurfaceModel(hv_SurfaceModelID, hv_Scene, hv_RelSamplingDistance, 0.00001,
					0, "true", ((HTuple("dense_pose_refinement").Append("sparse_pose_refinement")).Append("scene_normal_computation")),
					((HTuple("false").Append("false")).Append("mls")), &hv_Pose, &hv_Score,
					&hv_SurfaceMatchingResultID);
				GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", 0,
					&hv_SceneMLS);
			}
			//Send the new 3D object model to the visualization thread
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
			SetMessageTuple(hv_MessageHandle, "index", 0);
			SetMessageTuple(hv_MessageHandle, "model", hv_SceneMLS);
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
			hv_Message[2] = "Scene normals are computed based on the mls method";
			hv_MessageChanged = 1;
			(*hv_FindNames) = "scene_normal_computation";
			(*hv_FindValues) = "mls";
		}

		//Update the menu window
		if (0 != hv_MessageChanged)
		{
			ClearWindow(hv_WindowHandleBufferMenu);
			SetColor(hv_WindowHandleBufferMenu, "black");
			disp_menu_ext(ho_MenuRegions, hv_WindowHandleBufferMenu, hv_MenuText, hv_CasesDone,
				hv_CurrentCase);
			//
			SmallestRectangle1(ho_MenuRegions, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
			SetTposition(hv_WindowHandleBufferMenu, (hv_Row2.TupleMax()) + 6, 1);
			write_note(hv_WindowHandleBufferMenu, "instruction", HTuple(hv_Message[0]));
			write_note(hv_WindowHandleBufferMenu, "info", HTuple(hv_Message[1]));
			write_note(hv_WindowHandleBufferMenu, "none", HTuple(hv_Message[2]));
			CopyRectangle(hv_WindowHandleBufferMenu, hv_WindowHandleMenu, 0, 0, hv_Height - 1,
				(hv_Width * 2) - 1, 0, 0);
			hv_MessageChanged = 0;
		}
	} while (0 == (hv_DidFinish1.TupleOr(hv_DidFinish2)));
	//
	//Send termination message to all subthreads
	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
	//
	hv_TIT = hvec_TI.ConvertVectorToTuple();
	HDevThread::ParJoin(hv_TIT);
	//
	return;
}

void inspect_scene_edge_directions(HTuple hv_WindowHandle1, HTuple hv_WindowHandle2,
	HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID,
	HTuple hv_MaxGapIn, HTuple hv_MinAmplitudeIn, HTuple hv_ViewpointIn, HTuple *hv_Viewpoint)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Diameter, hv_DefaultAmplitude, hv_MinAmplitude;
	HTuple  hv_MaxAmplitude, hv_DefaultMaxGap, hv_MappingSize;
	HTuple  hv_MinMaxGap, hv_MaxMaxGap, hv_CenterScene, hv_DiameterScene;
	HTuple  hv_DiameterModel, hv_ViewpointStr, hv_Direction;
	HTuple  hv_Length, hv_LengthRel, hv_ViewpointViz, hv_ObjectModel3DSceneSampled;
	HTuple  hv_ObjectModel3DEdges, hv_EdgeDirs, hv_ObjectModel3DEdgeDirs;
	HTuple  hv_CenterSceneGravity, hv_OM3DCamera, hv_OM3DLineSphereToScene;
	HTuple  hv_DirectionLength, hv_ViewpointAsPoseIn, hv_DirNorm;
	HTuple  hv_Axis, hv_AxisNorm, hv_OrthogonalDirection, hv_RotationAxis;
	HTuple  hv_DirectionProjected, hv_AngleToX, hv_HomMat3DIdentity;
	HTuple  hv_HomMat3DRotate, hv_Instructions, hv_Row, hv_Column;
	HTuple  hv_Width, hv_Height, hv_CameraParam, hv_Buttons;
	HTuple  hv_MessageQueues1, hv_PreviousState1, hv_DidFinish1;
	HTuple  hv_VizCenter, hv_HomMat3DIdentity1, hv_PoseIn, hv_VizposeIn;
	HTuple  hv_ShowViewDir, hv_ShowEdgeDir, hv_MessageQueues2;
	HTuple  hv_PreviousState2, hv_ButtonPressed, hv_Pose, hv_MessageHandle;
	HTuple  hv_HomMat3D, hv_HomMat3DInvert, hv_Qx, hv_Qy, hv_Qz;
	HTuple  hv_DidFinish2, hv_Poses, hv_TIT;
	HTupleVector  hvec_TI(1);

	// +++ Threading variables 
	HDevThread*         hcppthread_handle;
	HDevThreadContext   hcppthread_context; // <-signals begin of procedure

											//Initial, Minimum and Maximum parameter values
	GetSurfaceModelParam(hv_SurfaceModelID, "diameter", &hv_Diameter);
	hv_DefaultAmplitude = hv_MinAmplitudeIn;
	hv_MinAmplitude = 0.0001*hv_Diameter;
	hv_MaxAmplitude = hv_Diameter;
	hv_DefaultMaxGap = hv_MaxGapIn;
	GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_size", &hv_MappingSize);
	hv_MinMaxGap = 0;
	hv_MaxMaxGap = hv_MappingSize.TupleMax();
	//
	GetObjectModel3dParams(hv_ObjectModel3DScene, "center", &hv_CenterScene);
	GetObjectModel3dParams(hv_ObjectModel3DScene, "diameter", &hv_DiameterScene);
	//
	GetSurfaceModelParam(hv_SurfaceModelID, "diameter", &hv_DiameterModel);
	(*hv_Viewpoint) = hv_ViewpointIn;
	hv_ViewpointStr = (((HTuple((*hv_Viewpoint)[0]) + " ") + HTuple((*hv_Viewpoint)[1])) + " ") + HTuple((*hv_Viewpoint)[2]);
	//With this method, the viewpoint would be very far away in view 2, leading to not-so-nice
	//visualization. Adapt the distance to be always <= SceneDiameter.
	hv_Direction = (*hv_Viewpoint) - hv_CenterScene;
	hv_Length = ((hv_Direction*hv_Direction).TupleSum()).TupleSqrt();
	hv_LengthRel = hv_Length / hv_DiameterScene;
	if (0 != (hv_LengthRel>1))
	{
		hv_Direction = hv_Direction / hv_LengthRel;
	}
	hv_ViewpointViz = hv_CenterScene + hv_Direction;
	//
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", 0, &hv_ObjectModel3DSceneSampled);
	EdgesObjectModel3d(hv_ObjectModel3DScene, hv_DefaultAmplitude, (HTuple("max_gap").Append("viewpoint")),
		hv_DefaultMaxGap.TupleConcat(hv_ViewpointStr), &hv_ObjectModel3DEdges);
	SampleObjectModel3d(hv_ObjectModel3DEdges, "fast_compute_normals", hv_DiameterModel*0.02,
		HTuple(), HTuple(), &hv_ObjectModel3DEdges);
	GetObjectModel3dParams(hv_ObjectModel3DEdges, HTuple("edge_dir_") + ((HTuple("x").Append("y")).Append("z")),
		&hv_EdgeDirs);
	SetObjectModel3dAttrib(hv_ObjectModel3DEdges, HTuple("point_normal_") + ((HTuple("x").Append("y")).Append("z")),
		HTuple(), hv_EdgeDirs, &hv_ObjectModel3DEdgeDirs);
	//
	//We only define a viewpoint, not a full camera. "Fake" a camera that looks towards the center of
	//gravity of the scene. Do not point it towards the center of the bounding box, since that is rather
	//unstable (a single outlier point would distort it).
	MomentsObjectModel3d(hv_ObjectModel3DScene, "mean_points", &hv_CenterSceneGravity);
	gen_camera_facing_scene(hv_ViewpointViz, hv_CenterSceneGravity, hv_DiameterModel * 2,
		&hv_OM3DCamera);
	GenObjectModel3dFromPoints(HTuple(hv_ViewpointViz[0]).TupleConcat(HTuple(hv_CenterScene[0])),
		HTuple(hv_ViewpointViz[1]).TupleConcat(HTuple(hv_CenterScene[1])), HTuple(hv_ViewpointViz[2]).TupleConcat(HTuple(hv_CenterScene[2])),
		&hv_OM3DLineSphereToScene);
	SetObjectModel3dAttribMod(hv_OM3DLineSphereToScene, "lines", HTuple(), ((HTuple(2).Append(0)).Append(1)));
	//
	//Convert input viewpoint into initial pose
	hv_Direction = (*hv_Viewpoint) - hv_CenterScene;
	hv_DirectionLength = ((hv_Direction*hv_Direction).TupleSum()).TupleSqrt();
	if (0 != (hv_DirectionLength<(1e-1*hv_DiameterModel)))
	{
		hv_ViewpointAsPoseIn.Clear();
		hv_ViewpointAsPoseIn[0] = 0;
		hv_ViewpointAsPoseIn[1] = 0;
		hv_ViewpointAsPoseIn[2] = 0;
		hv_ViewpointAsPoseIn[3] = 0;
		hv_ViewpointAsPoseIn[4] = 0;
		hv_ViewpointAsPoseIn[5] = 0;
		hv_ViewpointAsPoseIn[6] = 0;
	}
	else
	{
		//Create a rotation such that the camera faces the center of gravity of the scene
		hv_DirNorm = hv_Direction / hv_DirectionLength;
		if (0 != (((hv_DirNorm*((HTuple(0).Append(0)).Append(-1))).TupleSum())>-0.99999))
		{
			//Angle between the vectors is > 0.25
			hv_Axis = hv_DirNorm + ((HTuple(0).Append(0)).Append(-1));
			hv_AxisNorm = hv_Axis / (((hv_Axis*hv_Axis).TupleSum()).TupleSqrt());
			tuple_vector_cross_product(hv_DirNorm, ((HTuple(0).Append(0)).Append(1)), &hv_OrthogonalDirection);
			hv_OrthogonalDirection = hv_OrthogonalDirection / (((hv_OrthogonalDirection*hv_OrthogonalDirection).TupleSum()).TupleSqrt());
		}
		else
		{
			hv_Axis.Clear();
			hv_Axis[0] = 0;
			hv_Axis[1] = 1;
			hv_Axis[2] = 0;
			hv_OrthogonalDirection.Clear();
			hv_OrthogonalDirection[0] = 1;
			hv_OrthogonalDirection[1] = 0;
			hv_OrthogonalDirection[2] = 0;
		}
		tuple_vector_cross_product(((HTuple(0).Append(0)).Append(1)), hv_OrthogonalDirection,
			&hv_RotationAxis);
		tuple_vector_cross_product(((HTuple(0).Append(0)).Append(1)), hv_RotationAxis,
			&hv_DirectionProjected);
		hv_AngleToX = HTuple(hv_DirectionProjected[0]).TupleAtan2(HTuple(hv_DirectionProjected[1]));
		HomMat3dIdentity(&hv_HomMat3DIdentity);
		HomMat3dRotateLocal(hv_HomMat3DIdentity, HTuple(180).TupleRad(), hv_Axis, &hv_HomMat3DRotate);
		HomMat3dToPose(hv_HomMat3DRotate, &hv_ViewpointAsPoseIn);
	}
	hv_ViewpointAsPoseIn[HTuple::TupleGenSequence(0, 2, 1)] = (*hv_Viewpoint);
	PoseInvert(hv_ViewpointAsPoseIn, &hv_ViewpointAsPoseIn);
	//
	//Start the first 3D visualization window
	//In this window, one can set the viewpoint position
	hv_Instructions[0] = "Rotate: Left button";
	hv_Instructions[1] = "Zoom:   Shift + left button";
	hv_Instructions[2] = "Move:   Ctrl  + left button";
	//
	GetWindowExtents(hv_WindowHandle1, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
	gen_cam_par_area_scan_division(0.005, 0, 5.2e-06, 5.2e-06, (hv_Width*0.5) + 0.5,
		(hv_Height*0.5) + 0.5, hv_Width, hv_Height, &hv_CameraParam);
	hv_Buttons.Clear();
	hv_Buttons[0] = "Continue";
	hv_Buttons[1] = "right";
	hv_Buttons[2] = "bottom";
	hv_Buttons[3] = -1;
	hv_Buttons[4] = -1;
	hv_Buttons[5] = "Reset";
	hv_Buttons[6] = "left";
	hv_Buttons[7] = "bottom";
	hv_Buttons[8] = -1;
	hv_Buttons[9] = -1;
	create_visualization_message_queues(&hv_MessageQueues1);
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_visualize_object_model_3d_ext, 15, 0);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandle1);
	hcppthread_handle->SetInputCtrlParamTuple(1, hv_ObjectModel3DSceneSampled.TupleConcat(hv_ObjectModel3DEdges));
	hcppthread_handle->SetInputCtrlParamTuple(2, hv_CameraParam);
	hcppthread_handle->SetInputCtrlParamTuple(3, hv_ViewpointAsPoseIn);
	hcppthread_handle->SetInputCtrlParamTuple(4, ((HTuple("color_0").Append("color_1")).Append("disp_pose")));
	hcppthread_handle->SetInputCtrlParamTuple(5, ((HTuple("gray").Append("red")).Append("true")));
	hcppthread_handle->SetInputCtrlParamTuple(6, "Define Viewpoint");
	hcppthread_handle->SetInputCtrlParamTuple(7, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(8, hv_Instructions);
	hcppthread_handle->SetInputCtrlParamTuple(9, hv_MessageQueues1);
	hcppthread_handle->SetInputCtrlParamTuple(10, hv_Buttons);
	hcppthread_handle->SetInputCtrlParamTuple(11, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(12, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(13, "false");
	hcppthread_handle->SetInputCtrlParamTuple(14, HTuple());

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[0].T());

	hv_PreviousState1 = HTuple();
	hv_DidFinish1 = 0;
	//
	//Start the second 3D visualization window
	//Here, the edge directions are visualized
	//Find a viewpoint such that we see the scene and the camera "from the side".
	//This makes it easier to see what is going on.
	//To keep the scene upright, we first rotate around the x-axis, then around the
	//(original) z-axis.
	get_object_models_center(hv_ObjectModel3DSceneSampled.TupleConcat(hv_OM3DCamera),
		&hv_VizCenter);
	HomMat3dIdentity(&hv_HomMat3DIdentity1);
	HomMat3dRotate(hv_HomMat3DIdentity1, HTuple(-90).TupleRad(), ((HTuple(1).Append(0)).Append(0)),
		HTuple(hv_VizCenter[0]), HTuple(hv_VizCenter[1]), HTuple(hv_VizCenter[2]),
		&hv_HomMat3DRotate);
	HomMat3dRotateLocal(hv_HomMat3DRotate, hv_AngleToX, ((HTuple(0).Append(0)).Append(1)),
		&hv_HomMat3DRotate);
	HomMat3dToPose(hv_HomMat3DRotate, &hv_PoseIn);
	determine_optimum_pose_distance(hv_ObjectModel3DSceneSampled.TupleConcat(hv_OM3DCamera),
		hv_CameraParam, 0.5, hv_PoseIn, &hv_VizposeIn);
	//
	hv_Buttons.Clear();
	hv_Buttons[0] = "Hide Viewing Direction";
	hv_Buttons[1] = "left";
	hv_Buttons[2] = "bottom";
	hv_Buttons[3] = -1;
	hv_Buttons[4] = -1;
	hv_Buttons[5] = "Hide Edge Direction";
	hv_Buttons[6] = "right";
	hv_Buttons[7] = "bottom";
	hv_Buttons[8] = -1;
	hv_Buttons[9] = -1;
	hv_ShowViewDir = 1;
	hv_ShowEdgeDir = 1;
	create_visualization_message_queues(&hv_MessageQueues2);
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_visualize_object_model_3d_ext, 15, 0);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandle2);
	hcppthread_handle->SetInputCtrlParamTuple(1, (((hv_ObjectModel3DSceneSampled.TupleConcat(hv_ObjectModel3DEdges)).TupleConcat(hv_ObjectModel3DEdgeDirs)).TupleConcat(hv_OM3DCamera)).TupleConcat(hv_OM3DLineSphereToScene));
	hcppthread_handle->SetInputCtrlParamTuple(2, hv_CameraParam);
	hcppthread_handle->SetInputCtrlParamTuple(3, hv_VizposeIn);
	hcppthread_handle->SetInputCtrlParamTuple(4, (((((((HTuple("color_0").Append("color_1")).Append("color_2")).Append("color_3")).Append("color_4")).Append("disp_pose")).Append("disp_normals_1")).Append("disp_normals_2")));
	hcppthread_handle->SetInputCtrlParamTuple(5, (((((((HTuple("gray").Append("green")).Append("red")).Append("gray")).Append("white")).Append("true")).Append("true")).Append("true")));
	hcppthread_handle->SetInputCtrlParamTuple(6, "Inspect Edges");
	hcppthread_handle->SetInputCtrlParamTuple(7, ((((HTuple("").Append("")).Append("")).Append("Viewpoint")).Append("")));
	hcppthread_handle->SetInputCtrlParamTuple(8, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(9, hv_MessageQueues2);
	hcppthread_handle->SetInputCtrlParamTuple(10, hv_Buttons);
	hcppthread_handle->SetInputCtrlParamTuple(11, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(12, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(13, "false");
	hcppthread_handle->SetInputCtrlParamTuple(14, HTuple());

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[1].T());

	hv_PreviousState2 = HTuple();
	//
	while (0 != (hv_DidFinish1.TupleNot()))
	{
		process_visualize_events_generic(hv_WindowHandle1, hv_MessageQueues1, hv_PreviousState1,
			&hv_DidFinish1, &hv_PreviousState1, &hv_ButtonPressed, &hv_Pose);
		if (0 != (HTuple(hv_ButtonPressed == 0).TupleOr(hv_DidFinish1)))
		{
			//Exit button pressed
			break;
		}
		else if (0 != (hv_ButtonPressed == 1))
		{
			//Reset button pressed
			(*hv_Viewpoint).Clear();
			(*hv_Viewpoint)[0] = 0;
			(*hv_Viewpoint)[1] = 0;
			(*hv_Viewpoint)[2] = 0;
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "set_pose");
			SetMessageTuple(hv_MessageHandle, "poses", hv_ViewpointAsPoseIn);
			EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
			//Also update the second view below
			hv_Pose = hv_ViewpointAsPoseIn;
		}
		if (0 != (hv_Pose != HTuple()))
		{
			//The pose of view 1 was updated
			//-> Update the viewpoint in view 2
			PoseToHomMat3d(hv_Pose.TupleSelectRange(0, 6), &hv_HomMat3D);
			HomMat3dInvert(hv_HomMat3D, &hv_HomMat3DInvert);
			AffineTransPoint3d(hv_HomMat3DInvert, 0, 0, 0, &hv_Qx, &hv_Qy, &hv_Qz);
			(*hv_Viewpoint).Clear();
			(*hv_Viewpoint).Append(hv_Qx);
			(*hv_Viewpoint).Append(hv_Qy);
			(*hv_Viewpoint).Append(hv_Qz);
			hv_ViewpointStr = (((HTuple((*hv_Viewpoint)[0]) + " ") + HTuple((*hv_Viewpoint)[1])) + " ") + HTuple((*hv_Viewpoint)[2]);
			//With this method, the viewpoint would be very far away in view 2, leading to not-so-nice
			//visualization. Adapt the distance to be always <= SceneDiameter.
			hv_Direction = (*hv_Viewpoint) - hv_CenterScene;
			hv_Length = ((hv_Direction*hv_Direction).TupleSum()).TupleSqrt();
			hv_LengthRel = hv_Length / hv_DiameterScene;
			if (0 != (hv_LengthRel>1))
			{
				hv_Direction = hv_Direction / hv_LengthRel;
			}
			hv_ViewpointViz = hv_CenterScene + hv_Direction;
			//
			//Update title of left visualization window
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "change_title");
			SetMessageTuple(hv_MessageHandle, "title", HTuple("Define Viewpoint").TupleConcat(((((("Current Viewpoint: [" + HTuple((*hv_Viewpoint)[0])) + HTuple(",")) + HTuple((*hv_Viewpoint)[1])) + HTuple(",")) + HTuple((*hv_Viewpoint)[2])) + "]"));
			EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
			//
			gen_camera_facing_scene(hv_ViewpointViz, hv_CenterSceneGravity, hv_DiameterModel * 2,
				&hv_OM3DCamera);

			GenObjectModel3dFromPoints(HTuple(hv_ViewpointViz[0]).TupleConcat(HTuple(hv_CenterScene[0])),
				HTuple(hv_ViewpointViz[1]).TupleConcat(HTuple(hv_CenterScene[1])), HTuple(hv_ViewpointViz[2]).TupleConcat(HTuple(hv_CenterScene[2])),
				&hv_OM3DLineSphereToScene);
			SetObjectModel3dAttribMod(hv_OM3DLineSphereToScene, "lines", HTuple(), ((HTuple(2).Append(0)).Append(1)));
			EdgesObjectModel3d(hv_ObjectModel3DScene, hv_DefaultAmplitude, (HTuple("max_gap").Append("viewpoint")),
				hv_DefaultMaxGap.TupleConcat(hv_ViewpointStr), &hv_ObjectModel3DEdges);
			SampleObjectModel3d(hv_ObjectModel3DEdges, "fast_compute_normals", hv_DiameterModel*0.02,
				HTuple(), HTuple(), &hv_ObjectModel3DEdges);
			//
			GetObjectModel3dParams(hv_ObjectModel3DEdges, HTuple("edge_dir_") + ((HTuple("x").Append("y")).Append("z")),
				&hv_EdgeDirs);
			SetObjectModel3dAttrib(hv_ObjectModel3DEdges, HTuple("point_normal_") + ((HTuple("x").Append("y")).Append("z")),
				HTuple(), hv_EdgeDirs, &hv_ObjectModel3DEdgeDirs);
			//
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
			SetMessageTuple(hv_MessageHandle, "index", (((HTuple(1).Append(2)).Append(3)).Append(4)));
			SetMessageTuple(hv_MessageHandle, "model", ((hv_ObjectModel3DEdges.TupleConcat(hv_ObjectModel3DEdgeDirs)).TupleConcat(hv_OM3DCamera)).TupleConcat(hv_OM3DLineSphereToScene));
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
		}

		process_visualize_events_generic(hv_WindowHandle2, hv_MessageQueues2, hv_PreviousState2,
			&hv_DidFinish2, &hv_PreviousState2, &hv_ButtonPressed, &hv_Poses);
		if (0 != hv_DidFinish2)
		{
			break;
		}
		if (0 != (hv_ButtonPressed == 0))
		{
			hv_ShowViewDir = hv_ShowViewDir.TupleNot();
			//Toggle viewing direction
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
			SetMessageTuple(hv_MessageHandle, "param", "disp_normals_1");
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
			SetMessageTuple(hv_MessageHandle, "index", 0);
			if (0 != hv_ShowViewDir)
			{
				SetMessageTuple(hv_MessageHandle, "text", "Hide Viewing Direction");
			}
			else
			{
				SetMessageTuple(hv_MessageHandle, "text", "Show Viewing Direction");
			}
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
		}
		else if (0 != (hv_ButtonPressed == 1))
		{
			hv_ShowEdgeDir = hv_ShowEdgeDir.TupleNot();
			//Toggle viewing direction
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
			SetMessageTuple(hv_MessageHandle, "param", "disp_normals_2");
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
			SetMessageTuple(hv_MessageHandle, "index", 1);
			if (0 != hv_ShowEdgeDir)
			{
				SetMessageTuple(hv_MessageHandle, "text", "Hide Edge Direction");
			}
			else
			{
				SetMessageTuple(hv_MessageHandle, "text", "Show Edge Direction");
			}
			EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
		}
	}

	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
	//
	hv_TIT = hvec_TI.ConvertVectorToTuple();
	HDevThread::ParJoin(hv_TIT);

	return;
}

void inspect_scene_edge_parameters(HTuple hv_WindowHandle1, HTuple hv_WindowHandle2,
	HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID,
	HTuple hv_MaxGapIn, HTuple hv_MinAmplitudeAbsIn, HTuple hv_ViewpointIn, HTuple *hv_MaxGap,
	HTuple *hv_MinAmplitudeAbs)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Diameter, hv_DefaultAmplitude, hv_MinAmplitude;
	HTuple  hv_MaxAmplitude, hv_DefaultMaxGap, hv_MappingSize;
	HTuple  hv_MinMaxGap, hv_MaxMaxGap, hv_ViewpointStr, hv_ObjectModel3DSceneSampled;
	HTuple  hv_ObjectModel3DEdges, hv_Instructions, hv_Buttons;
	HTuple  hv_MessageQueues1, hv_PreviousState1, hv_DidFinish1;
	HTuple  hv_MessageQueues2, hv_MinAmplitudeRel, hv_XXScene;
	HTuple  hv_YYScene, hv_ZZScene, hv_PreviousState2, hv_ButtonPressed;
	HTuple  hv_Poses, hv_DidFinish2, hv_MessageHandle, hv_TIT;
	HTupleVector  hvec_TI(1);

	// +++ Threading variables 
	HDevThread*         hcppthread_handle;
	HDevThreadContext   hcppthread_context; // <-signals begin of procedure

											//Initial, Minimum and Maximum parameter values
	GetSurfaceModelParam(hv_SurfaceModelID, "diameter", &hv_Diameter);
	hv_DefaultAmplitude = hv_MinAmplitudeAbsIn / hv_Diameter;
	hv_MinAmplitude = 0.0001;
	hv_MaxAmplitude = 1;
	hv_DefaultMaxGap = hv_MaxGapIn;
	GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_size", &hv_MappingSize);
	hv_MinMaxGap = 0;
	hv_MaxMaxGap = hv_MappingSize.TupleMax();
	hv_ViewpointStr = (hv_ViewpointIn + " ").TupleSum();
	//
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", 0, &hv_ObjectModel3DSceneSampled);
	EdgesObjectModel3d(hv_ObjectModel3DScene, hv_DefaultAmplitude*hv_Diameter, (HTuple("max_gap").Append("viewpoint")),
		hv_DefaultMaxGap.TupleConcat(hv_ViewpointStr), &hv_ObjectModel3DEdges);
	//
	//Start the 3D visualization window
	hv_Instructions[0] = "Rotate: Left button";
	hv_Instructions[1] = "Zoom:   Shift + left button";
	hv_Instructions[2] = "Move:   Ctrl  + left button";
	//
	hv_Buttons.Clear();
	hv_Buttons[0] = "Continue";
	hv_Buttons[1] = "right";
	hv_Buttons[2] = "bottom";
	hv_Buttons[3] = -1;
	hv_Buttons[4] = -1;
	create_visualization_message_queues(&hv_MessageQueues1);
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_visualize_object_model_3d_ext, 15, 0);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandle1);
	hcppthread_handle->SetInputCtrlParamTuple(1, hv_ObjectModel3DSceneSampled.TupleConcat(hv_ObjectModel3DEdges));
	hcppthread_handle->SetInputCtrlParamTuple(2, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(3, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(4, ((HTuple("color_0").Append("color_1")).Append("disp_pose")));
	hcppthread_handle->SetInputCtrlParamTuple(5, ((HTuple("gray").Append("red")).Append("true")));
	hcppthread_handle->SetInputCtrlParamTuple(6, "Inspection");
	hcppthread_handle->SetInputCtrlParamTuple(7, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(8, hv_Instructions);
	hcppthread_handle->SetInputCtrlParamTuple(9, hv_MessageQueues1);
	hcppthread_handle->SetInputCtrlParamTuple(10, hv_Buttons);
	hcppthread_handle->SetInputCtrlParamTuple(11, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(12, HTuple());
	hcppthread_handle->SetInputCtrlParamTuple(13, "false");
	hcppthread_handle->SetInputCtrlParamTuple(14, HTuple());

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[0].T());

	//
	hv_PreviousState1 = HTuple();
	hv_DidFinish1 = 0;
	//
	//Start the 2D Slider window
	create_visualization_message_queues(&hv_MessageQueues2);
	// Create a thread instance
	hcppthread_handle = new HDevThread(hcppthread_context,
		(void*)HDevExportCpp::_hcppthread_set_edge_parameter_sliders, 8, 2);
	// Set thread procedure call arguments 
	hcppthread_handle->SetInputCtrlParamTuple(0, hv_WindowHandle2);
	hcppthread_handle->SetInputCtrlParamTuple(1, hv_ObjectModel3DScene);
	hcppthread_handle->SetInputCtrlParamTuple(2, hv_MessageQueues2);
	hcppthread_handle->SetInputCtrlParamTuple(3, hv_MessageQueues1);
	hcppthread_handle->SetInputCtrlParamTuple(4, hv_Diameter);
	hcppthread_handle->SetInputCtrlParamTuple(5, (hv_MinAmplitude.TupleConcat(hv_MaxAmplitude)).TupleConcat(hv_DefaultAmplitude));
	hcppthread_handle->SetInputCtrlParamTuple(6, (hv_MinMaxGap.TupleConcat(hv_MaxMaxGap)).TupleConcat(hv_DefaultMaxGap));
	hcppthread_handle->SetInputCtrlParamTuple(7, hv_ViewpointIn);
	hcppthread_handle->BindOutputCtrlParamTuple(0, 0, &hv_MinAmplitudeRel);
	hcppthread_handle->BindOutputCtrlParamTuple(1, 0, &(*hv_MaxGap));

	// Start proc line in thread
	hcppthread_handle->ParStart(&hvec_TI[1].T());

	//
	GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_x", &hv_XXScene);
	GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_y", &hv_YYScene);
	GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_z", &hv_ZZScene);
	//
	hv_PreviousState2 = HTuple();
	//
	while (0 != (hv_DidFinish1.TupleNot()))
	{
		process_visualize_events_generic(hv_WindowHandle1, hv_MessageQueues1, hv_PreviousState1,
			&hv_DidFinish1, &hv_PreviousState1, &hv_ButtonPressed, &hv_Poses);

		if (0 != (HTuple(hv_ButtonPressed == 0).TupleOr(hv_DidFinish1)))
		{
			//Exit button pressed
			break;
		}

		process_slider_events(hv_WindowHandle2, hv_MessageQueues2, hv_PreviousState2,
			&hv_PreviousState2, &hv_DidFinish2);
		if (0 != hv_DidFinish2)
		{
			//Window closed
			break;
		}
	}

	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues1[1]), hv_MessageHandle, HTuple(), HTuple());
	CreateMessage(&hv_MessageHandle);
	SetMessageTuple(hv_MessageHandle, "type", "exit");
	EnqueueMessage(HTuple(hv_MessageQueues2[1]), hv_MessageHandle, HTuple(), HTuple());
	//
	hv_TIT = hvec_TI.ConvertVectorToTuple();
	HDevThread::ParJoin(hv_TIT);
	//
	//Convert from relative to absolute
	(*hv_MinAmplitudeAbs) = hv_MinAmplitudeRel*hv_Diameter;
	//
	return;
}

// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width(HTuple hv_WindowHandle, HTuple hv_Lines, HTuple *hv_MaxWidth)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Index, hv_Ascent, hv_Descent, hv_LineWidth;
	HTuple  hv_LineHeight;

	(*hv_MaxWidth) = 0;
	{
		HTuple end_val1 = (hv_Lines.TupleLength()) - 1;
		HTuple step_val1 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val1, step_val1); hv_Index += step_val1)
		{
			GetStringExtents(hv_WindowHandle, HTuple(hv_Lines[hv_Index]), &hv_Ascent, &hv_Descent,
				&hv_LineWidth, &hv_LineHeight);
			(*hv_MaxWidth) = (hv_LineWidth.TupleConcat((*hv_MaxWidth))).TupleMax();
		}
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width_visualize_object_model_3d(HTuple hv_WindowHandle, HTuple hv_Lines,
	HTuple *hv_MaxWidth)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Index, hv_Ascent, hv_Descent, hv_LineWidth;
	HTuple  hv_LineHeight;

	(*hv_MaxWidth) = 0;
	{
		HTuple end_val1 = (hv_Lines.TupleLength()) - 1;
		HTuple step_val1 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val1, step_val1); hv_Index += step_val1)
		{
			GetStringExtents(hv_WindowHandle, HTuple(hv_Lines[hv_Index]), &hv_Ascent, &hv_Descent,
				&hv_LineWidth, &hv_LineHeight);
			(*hv_MaxWidth) = (hv_LineWidth.TupleConcat((*hv_MaxWidth))).TupleMax();
		}
	}
	return;
}

void process_slider_events(HTuple hv_WindowHandle, HTuple hv_MessageQueues, HTuple hv_PreviousState,
	HTuple *hv_CurrentState, HTuple *hv_DidFinish)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Row, hv_Column, hv_Button, hv_Current;
	HTuple  hv_MessageHandle, hv_MessageHandleIgnore, hv_Exception;
	HTuple  hv_EventHappened1;

	(*hv_CurrentState) = hv_PreviousState;

	(*hv_DidFinish) = 0;
	try
	{
		get_mouse_info(hv_WindowHandle, HTuple(), HTuple(), &hv_Row, &hv_Column, &hv_Button);
		hv_Current.Clear();
		hv_Current.Append(hv_Row);
		hv_Current.Append(hv_Column);
		hv_Current.Append(hv_Button);
		if (0 != (hv_Current != hv_PreviousState))
		{
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "mouse_event");
			SetMessageTuple(hv_MessageHandle, "mouse_row", hv_Row);
			SetMessageTuple(hv_MessageHandle, "mouse_col", hv_Column);
			SetMessageTuple(hv_MessageHandle, "mouse_button", hv_Button);
			//Remove any previous mouse message and overwrite it with the new
			//message. If the sub thread is too slow to process the mouse events,
			//we rather skip one and only use the last one. This avoids
			//the "lagging" GUI effect.
			try
			{
				DequeueMessage(HTuple(hv_MessageQueues[0]), "timeout", 0, &hv_MessageHandleIgnore);
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
			}
			EnqueueMessage(HTuple(hv_MessageQueues[0]), hv_MessageHandle, HTuple(), HTuple());
			(*hv_CurrentState) = hv_Current;
			hv_EventHappened1 = 1;
		}
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		if (0 != (HTuple(hv_Exception[0]) == 2891))
		{
			//Message queue overflow
			//-> there is already a mouse event in the queue, do not add another one
			//   to avoid overflowing the queue
			return;
		}
		else if (0 != (HTuple(HTuple(hv_Exception[0]) == 5).TupleAnd(HTuple(hv_Exception[5]) == HTuple("get_mposition_sub_pix"))))
		{
			//Mouse not in window
			//Ignore
			WaitSeconds(0.01);
		}
		else if (0 != (HTuple(HTuple(hv_Exception[0]) == 2454).TupleOr(HTuple(hv_Exception[0]) == 5100)))
		{
			//Handle was already cleared -> indicates that the window was closed (by the user)
			//Abort gracefully.
			(*hv_DidFinish) = 1;
			return;
		}
		else
		{
			//Unknown / Unexpected exception
			throw HException(hv_Exception);
		}
	}
	return;

}

// Short Description: Generic processor for events of visualize_object_model_3d_ext 
void process_visualize_events_generic(HTuple hv_WindowHandle, HTuple hv_MessageQueues,
	HTuple hv_PreviousState, HTuple *hv_DidFinish, HTuple *hv_NewState, HTuple *hv_ButtonPressed,
	HTuple *hv_Poses)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_MessageHandle, hv_Type, hv_ButtonID;
	HTuple  hv_Exception, hv_Row, hv_Column, hv_Button, hv_Current;
	HTuple  hv_MessageHandleIgnore;

	(*hv_NewState) = hv_PreviousState;
	(*hv_ButtonPressed) = HTuple();
	(*hv_Poses) = HTuple();
	(*hv_DidFinish) = 0;
	//
	try
	{
		try
		{
			DequeueMessage(HTuple(hv_MessageQueues[2]), "timeout", 0, &hv_MessageHandle);
			GetMessageTuple(hv_MessageHandle, "type", &hv_Type);
			if (0 != (hv_Type == HTuple("done")))
			{
				//The visualization function has finished and has exited
				(*hv_DidFinish) = 1;
			}
			else if (0 != (hv_Type == HTuple("button_pressed")))
			{
				//The user pressed one of the buttons
				GetMessageTuple(hv_MessageHandle, "button", &hv_ButtonID);
				(*hv_ButtonPressed) = hv_ButtonID;
			}
			else if (0 != (hv_Type == HTuple("redraw")))
			{
				GetMessageTuple(hv_MessageHandle, "poses", &(*hv_Poses));
				//Nothing TBD
			}
			else
			{
				//Unknown / unexpected Message
				// stop(...); only in hdevelop
			}
		}
		// catch (Exception) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception);
			//Ignore timeout (no message in queue)
			if (0 != (HTuple(hv_Exception[0]) != 9400))
			{
				throw HException(hv_Exception);
			}
		}

		get_mouse_info(hv_WindowHandle, HTuple(), HTuple(), &hv_Row, &hv_Column, &hv_Button);

		hv_Current.Clear();
		hv_Current.Append(hv_Row);
		hv_Current.Append(hv_Column);
		hv_Current.Append(hv_Button);
		if (0 != (hv_Current != hv_PreviousState))
		{
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "mouse_event");
			SetMessageTuple(hv_MessageHandle, "mouse_row", hv_Row);
			SetMessageTuple(hv_MessageHandle, "mouse_col", hv_Column);
			SetMessageTuple(hv_MessageHandle, "mouse_button", hv_Button);
			//Remove any previous mouse message and overwrite it with the new
			//message. If the sub thread is too slow to process the mouse events,
			//we rather skip one and only use the last one. This avoids
			//the "lagging" GUI effect.
			try
			{
				DequeueMessage(HTuple(hv_MessageQueues[0]), "timeout", 0, &hv_MessageHandleIgnore);
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
				//Ignore
			}
			EnqueueMessage(HTuple(hv_MessageQueues[0]), hv_MessageHandle, HTuple(), HTuple());
			(*hv_NewState) = hv_Current;
		}
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		if (0 != (HTuple(hv_Exception[0]) == 2891))
		{
			//Message Queue overflow (usually of the mouse event queue)
			return;
		}
		else if (0 != (HTuple(HTuple(hv_Exception[0]) == 5).TupleAnd(HTuple(hv_Exception[5]) == HTuple("get_mposition_sub_pix"))))
		{
			//Mouse not in window
			//Ignore
			WaitSeconds(0.01);
		}
		else if (0 != (HTuple(HTuple(hv_Exception[0]) == 2454).TupleOr(HTuple(hv_Exception[0]) == 5100)))
		{
			//Handle was already cleared -> indicates that the window was closed (by the user)
			//Abort gracefully.
			(*hv_DidFinish) = 1;
			return;
		}
		else
		{
			//Unknown / Unexpected exception
			throw HException(hv_Exception);
		}
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball(HTuple hv_X, HTuple hv_Y, HTuple hv_VirtualTrackball,
	HTuple hv_TrackballSize, HTuple *hv_V)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_R, hv_XP, hv_YP, hv_ZP;

	if (0 != (hv_VirtualTrackball == HTuple("shoemake")))
	{
		//Virtual Trackball according to Shoemake
		hv_R = ((hv_X*hv_X) + (hv_Y*hv_Y)).TupleSqrt();
		if (0 != (hv_R <= hv_TrackballSize))
		{
			hv_XP = hv_X;
			hv_YP = hv_Y;
			hv_ZP = ((hv_TrackballSize*hv_TrackballSize) - (hv_R*hv_R)).TupleSqrt();
		}
		else
		{
			hv_XP = (hv_X*hv_TrackballSize) / hv_R;
			hv_YP = (hv_Y*hv_TrackballSize) / hv_R;
			hv_ZP = 0;
		}
	}
	else
	{
		//Virtual Trackball according to Bell
		hv_R = ((hv_X*hv_X) + (hv_Y*hv_Y)).TupleSqrt();
		if (0 != (hv_R <= (hv_TrackballSize*0.70710678)))
		{
			hv_XP = hv_X;
			hv_YP = hv_Y;
			hv_ZP = ((hv_TrackballSize*hv_TrackballSize) - (hv_R*hv_R)).TupleSqrt();
		}
		else
		{
			hv_XP = hv_X;
			hv_YP = hv_Y;
			hv_ZP = ((0.6*hv_TrackballSize)*hv_TrackballSize) / hv_R;
		}
	}
	(*hv_V).Clear();
	(*hv_V).Append(hv_XP);
	(*hv_V).Append(hv_YP);
	(*hv_V).Append(hv_ZP);
	return;
}

// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball_visualize_object_model_3d(HTuple hv_X, HTuple hv_Y,
	HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple *hv_V)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_R, hv_XP, hv_YP, hv_ZP;

	if (0 != (hv_VirtualTrackball == HTuple("shoemake")))
	{
		//Virtual Trackball according to Shoemake
		hv_R = ((hv_X*hv_X) + (hv_Y*hv_Y)).TupleSqrt();
		if (0 != (hv_R <= hv_TrackballSize))
		{
			hv_XP = hv_X;
			hv_YP = hv_Y;
			hv_ZP = ((hv_TrackballSize*hv_TrackballSize) - (hv_R*hv_R)).TupleSqrt();
		}
		else
		{
			hv_XP = (hv_X*hv_TrackballSize) / hv_R;
			hv_YP = (hv_Y*hv_TrackballSize) / hv_R;
			hv_ZP = 0;
		}
	}
	else
	{
		//Virtual Trackball according to Bell
		hv_R = ((hv_X*hv_X) + (hv_Y*hv_Y)).TupleSqrt();
		if (0 != (hv_R <= (hv_TrackballSize*0.70710678)))
		{
			hv_XP = hv_X;
			hv_YP = hv_Y;
			hv_ZP = ((hv_TrackballSize*hv_TrackballSize) - (hv_R*hv_R)).TupleSqrt();
		}
		else
		{
			hv_XP = hv_X;
			hv_YP = hv_Y;
			hv_ZP = ((0.6*hv_TrackballSize)*hv_TrackballSize) / hv_R;
		}
	}
	(*hv_V).Clear();
	(*hv_V).Append(hv_XP);
	(*hv_V).Append(hv_YP);
	(*hv_V).Append(hv_ZP);
	return;
}

void select_case(HObject ho_MenuRegions, HTuple hv_WindowHandleMenu, HTuple hv_MenuTexts,
	HTuple *hv_SelectedCase)
{

	// Local iconic variables
	HObject  ho_ObjectSelected;

	// Local control variables
	HTuple  hv_Row, hv_Column, hv_Button, hv_Number;
	HTuple  hv_Index, hv_IsInside, hv_Exception;

	while (0 != 1)
	{
		try
		{
			GetMposition(hv_WindowHandleMenu, &hv_Row, &hv_Column, &hv_Button);
			if (0 != (hv_Button == 1))
			{
				CountObj(ho_MenuRegions, &hv_Number);
				{
					HTuple end_val5 = hv_Number.TupleMin2(hv_MenuTexts.TupleLength());
					HTuple step_val5 = 1;
					for (hv_Index = 1; hv_Index.Continue(end_val5, step_val5); hv_Index += step_val5)
					{
						SelectObj(ho_MenuRegions, &ho_ObjectSelected, hv_Index);
						TestRegionPoint(ho_ObjectSelected, hv_Row, hv_Column, &hv_IsInside);
						if (0 != hv_IsInside)
						{
							(*hv_SelectedCase) = hv_Index - 1;
							return;
						}
					}
				}
			}
		}
		// catch (Exception) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception);
			if (0 != (HTuple(HTuple(hv_Exception[0]) == 2454).TupleOr(HTuple(hv_Exception[0]) == 5100)))
			{
				//Handle was already cleared -> indicates that the window was closed (by the user)
				//Abort gracefully.
				(*hv_SelectedCase) = -1;
				return;
			}
			else if (0 != (HTuple(hv_Exception[0]) == 5))
			{
				//Ignore -> mouse outside of window
			}
			else
			{
				//Unknown / Unexpected exception
				//Ignore for now
			}
		}
	}
	return;
}

void send_pose_update(HTuple hv_Parameters, HTuple hv_Poses)
{

	// Local control variables
	HTuple  hv_MessageQueue, hv_MessageHandle;

	GetMessageTuple(hv_Parameters, "MessageQueue", &hv_MessageQueue);
	if (0 != (hv_MessageQueue != HTuple()))
	{
		CreateMessage(&hv_MessageHandle);
		SetMessageTuple(hv_MessageHandle, "type", "redraw");
		SetMessageTuple(hv_MessageHandle, "poses", hv_Poses);
		EnqueueMessage(HTuple(hv_MessageQueue[2]), hv_MessageHandle, HTuple(), HTuple());
		ClearMessage(hv_MessageHandle);
	}
	return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Set the value of a specified camera parameter in the camera parameter tuple. 
void set_cam_par_data(HTuple hv_CameraParamIn, HTuple hv_ParamName, HTuple hv_ParamValue,
	HTuple *hv_CameraParamOut)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Index, hv_ParamNameInd, hv_CameraParamNames;
	HTuple  hv_I, hv_CameraType, hv_IsTelecentric;

	//set_cam_par_data sets the value of the parameter that
	//is given in ParamName in the tuple of camera parameters
	//given in CameraParamIn. The modified camera parameters
	//are returned in CameraParamOut.
	//
	//Check for consistent length of input parameters
	if (0 != ((hv_ParamName.TupleLength()) != (hv_ParamValue.TupleLength())))
	{
		throw HException("Different number of values in ParamName and ParamValue");
	}
	//First, get the parameter names that correspond to the
	//elements in the input camera parameter tuple.
	get_cam_par_names(hv_CameraParamIn, &hv_CameraType, &hv_CameraParamNames);
	//
	//Find the index of the requested camera data and return
	//the corresponding value.
	(*hv_CameraParamOut) = hv_CameraParamIn;
	{
		HTuple end_val16 = (hv_ParamName.TupleLength()) - 1;
		HTuple step_val16 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val16, step_val16); hv_Index += step_val16)
		{
			hv_ParamNameInd = HTuple(hv_ParamName[hv_Index]);
			hv_I = hv_CameraParamNames.TupleFind(hv_ParamNameInd);
			if (0 != (hv_I != -1))
			{
				(*hv_CameraParamOut)[hv_I] = HTuple(hv_ParamValue[hv_Index]);
			}
			else
			{
				throw HException("Wrong ParamName " + hv_ParamNameInd);
			}
			//Check the consistency of focus and telecentricity
			if (0 != (hv_ParamNameInd == HTuple("focus")))
			{
				hv_IsTelecentric = HTuple((hv_CameraType.TupleStrstr("telecentric")) != -1).TupleAnd((hv_CameraType.TupleStrstr("image_side_telecentric")) == -1);
				if (0 != hv_IsTelecentric)
				{
					throw HException(HTuple("Focus for telecentric lenses is always 0, and hence, cannot be changed."));
				}
				if (0 != (HTuple(hv_IsTelecentric.TupleNot()).TupleAnd(HTuple(hv_ParamValue[hv_Index]) == 0.0)))
				{
					throw HException("Focus for non-telecentric lenses must not be 0.");
				}
			}
		}
	}
	return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold,
	HTuple hv_Slant)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_OS, hv_Fonts, hv_Style, hv_Exception;
	HTuple  hv_AvailableFonts, hv_Fdx, hv_Indices;

	//This procedure sets the text font of the current window with
	//the specified attributes.
	//
	//Input parameters:
	//WindowHandle: The graphics window for which the font will be set
	//Size: The font size. If Size=-1, the default of 16 is used.
	//Bold: If set to 'true', a bold font is used
	//Slant: If set to 'true', a slanted font is used
	//
	GetSystem("operating_system", &hv_OS);
	if (0 != (HTuple(hv_Size == HTuple()).TupleOr(hv_Size == -1)))
	{
		hv_Size = 16;
	}
	if (0 != ((hv_OS.TupleSubstr(0, 2)) == HTuple("Win")))
	{
		//Restore previous behaviour
		hv_Size = (1.13677*hv_Size).TupleInt();
	}
	else
	{
		hv_Size = hv_Size.TupleInt();
	}
	if (0 != (hv_Font == HTuple("Courier")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Courier";
		hv_Fonts[1] = "Courier 10 Pitch";
		hv_Fonts[2] = "Courier New";
		hv_Fonts[3] = "CourierNew";
		hv_Fonts[4] = "Liberation Mono";
	}
	else if (0 != (hv_Font == HTuple("mono")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Consolas";
		hv_Fonts[1] = "Menlo";
		hv_Fonts[2] = "Courier";
		hv_Fonts[3] = "Courier 10 Pitch";
		hv_Fonts[4] = "FreeMono";
		hv_Fonts[5] = "Liberation Mono";
	}
	else if (0 != (hv_Font == HTuple("sans")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Luxi Sans";
		hv_Fonts[1] = "DejaVu Sans";
		hv_Fonts[2] = "FreeSans";
		hv_Fonts[3] = "Arial";
		hv_Fonts[4] = "Liberation Sans";
	}
	else if (0 != (hv_Font == HTuple("serif")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Times New Roman";
		hv_Fonts[1] = "Luxi Serif";
		hv_Fonts[2] = "DejaVu Serif";
		hv_Fonts[3] = "FreeSerif";
		hv_Fonts[4] = "Utopia";
		hv_Fonts[5] = "Liberation Serif";
	}
	else
	{
		hv_Fonts = hv_Font;
	}
	hv_Style = "";
	if (0 != (hv_Bold == HTuple("true")))
	{
		hv_Style += HTuple("Bold");
	}
	else if (0 != (hv_Bold != HTuple("false")))
	{
		hv_Exception = "Wrong value of control parameter Bold";
		throw HException(hv_Exception);
	}
	if (0 != (hv_Slant == HTuple("true")))
	{
		hv_Style += HTuple("Italic");
	}
	else if (0 != (hv_Slant != HTuple("false")))
	{
		hv_Exception = "Wrong value of control parameter Slant";
		throw HException(hv_Exception);
	}
	if (0 != (hv_Style == HTuple("")))
	{
		hv_Style = "Normal";
	}
	QueryFont(hv_WindowHandle, &hv_AvailableFonts);
	hv_Font = "";
	{
		HTuple end_val48 = (hv_Fonts.TupleLength()) - 1;
		HTuple step_val48 = 1;
		for (hv_Fdx = 0; hv_Fdx.Continue(end_val48, step_val48); hv_Fdx += step_val48)
		{
			hv_Indices = hv_AvailableFonts.TupleFind(HTuple(hv_Fonts[hv_Fdx]));
			if (0 != ((hv_Indices.TupleLength())>0))
			{
				if (0 != (HTuple(hv_Indices[0]) >= 0))
				{
					hv_Font = HTuple(hv_Fonts[hv_Fdx]);
					break;
				}
			}
		}
	}
	if (0 != (hv_Font == HTuple("")))
	{
		throw HException("Wrong value of control parameter Font");
	}
	hv_Font = (((hv_Font + "-") + hv_Style) + "-") + hv_Size;
	SetFont(hv_WindowHandle, hv_Font);
	return;
}

void set_edge_parameter_sliders(HTuple hv_WindowHandle, HTuple hv_ObjectModel3D,
	HTuple hv_MesageQueues, HTuple hv_MessageQueueOut, HTuple hv_ModelDiameter, HTuple hv_AmplitudeRange,
	HTuple hv_MaxGapRange, HTuple hv_Viewpoint, HTuple *hv_MinAmplitude, HTuple *hv_MaxGap)
{

	// Local iconic variables
	HObject  ho_X, ho_Y, ho_Z, ho_ZZoomed, ho_XEdges;
	HObject  ho_YEdges, ho_ZEdges, ho_EdgesDomain, ho_EdgesDomainZoomed;

	// Local control variables
	HTuple  hv_ViewpointStr, hv_Row, hv_Column, hv_Width;
	HTuple  hv_Height, hv_WindowHandleBuffer, hv_SliderHeight;
	HTuple  hv_RowSlider1, hv_RowSlider2, hv_ColSliderLabel;
	HTuple  hv_ColSliderValue, hv_ColSliderStart, hv_ColSliderEnd;
	HTuple  hv_ImgWidth, hv_ImgHeight, hv_Factor, hv_CurrentSliderActive;
	HTuple  hv_ObjectModel3DEdges, hv_PoseEstimated, hv_MessageHandle;
	HTuple  hv_ValuesUpdated, hv_Slider, hv_MouseRow, hv_MouseColumn;
	HTuple  hv_UpdateSlider, hv_MouseButton, hv_ValueRel, hv_MessageType;
	HTuple  hv_Exception;

	(*hv_MaxGap) = ((const HTuple&)hv_MaxGapRange)[2];
	(*hv_MinAmplitude) = ((const HTuple&)hv_AmplitudeRange)[2];
	hv_ViewpointStr = (hv_Viewpoint + " ").TupleSum();

	//Open (invisible) buffer window to avoid flickering
	GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
	OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", &hv_WindowHandleBuffer);
	SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height - 1, hv_Width - 1);

	//Estimate a good visualization pose
	estimate_visualization_pose_simple(hv_ObjectModel3D, hv_WindowHandleBuffer, &hv_PoseEstimated);

	hv_SliderHeight = 25;
	hv_RowSlider1 = (hv_Height - 10) - (2 * hv_SliderHeight);
	hv_RowSlider2 = (hv_Height - 10) - (1 * hv_SliderHeight);
	hv_ColSliderLabel = 10;
	hv_ColSliderValue = hv_Width - 50;
	hv_ColSliderStart = hv_ColSliderLabel + 130;
	hv_ColSliderEnd = hv_ColSliderValue - 10;

	set_display_font(hv_WindowHandle, 12, "mono", "true", "false");
	set_display_font(hv_WindowHandleBuffer, 12, "mono", "true", "false");

	ObjectModel3dToXyz(&ho_X, &ho_Y, &ho_Z, hv_ObjectModel3D, "from_xyz_map", HTuple(),
		HTuple());
	GetImageSize(ho_X, &hv_ImgWidth, &hv_ImgHeight);
	hv_Factor = ((1.0*hv_Width) / hv_ImgWidth).TupleMin2((((1.0*hv_Height) - 10) - (2 * hv_SliderHeight)) / hv_ImgHeight);
	ZoomImageFactor(ho_Z, &ho_ZZoomed, hv_Factor, hv_Factor, "nearest_neighbor");
	DispObj(ho_ZZoomed, hv_WindowHandle);

	hv_CurrentSliderActive = HTuple();

	try
	{
		while (0 != 1)
		{
			EdgesObjectModel3d(hv_ObjectModel3D, (*hv_MinAmplitude)*hv_ModelDiameter, (HTuple("max_gap").Append("viewpoint")),
				(*hv_MaxGap).TupleConcat(hv_ViewpointStr), &hv_ObjectModel3DEdges);
			//
			//disp_object_model_3d (WindowHandleBuffer, ObjectModel3DEdges, [], PoseEstimated, 'color', 'blue')
			ClearWindow(hv_WindowHandleBuffer);
			DispObj(ho_ZZoomed, hv_WindowHandleBuffer);
			SetColor(hv_WindowHandleBuffer, "red");
			ObjectModel3dToXyz(&ho_XEdges, &ho_YEdges, &ho_ZEdges, hv_ObjectModel3DEdges,
				"from_xyz_map", HTuple(), HTuple());
			GetDomain(ho_ZEdges, &ho_EdgesDomain);
			ZoomRegion(ho_EdgesDomain, &ho_EdgesDomainZoomed, hv_Factor, hv_Factor);
			DilationCircle(ho_EdgesDomainZoomed, &ho_EdgesDomainZoomed, 1.5);
			DispObj(ho_EdgesDomainZoomed, hv_WindowHandleBuffer);
			//
			//Update the 3D object model with the edges in the 3D visualization window
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
			SetMessageTuple(hv_MessageHandle, "index", 1);
			SetMessageTuple(hv_MessageHandle, "model", hv_ObjectModel3DEdges);
			EnqueueMessage(HTuple(hv_MessageQueueOut[1]), hv_MessageHandle, HTuple(), HTuple());
			//
			disp_slider(hv_WindowHandleBuffer, hv_RowSlider1, hv_SliderHeight, hv_ColSliderLabel,
				hv_ColSliderValue, hv_ColSliderStart, hv_ColSliderEnd, "MinAmplitudeRel: ",
				HTuple(hv_AmplitudeRange[0]), HTuple(hv_AmplitudeRange[1]), (*hv_MinAmplitude),
				"2.3f");
			disp_slider(hv_WindowHandleBuffer, hv_RowSlider2, hv_SliderHeight, hv_ColSliderLabel,
				hv_ColSliderValue, hv_ColSliderStart, hv_ColSliderEnd, "MaxGap: ", HTuple(hv_MaxGapRange[0]),
				HTuple(hv_MaxGapRange[1]), (*hv_MaxGap), "d");
			//
			CopyRectangle(hv_WindowHandleBuffer, hv_WindowHandle, 0, 0, hv_Height - 1, hv_Width - 1,
				0, 0);
			//
			hv_ValuesUpdated = 0;
			while (0 != (hv_ValuesUpdated.TupleNot()))
			{
				get_mouse_info(hv_WindowHandle, hv_MesageQueues, 0.01, &hv_MouseRow, &hv_MouseColumn,
					&hv_MouseButton);
				//
				//Find the slider the mouse is in
				hv_Slider = HTuple();
				if (0 != (HTuple(HTuple(HTuple(hv_MouseRow>hv_RowSlider1).TupleAnd(hv_MouseRow<(hv_RowSlider1 + hv_SliderHeight))).TupleAnd(hv_MouseColumn >= hv_ColSliderStart)).TupleAnd(hv_MouseColumn <= hv_ColSliderEnd)))
				{
					hv_Slider = 1;
				}
				else if (0 != (HTuple(HTuple(HTuple(hv_MouseRow>hv_RowSlider2).TupleAnd(hv_MouseRow<(hv_RowSlider2 + hv_SliderHeight))).TupleAnd(hv_MouseColumn >= hv_ColSliderStart)).TupleAnd(hv_MouseColumn <= hv_ColSliderEnd)))
				{
					hv_Slider = 2;
				}
				//
				hv_UpdateSlider = 0;
				if (0 != (hv_MouseButton == 1))
				{
					if (0 != (hv_CurrentSliderActive == HTuple()))
					{
						if (0 != (hv_Slider != HTuple()))
						{
							//Clicked into a slider -> start sliding
							hv_CurrentSliderActive = hv_Slider;
							hv_UpdateSlider = 1;
						}
					}
					else
					{
						//Continue sliding the current slider
						hv_UpdateSlider = 1;
					}
				}
				else if (0 != (hv_MouseButton == 0))
				{
					if (0 != (hv_CurrentSliderActive != HTuple()))
					{
						//mouse button released -> stop sliding
						hv_CurrentSliderActive = HTuple();
					}
				}
				//
				if (0 != hv_UpdateSlider)
				{
					hv_ValueRel = (hv_MouseColumn - hv_ColSliderStart) / (hv_ColSliderEnd - hv_ColSliderStart);
					if (0 != (hv_ValueRel<0))
					{
						hv_ValueRel = 0;
					}
					else if (0 != (hv_ValueRel>1))
					{
						hv_ValueRel = 1;
					}

					if (0 != (1 == hv_CurrentSliderActive))
					{
						(*hv_MinAmplitude) = HTuple(hv_AmplitudeRange[0]) + (hv_ValueRel*(HTuple(hv_AmplitudeRange[1]) - HTuple(hv_AmplitudeRange[0])));
					}
					else if (0 != (2 == hv_CurrentSliderActive))
					{
						(*hv_MaxGap) = (HTuple(hv_MaxGapRange[0]) + (hv_ValueRel*(HTuple(hv_MaxGapRange[1]) - HTuple(hv_MaxGapRange[0])))).TupleInt();
						//rounding might push it out of range
						if (0 != ((*hv_MaxGap)<HTuple(hv_MaxGapRange[0])))
						{
							(*hv_MaxGap) = ((const HTuple&)hv_MaxGapRange)[0];
						}
						else if (0 != ((*hv_MaxGap)>HTuple(hv_MaxGapRange[1])))
						{
							(*hv_MaxGap) = ((const HTuple&)hv_MaxGapRange)[1];
						}
					}
					hv_ValuesUpdated = 1;
				}
				//
				try
				{
					DequeueMessage(HTuple(hv_MesageQueues[1]), "timeout", 0, &hv_MessageHandle);
					GetMessageTuple(hv_MessageHandle, "type", &hv_MessageType);
					if (0 != (hv_MessageType == HTuple("exit")))
					{
						return;
					}
					else
					{
						throw HException((HTuple("Unknown message type").TupleConcat(hv_MessageType)).TupleConcat(hv_MessageHandle));
					}
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					if (0 != (HTuple(hv_Exception[0]) != 9400))
					{
						//Ignore timeout (no message in queue)
						throw HException(hv_Exception);
					}
				}
			}
		}
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		if (0 != (HTuple(HTuple(hv_Exception[0]) == 2454).TupleOr(HTuple(hv_Exception[0]) == 5100)))
		{
			//Handle was already cleared -> indicates that the window was closed (by the user)
			//Abort gracefully.
			return;
		}
		else
		{
			//Unknown / Unexpected exception
			throw HException(hv_Exception);
		}
	}

	return;
}

// Chapter: Graphics / Output
// Short Description: Compute the 3D rotation from the mouse movement 
void trackball(HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2, HTuple hv_MY2, HTuple hv_VirtualTrackball,
	HTuple hv_TrackballSize, HTuple hv_SensFactor, HTuple *hv_QuatRotation)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_P1, hv_P2, hv_RotAxis, hv_D, hv_T;
	HTuple  hv_RotAngle, hv_Len;

	//Compute the 3D rotation from the mouse movement
	//
	if (0 != (HTuple(hv_MX1 == hv_MX2).TupleAnd(hv_MY1 == hv_MY2)))
	{
		(*hv_QuatRotation).Clear();
		(*hv_QuatRotation)[0] = 1;
		(*hv_QuatRotation)[1] = 0;
		(*hv_QuatRotation)[2] = 0;
		(*hv_QuatRotation)[3] = 0;
		return;
	}
	//Project the image point onto the trackball
	project_point_on_trackball(hv_MX1, hv_MY1, hv_VirtualTrackball, hv_TrackballSize,
		&hv_P1);
	project_point_on_trackball(hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize,
		&hv_P2);
	//The cross product of the projected points defines the rotation axis
	tuple_vector_cross_product(hv_P1, hv_P2, &hv_RotAxis);
	//Compute the rotation angle
	hv_D = hv_P2 - hv_P1;
	hv_T = (((hv_D*hv_D).TupleSum()).TupleSqrt()) / (2.0*hv_TrackballSize);
	if (0 != (hv_T>1.0))
	{
		hv_T = 1.0;
	}
	if (0 != (hv_T<-1.0))
	{
		hv_T = -1.0;
	}
	hv_RotAngle = (2.0*(hv_T.TupleAsin()))*hv_SensFactor;
	hv_Len = ((hv_RotAxis*hv_RotAxis).TupleSum()).TupleSqrt();
	if (0 != (hv_Len>0.0))
	{
		hv_RotAxis = hv_RotAxis / hv_Len;
	}
	AxisAngleToQuat(HTuple(hv_RotAxis[0]), HTuple(hv_RotAxis[1]), HTuple(hv_RotAxis[2]),
		hv_RotAngle, &(*hv_QuatRotation));
	return;
}

// Chapter: Graphics / Output
// Short Description: Compute the 3D rotation from the mouse movement 
void trackball_visualize_object_model_3d(HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2,
	HTuple hv_MY2, HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SensFactor,
	HTuple *hv_QuatRotation)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_P1, hv_P2, hv_RotAxis, hv_D, hv_T;
	HTuple  hv_RotAngle, hv_Len;

	//Compute the 3D rotation from the mouse movement
	//
	if (0 != (HTuple(hv_MX1 == hv_MX2).TupleAnd(hv_MY1 == hv_MY2)))
	{
		(*hv_QuatRotation).Clear();
		(*hv_QuatRotation)[0] = 1;
		(*hv_QuatRotation)[1] = 0;
		(*hv_QuatRotation)[2] = 0;
		(*hv_QuatRotation)[3] = 0;
		return;
	}
	//Project the image point onto the trackball
	project_point_on_trackball_visualize_object_model_3d(hv_MX1, hv_MY1, hv_VirtualTrackball,
		hv_TrackballSize, &hv_P1);
	project_point_on_trackball_visualize_object_model_3d(hv_MX2, hv_MY2, hv_VirtualTrackball,
		hv_TrackballSize, &hv_P2);
	//The cross product of the projected points defines the rotation axis
	tuple_vector_cross_product_visualize_object_model_3d(hv_P1, hv_P2, &hv_RotAxis);
	//Compute the rotation angle
	hv_D = hv_P2 - hv_P1;
	hv_T = (((hv_D*hv_D).TupleSum()).TupleSqrt()) / (2.0*hv_TrackballSize);
	if (0 != (hv_T>1.0))
	{
		hv_T = 1.0;
	}
	if (0 != (hv_T<-1.0))
	{
		hv_T = -1.0;
	}
	hv_RotAngle = (2.0*(hv_T.TupleAsin()))*hv_SensFactor;
	hv_Len = ((hv_RotAxis*hv_RotAxis).TupleSum()).TupleSqrt();
	if (0 != (hv_Len>0.0))
	{
		hv_RotAxis = hv_RotAxis / hv_Len;
	}
	AxisAngleToQuat(HTuple(hv_RotAxis[0]), HTuple(hv_RotAxis[1]), HTuple(hv_RotAxis[2]),
		hv_RotAngle, &(*hv_QuatRotation));
	return;
}

// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product(HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC)
{

	// Local iconic variables

	//The caller must ensure that the length of both input vectors is 3
	(*hv_VC) = (HTuple(hv_V1[1])*HTuple(hv_V2[2])) - (HTuple(hv_V1[2])*HTuple(hv_V2[1]));
	(*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[2])*HTuple(hv_V2[0])) - (HTuple(hv_V1[0])*HTuple(hv_V2[2])));
	(*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[0])*HTuple(hv_V2[1])) - (HTuple(hv_V1[1])*HTuple(hv_V2[0])));
	return;
}

// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product_visualize_object_model_3d(HTuple hv_V1, HTuple hv_V2,
	HTuple *hv_VC)
{

	// Local iconic variables

	//The caller must ensure that the length of both input vectors is 3
	(*hv_VC) = (HTuple(hv_V1[1])*HTuple(hv_V2[2])) - (HTuple(hv_V1[2])*HTuple(hv_V2[1]));
	(*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[2])*HTuple(hv_V2[0])) - (HTuple(hv_V1[0])*HTuple(hv_V2[2])));
	(*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[0])*HTuple(hv_V2[1])) - (HTuple(hv_V1[1])*HTuple(hv_V2[0])));
	return;
}

// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d(HTuple hv_WindowHandle, HTuple hv_ObjectModel3D,
	HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue,
	HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple *hv_PoseOut)
{

	// Local iconic variables
	HObject  ho_Image, ho_ImageDump;

	// Local control variables
	HTuple  ExpTmpLocalVar_gDispObjOffset, ExpTmpLocalVar_gLabelsDecor;
	HTuple  ExpTmpLocalVar_gInfoDecor, ExpTmpLocalVar_gInfoPos;
	HTuple  ExpTmpLocalVar_gTitlePos, ExpTmpLocalVar_gTitleDecor;
	HTuple  ExpTmpLocalVar_gTerminationButtonLabel, ExpTmpLocalVar_gAlphaDeselected;
	HTuple  ExpTmpLocalVar_gIsSinglePose, ExpTmpLocalVar_gUsesOpenGL;
	HTuple  hv_Scene3DTest, hv_Scene3D, hv_WindowHandleBuffer;
	HTuple  hv_TrackballSize, hv_VirtualTrackball, hv_MouseMapping;
	HTuple  hv_WaitForButtonRelease, hv_MaxNumModels, hv_WindowCenteredRotation;
	HTuple  hv_NumModels, hv_SelectedObject, hv_ClipRegion;
	HTuple  hv_CPLength, hv_RowNotUsed, hv_ColumnNotUsed, hv_Width;
	HTuple  hv_Height, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2;
	HTuple  hv_CamParamValue, hv_CamWidth, hv_CamHeight, hv_Scale;
	HTuple  hv_Indices, hv_DispBackground, hv_Mask, hv_Center;
	HTuple  hv_Poses, hv_HomMat3Ds, hv_Sequence, hv_PoseEstimated;
	HTuple  hv_Font, hv_Exception, hv_OpenGLInfo, hv_DummyObjectModel3D;
	HTuple  hv_CameraIndexTest, hv_PoseTest, hv_InstanceIndexTest;
	HTuple  hv_MinImageSize, hv_TrackballRadiusPixel, hv_Ascent;
	HTuple  hv_Descent, hv_TextWidth, hv_TextHeight, hv_NumChannels;
	HTuple  hv_ColorImage, hv_CameraIndex, hv_AllInstances;
	HTuple  hv_SetLight, hv_LightParam, hv_LightPosition, hv_LightKind;
	HTuple  hv_LightIndex, hv_PersistenceParamName, hv_PersistenceParamValue;
	HTuple  hv_AlphaOrig, hv_I, hv_ParamName, hv_ParamValue;
	HTuple  hv_ParamNameTrunk, hv_Instance, hv_HomMat3D, hv_Qx;
	HTuple  hv_Qy, hv_Qz, hv_TBCenter, hv_TBSize, hv_ButtonHold;
	HTuple  hv_VisualizeTB, hv_MaxIndex, hv_TrackballCenterRow;
	HTuple  hv_TrackballCenterCol, hv_GraphEvent, hv_Exit, hv_GraphButtonRow;
	HTuple  hv_GraphButtonColumn, hv_GraphButton, hv_ButtonReleased;
	HTuple  hv_e;

	//The procedure visualize_object_model_3d can be used to display
	//one or more 3d object models and to interactively modify
	//the object poses by using the mouse.
	//
	//The pose can be modified by moving the mouse while
	//pressing a mouse button. The default settings are:
	//
	// Rotate: Left mouse button
	// Zoom: Shift + Left mouse button (or Center mouse button)
	// Pan: Ctrl + Left mouse button
	//
	//Furthermore, it is possible to select and deselect objects,
	//to decrease the mouse sensitivity, and to toggle the
	//inspection mode (see the description of the generic parameter
	//'inspection_mode' below):
	//
	// (De-)select object(s): Right mouse button
	// Low mouse sensitivity: Alt + Mouse button
	// Toggle inspection mode: Ctrl + Alt + Left mouse button
	//
	//In GenParamName and GenParamValue all generic Parameters
	//of disp_object_model_3d are supported.
	//
	//**********************************************************
	//Define global variables
	//**********************************************************
	//
	//global def tuple gDispObjOffset
	//global def tuple gLabelsDecor
	//global def tuple gInfoDecor
	//global def tuple gInfoPos
	//global def tuple gTitlePos
	//global def tuple gTitleDecor
	//global def tuple gTerminationButtonLabel
	//global def tuple gAlphaDeselected
	//global def tuple gIsSinglePose
	//global def tuple gUsesOpenGL
	//
	//**********************************************************
	//Initialize Handles to enable correct handling in error case
	//**********************************************************
	hv_Scene3DTest = HTuple();
	hv_Scene3D = HTuple();
	hv_WindowHandleBuffer = HTuple();

	//**********************************************************
	//Some user defines that may be adapted if desired
	//**********************************************************
	//
	//TrackballSize defines the diameter of the trackball in
	//the image with respect to the smaller image dimension.
	hv_TrackballSize = 0.8;
	//
	//VirtualTrackball defines the type of virtual trackball that
	//shall be used ('shoemake' or 'bell').
	hv_VirtualTrackball = "shoemake";
	//VirtualTrackball := 'bell'
	//
	//Functionality of mouse buttons
	//    1: Left Button
	//    2: Middle Button
	//    4: Right Button
	//    5: Left+Right Mousebutton
	//  8+x: Shift + Mousebutton
	// 16+x: Ctrl + Mousebutton
	// 48+x: Ctrl + Alt + Mousebutton
	//in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]
	hv_MouseMapping.Clear();
	hv_MouseMapping[0] = 17;
	hv_MouseMapping[1] = 1;
	hv_MouseMapping[2] = 2;
	hv_MouseMapping[3] = 5;
	hv_MouseMapping[4] = 9;
	hv_MouseMapping[5] = 4;
	hv_MouseMapping[6] = 49;
	//
	//The labels of the objects appear next to their projected
	//center. With gDispObjOffset a fixed offset is added
	//                  R,  C
	ExpTmpLocalVar_gDispObjOffset.Clear();
	ExpTmpLocalVar_gDispObjOffset[0] = -30;
	ExpTmpLocalVar_gDispObjOffset[1] = 0;
	ExpSetGlobalVar_gDispObjOffset(ExpTmpLocalVar_gDispObjOffset);
	//
	//Customize the decoration of the different text elements
	//              Color,   Box
	ExpTmpLocalVar_gInfoDecor.Clear();
	ExpTmpLocalVar_gInfoDecor[0] = "white";
	ExpTmpLocalVar_gInfoDecor[1] = "false";
	ExpSetGlobalVar_gInfoDecor(ExpTmpLocalVar_gInfoDecor);
	ExpTmpLocalVar_gLabelsDecor.Clear();
	ExpTmpLocalVar_gLabelsDecor[0] = "white";
	ExpTmpLocalVar_gLabelsDecor[1] = "false";
	ExpSetGlobalVar_gLabelsDecor(ExpTmpLocalVar_gLabelsDecor);
	ExpTmpLocalVar_gTitleDecor.Clear();
	ExpTmpLocalVar_gTitleDecor[0] = "black";
	ExpTmpLocalVar_gTitleDecor[1] = "true";
	ExpSetGlobalVar_gTitleDecor(ExpTmpLocalVar_gTitleDecor);
	//
	//Customize the position of some text elements
	//  gInfoPos has one of the values
	//  {'UpperLeft', 'LowerLeft', 'UpperRight'}
	ExpTmpLocalVar_gInfoPos = "LowerLeft";
	ExpSetGlobalVar_gInfoPos(ExpTmpLocalVar_gInfoPos);
	//  gTitlePos has one of the values
	//  {'UpperLeft', 'UpperCenter', 'UpperRight'}
	ExpTmpLocalVar_gTitlePos = "UpperLeft";
	ExpSetGlobalVar_gTitlePos(ExpTmpLocalVar_gTitlePos);
	//Alpha value (=1-transparency) that is used for visualizing
	//the objects that are not selected
	ExpTmpLocalVar_gAlphaDeselected = 0.3;
	ExpSetGlobalVar_gAlphaDeselected(ExpTmpLocalVar_gAlphaDeselected);
	//Customize the label of the continue button
	ExpTmpLocalVar_gTerminationButtonLabel = " Continue ";
	ExpSetGlobalVar_gTerminationButtonLabel(ExpTmpLocalVar_gTerminationButtonLabel);
	//Define if the continue button responds to a single click event or
	//if it responds only if the mouse button is released while being placed
	//over the continue button.
	//'true':  Wait until the continue button has been released.
	//         This should be used to avoid unwanted continuations of
	//         subsequent calls of visualize_object_model_3d, which can
	//         otherwise occur if the mouse button remains pressed while the
	//         next visualization is active.
	//'false': Continue the execution already if the continue button is
	//         pressed. This option allows a fast forwarding through
	//         subsequent calls of visualize_object_model_3d.
	hv_WaitForButtonRelease = "true";
	//Number of 3D Object models that can be selected and handled individually.
	//If there are more models passed then this number, some calculations
	//are performed differently and the individual selection and handling
	//of models is not supported anymore. Note that the value of MaxNumModels
	//can be overwritten with the generic parameter max_num_selectable_models.
	hv_MaxNumModels = 1000;
	//Defines the default for the initial state of the rotation center:
	//(1) The rotation center is fixed in the center of the image and lies
	//    on the surface of the object.
	//(2) The rotation center lies in the center of the object.
	hv_WindowCenteredRotation = 2;
	//
	//**********************************************************
	//
	//Initialize some values
	hv_NumModels = hv_ObjectModel3D.TupleLength();
	hv_SelectedObject = HTuple(hv_NumModels, 1);
	//
	//Apply some system settings
	// dev_set_preferences(...); only in hdevelop
	// dev_get_preferences(...); only in hdevelop
	// dev_set_preferences(...); only in hdevelop
	GetSystem("clip_region", &hv_ClipRegion);
	SetSystem("clip_region", "false");
	dev_update_off();
	//
	//Check if GenParamName matches GenParamValue
	if (0 != ((hv_GenParamName.TupleLength()) != (hv_GenParamValue.TupleLength())))
	{
		throw HException("Number of generic parameters does not match number of generic parameter values");
	}
	//
	try
	{
		//
		//Refactor camera parameters to fit to window size
		//
		hv_CPLength = hv_CamParam.TupleLength();
		GetWindowExtents(hv_WindowHandle, &hv_RowNotUsed, &hv_ColumnNotUsed, &hv_Width,
			&hv_Height);
		GetPart(hv_WindowHandle, &hv_WPRow1, &hv_WPColumn1, &hv_WPRow2, &hv_WPColumn2);
		SetPart(hv_WindowHandle, 0, 0, hv_Height - 1, hv_Width - 1);
		if (0 != (hv_CPLength == 0))
		{
			gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width / 2, hv_Height / 2,
				hv_Width, hv_Height, &hv_CamParam);
		}
		else
		{
			get_cam_par_data(hv_CamParam, (((((HTuple("sx").Append("sy")).Append("cx")).Append("cy")).Append("image_width")).Append("image_height")),
				&hv_CamParamValue);
			hv_CamWidth = HTuple(hv_CamParamValue[4]).TupleReal();
			hv_CamHeight = HTuple(hv_CamParamValue[5]).TupleReal();
			hv_Scale = ((hv_Width / hv_CamWidth).TupleConcat(hv_Height / hv_CamHeight)).TupleMin();
			set_cam_par_data(hv_CamParam, "sx", HTuple(hv_CamParamValue[0]) / hv_Scale, &hv_CamParam);
			set_cam_par_data(hv_CamParam, "sy", HTuple(hv_CamParamValue[1]) / hv_Scale, &hv_CamParam);
			set_cam_par_data(hv_CamParam, "cx", HTuple(hv_CamParamValue[2])*hv_Scale, &hv_CamParam);
			set_cam_par_data(hv_CamParam, "cy", HTuple(hv_CamParamValue[3])*hv_Scale, &hv_CamParam);
			set_cam_par_data(hv_CamParam, "image_width", (HTuple(hv_CamParamValue[4])*hv_Scale).TupleInt(),
				&hv_CamParam);
			set_cam_par_data(hv_CamParam, "image_height", (HTuple(hv_CamParamValue[5])*hv_Scale).TupleInt(),
				&hv_CamParam);
		}
		//
		//Check the generic parameters for max_num_selectable_models
		//(Note that the default is set above to MaxNumModels := 1000)
		hv_Indices = hv_GenParamName.TupleFind("max_num_selectable_models");
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleIsNumber()))
			{
				if (0 != (((HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleNumber()).TupleInt())<1))
				{
					//Wrong parameter value: Only integer values greater than 0 are allowed
					throw HException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
				}
			}
			else
			{
				//Wrong parameter value: Only integer values greater than 0 are allowed
				throw HException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
			}
			hv_MaxNumModels = (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleNumber()).TupleInt();
			hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
			hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
		}
		//
		//Check the generic parameters for window_centered_rotation
		//(Note that the default is set above to WindowCenteredRotation := 2)
		hv_Indices = hv_GenParamName.TupleFind("inspection_mode");
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]) == HTuple("surface")))
			{
				hv_WindowCenteredRotation = 1;
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]) == HTuple("standard")))
			{
				hv_WindowCenteredRotation = 2;
			}
			else
			{
				//Wrong parameter value, use default value
			}
			hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
			hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
		}
		//
		//Check the generic parameters for disp_background
		//(The former parameter name 'use_background' is still supported
		// for compatibility reasons)
		hv_DispBackground = "false";
		if (0 != ((hv_GenParamName.TupleLength())>0))
		{
			hv_Mask = (hv_GenParamName.TupleEqualElem("disp_background")).TupleOr(hv_GenParamName.TupleEqualElem("use_background"));
			hv_Indices = hv_Mask.TupleFind(1);
		}
		else
		{
			hv_Indices = -1;
		}
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			hv_DispBackground = HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]);
			if (0 != (HTuple(hv_DispBackground != HTuple("true")).TupleAnd(hv_DispBackground != HTuple("false"))))
			{
				//Wrong parameter value: Only 'true' and 'false' are allowed
				throw HException("Wrong value for parameter 'disp_background' (must be either 'true' or 'false')");
			}
			//Note the the background is handled explicitly in this procedure
			//and therefore, the parameter is removed from the list of
			//parameters and disp_background is always set to true (see below)
			hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
			hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
		}
		//
		//Read and check the parameter Label for each object
		if (0 != ((hv_Label.TupleLength()) == 0))
		{
			hv_Label = 0;
		}
		else if (0 != ((hv_Label.TupleLength()) == 1))
		{
			hv_Label = HTuple(hv_NumModels, hv_Label);
		}
		else
		{
			if (0 != ((hv_Label.TupleLength()) != hv_NumModels))
			{
				//Number of elements in Label does not match
				//the number of object models.
				throw HException(((HTuple(HTuple("Number of elements in Label (") + (hv_Label.TupleLength())) + ") does not match the number of object models(") + hv_NumModels) + ").");
			}
		}
		//
		//Read and check the parameter PoseIn for each object
		get_object_models_center_visualize_object_model_3d(hv_ObjectModel3D, &hv_Center);
		if (0 != ((hv_PoseIn.TupleLength()) == 0))
		{
			//If no pose was specified by the caller, automatically calculate
			//a pose that is appropriate for the visualization.
			//Set the initial model reference pose. The orientation is parallel
			//to the object coordinate system, the position is at the center
			//of gravity of all models.
			CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]),
				0, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
			determine_optimum_pose_distance_visualize_object_model_3d(hv_ObjectModel3D,
				hv_CamParam, 0.9, hv_PoseIn, &hv_PoseEstimated);
			hv_Poses = HTuple();
			hv_HomMat3Ds = HTuple();
			hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
			hv_Poses = HTuple(hv_PoseEstimated[hv_Sequence % 7]);
			ExpTmpLocalVar_gIsSinglePose = 1;
			ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
		}
		else if (0 != ((hv_PoseIn.TupleLength()) == 7))
		{
			hv_Poses = HTuple();
			hv_HomMat3Ds = HTuple();
			hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
			hv_Poses = HTuple(hv_PoseIn[hv_Sequence % 7]);
			ExpTmpLocalVar_gIsSinglePose = 1;
			ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
		}
		else
		{
			if (0 != ((hv_PoseIn.TupleLength()) != ((hv_ObjectModel3D.TupleLength()) * 7)))
			{
				//Wrong number of values of input control parameter 'PoseIn'
				throw HException("Wrong number of values of input control parameter 'PoseIn'.");
			}
			else
			{
				hv_Poses = hv_PoseIn;
			}
			ExpTmpLocalVar_gIsSinglePose = 0;
			ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
		}

		//
		//Open (invisible) buffer window to avoid flickering
		OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", &hv_WindowHandleBuffer);
		SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height - 1, hv_Width - 1);
		GetFont(hv_WindowHandle, &hv_Font);
		try
		{
			SetFont(hv_WindowHandleBuffer, hv_Font);
		}
		// catch (Exception) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception);
		}
		//
		// Is OpenGL available and should it be used?
		ExpTmpLocalVar_gUsesOpenGL = "true";
		ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
		hv_Indices = hv_GenParamName.TupleFind("opengl");
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			ExpTmpLocalVar_gUsesOpenGL = HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]);
			ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
			hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
			hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
			if (0 != (HTuple(ExpGetGlobalVar_gUsesOpenGL() != HTuple("true")).TupleAnd(ExpGetGlobalVar_gUsesOpenGL() != HTuple("false"))))
			{
				//Wrong parameter value: Only 'true' and 'false' are allowed
				throw HException("Wrong value for parameter 'opengl' (must be either 'true' or 'false')");
			}
		}
		if (0 != (ExpGetGlobalVar_gUsesOpenGL() == HTuple("true")))
		{
			GetSystem("opengl_info", &hv_OpenGLInfo);
			if (0 != (hv_OpenGLInfo == HTuple("No OpenGL support included.")))
			{
				ExpTmpLocalVar_gUsesOpenGL = "false";
				ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
			}
			else
			{
				GenObjectModel3dFromPoints(0, 0, 0, &hv_DummyObjectModel3D);
				CreateScene3d(&hv_Scene3DTest);
				AddScene3dCamera(hv_Scene3DTest, hv_CamParam, &hv_CameraIndexTest);
				determine_optimum_pose_distance_visualize_object_model_3d(hv_DummyObjectModel3D,
					hv_CamParam, 0.9, ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)),
					&hv_PoseTest);
				AddScene3dInstance(hv_Scene3DTest, hv_DummyObjectModel3D, hv_PoseTest, &hv_InstanceIndexTest);
				try
				{
					DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3DTest, hv_InstanceIndexTest);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					ExpTmpLocalVar_gUsesOpenGL = "false";
					ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
				}
				ClearScene3d(hv_Scene3DTest);
				hv_Scene3DTest = HTuple();
				ClearObjectModel3d(hv_DummyObjectModel3D);
			}
		}
		//
		//Compute the trackball
		hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
		hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize) / 2.0;
		//
		//Measure the text extents for the continue button in the
		//graphics window
		GetStringExtents(hv_WindowHandleBuffer, ExpGetGlobalVar_gTerminationButtonLabel() + "  ",
			&hv_Ascent, &hv_Descent, &hv_TextWidth, &hv_TextHeight);
		//
		//Store background image
		if (0 != (hv_DispBackground == HTuple("false")))
		{
			ClearWindow(hv_WindowHandle);
		}
		DumpWindowImage(&ho_Image, hv_WindowHandle);
		//Special treatment for color background images necessary
		CountChannels(ho_Image, &hv_NumChannels);
		hv_ColorImage = hv_NumChannels == 3;
		//
		CreateScene3d(&hv_Scene3D);
		AddScene3dCamera(hv_Scene3D, hv_CamParam, &hv_CameraIndex);
		AddScene3dInstance(hv_Scene3D, hv_ObjectModel3D, hv_Poses, &hv_AllInstances);
		//Always set 'disp_background' to true,  because it is handled explicitly
		//in this procedure (see above)
		SetScene3dParam(hv_Scene3D, "disp_background", "true");
		//Check if we have to set light specific parameters
		hv_SetLight = hv_GenParamName.TupleRegexpTest("light_");
		if (0 != hv_SetLight)
		{
			//set position of light source
			hv_Indices = hv_GenParamName.TupleFind("light_position");
			if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
			{
				//If multiple light positions are given, use the last one
				hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]).TupleSplit(HTuple(", "))).TupleNumber();
				if (0 != ((hv_LightParam.TupleLength()) != 4))
				{
					throw HException("light_position must be given as a string that contains four space separated floating point numbers");
				}
				hv_LightPosition = hv_LightParam.TupleSelectRange(0, 2);
				hv_LightKind = "point_light";
				if (0 != (HTuple(hv_LightParam[3]) == 0))
				{
					hv_LightKind = "directional_light";
				}
				//Currently, only one light source is supported
				RemoveScene3dLight(hv_Scene3D, 0);
				AddScene3dLight(hv_Scene3D, hv_LightPosition, hv_LightKind, &hv_LightIndex);
				TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
				TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
			}
			//set ambient part of light source
			hv_Indices = hv_GenParamName.TupleFind("light_ambient");
			if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
			{
				//If the ambient part is set multiple times, use the last setting
				hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]).TupleSplit(HTuple(", "))).TupleNumber();
				if (0 != ((hv_LightParam.TupleLength())<3))
				{
					throw HException("light_ambient must be given as a string that contains three space separated floating point numbers");
				}
				SetScene3dLightParam(hv_Scene3D, 0, "ambient", hv_LightParam.TupleSelectRange(0, 2));
				TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
				TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
			}
			//Set diffuse part of light source
			hv_Indices = hv_GenParamName.TupleFind("light_diffuse");
			if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
			{
				//If the diffuse part is set multiple times, use the last setting
				hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]).TupleSplit(HTuple(", "))).TupleNumber();
				if (0 != ((hv_LightParam.TupleLength())<3))
				{
					throw HException("light_diffuse must be given as a string that contains three space separated floating point numbers");
				}
				SetScene3dLightParam(hv_Scene3D, 0, "diffuse", hv_LightParam.TupleSelectRange(0, 2));
				TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
				TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
			}
		}
		//
		//Handle persistence parameters separately because persistence will
		//only be activated immediately before leaving the visualization
		//procedure
		hv_PersistenceParamName = HTuple();
		hv_PersistenceParamValue = HTuple();
		//Set position of light source
		hv_Indices = hv_GenParamName.TupleFind("object_index_persistence");
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("true")))
			{
				hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("object_index_persistence");
				hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("false")))
			{
			}
			else
			{
				throw HException("Wrong value for parameter 'object_index_persistence' (must be either 'true' or 'false')");
			}
			TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
			TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
		}
		hv_Indices = hv_GenParamName.TupleFind("depth_persistence");
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("true")))
			{
				hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("depth_persistence");
				hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("false")))
			{
			}
			else
			{
				throw HException("Wrong value for parameter 'depth_persistence' (must be either 'true' or 'false')");
			}
			TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
			TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
		}
		//
		//Parse the generic parameters
		//- First, all parameters that are understood by set_scene_3d_instance_param
		hv_AlphaOrig = HTuple(hv_NumModels, 1);
		{
			HTuple end_val406 = (hv_GenParamName.TupleLength()) - 1;
			HTuple step_val406 = 1;
			for (hv_I = 0; hv_I.Continue(end_val406, step_val406); hv_I += step_val406)
			{
				hv_ParamName = HTuple(hv_GenParamName[hv_I]);
				hv_ParamValue = HTuple(hv_GenParamValue[hv_I]);
				//Check if this parameter is understood by set_scene_3d_param
				if (0 != (hv_ParamName == HTuple("alpha")))
				{
					hv_AlphaOrig = HTuple(hv_NumModels, hv_ParamValue);
				}
				try
				{
					SetScene3dParam(hv_Scene3D, hv_ParamName, hv_ParamValue);
					continue;
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					if (0 != (HTuple(HTuple(hv_Exception[0]) == 1203).TupleOr(HTuple(hv_Exception[0]) == 1303)))
					{
						throw HException((("Wrong type or value for parameter " + hv_ParamName) + ": ") + hv_ParamValue);
					}
				}
				//Check if it is a parameter that is valid for only one instance
				//and therefore can be set only with set_scene_3d_instance_param
				hv_ParamNameTrunk = hv_ParamName.TupleRegexpReplace("_\\d+$", "");
				if (0 != (hv_ParamName == hv_ParamNameTrunk))
				{
					hv_Instance = HTuple::TupleGenSequence(0, hv_NumModels - 1, 1);
				}
				else
				{
					hv_Instance = (hv_ParamName.TupleRegexpReplace(("^" + hv_ParamNameTrunk) + "_(\\d+)$", "$1")).TupleNumber();
					if (0 != (HTuple(hv_Instance<0).TupleOr(hv_Instance>(hv_NumModels - 1))))
					{
						throw HException(("Parameter " + hv_ParamName) + " refers to a non existing 3D object model");
					}
				}
				try
				{
					SetScene3dInstanceParam(hv_Scene3D, hv_Instance, hv_ParamNameTrunk, hv_ParamValue);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					if (0 != (HTuple(HTuple(hv_Exception[0]) == 1204).TupleOr(HTuple(hv_Exception[0]) == 1304)))
					{
						throw HException((("Wrong type or value for parameter " + hv_ParamName) + ": ") + hv_ParamValue);
					}
					else if (0 != (HTuple(HTuple(hv_Exception[0]) == 1203).TupleOr(HTuple(hv_Exception[0]) == 1303)))
					{
						throw HException("Wrong parameter name " + hv_ParamName);
					}
					else
					{
						throw HException(hv_Exception);
					}
				}
				if (0 != (hv_ParamNameTrunk == HTuple("alpha")))
				{
					hv_AlphaOrig[hv_Instance] = hv_ParamValue;
				}
			}
		}
		//
		//Start the visualization loop
		PoseToHomMat3d(hv_Poses.TupleSelectRange(0, 6), &hv_HomMat3D);
		AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]), HTuple(hv_Center[2]),
			&hv_Qx, &hv_Qy, &hv_Qz);
		hv_TBCenter.Clear();
		hv_TBCenter.Append(hv_Qx);
		hv_TBCenter.Append(hv_Qy);
		hv_TBCenter.Append(hv_Qz);
		hv_TBSize = (0.5 + ((0.5*(hv_SelectedObject.TupleSum())) / hv_NumModels))*hv_TrackballRadiusPixel;
		hv_ButtonHold = 0;
		while (0 != 1)
		{
			hv_VisualizeTB = (hv_SelectedObject.TupleMax()) != 0;
			hv_MaxIndex = ((HTuple(hv_ObjectModel3D.TupleLength()).TupleConcat(hv_MaxNumModels)).TupleMin()) - 1;
			//Set trackball fixed in the center of the window
			hv_TrackballCenterRow = hv_Height / 2;
			hv_TrackballCenterCol = hv_Width / 2;
			if (0 != (hv_WindowCenteredRotation == 1))
			{
				try
				{
					get_trackball_center_fixed_visualize_object_model_3d(hv_SelectedObject.TupleSelectRange(0, hv_MaxIndex),
						hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel,
						hv_Scene3D, hv_ObjectModel3D.TupleSelectRange(0, hv_MaxIndex), hv_Poses.TupleSelectRange(0, ((hv_MaxIndex + 1) * 7) - 1),
						hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, hv_GenParamValue,
						&hv_TBCenter, &hv_TBSize);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					disp_message(hv_WindowHandle, "Surface inspection mode is not available.",
						"image", 5, 20, "red", "true");
					hv_WindowCenteredRotation = 2;
					get_trackball_center_visualize_object_model_3d(hv_SelectedObject.TupleSelectRange(0, hv_MaxIndex),
						hv_TrackballRadiusPixel, hv_ObjectModel3D.TupleSelectRange(0, hv_MaxIndex),
						hv_Poses.TupleSelectRange(0, ((hv_MaxIndex + 1) * 7) - 1), &hv_TBCenter, &hv_TBSize);
					WaitSeconds(1);
				}
			}
			else
			{
				get_trackball_center_visualize_object_model_3d(hv_SelectedObject.TupleSelectRange(0, hv_MaxIndex),
					hv_TrackballRadiusPixel, hv_ObjectModel3D.TupleSelectRange(0, hv_MaxIndex),
					hv_Poses.TupleSelectRange(0, ((hv_MaxIndex + 1) * 7) - 1), &hv_TBCenter, &hv_TBSize);
			}
			dump_image_output_visualize_object_model_3d(ho_Image, hv_WindowHandleBuffer,
				hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, hv_GenParamName, hv_GenParamValue,
				hv_CamParam, hv_Poses, hv_ColorImage, hv_Title, hv_Information, hv_Label,
				hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TBSize,
				hv_SelectedObject, hv_WindowCenteredRotation, hv_TBCenter);
			DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
			HDevWindowStack::SetActive(hv_WindowHandle);
			if (HDevWindowStack::IsOpen())
				DispObj(ho_ImageDump, HDevWindowStack::GetActive());
			//
			//Check for mouse events
			hv_GraphEvent = 0;
			hv_Exit = 0;
			while (0 != 1)
			{
				//
				//Check graphic event
				try
				{
					GetMpositionSubPix(hv_WindowHandle, &hv_GraphButtonRow, &hv_GraphButtonColumn,
						&hv_GraphButton);
					if (0 != (hv_GraphButton != 0))
					{
						if (0 != (HTuple(HTuple(HTuple(hv_GraphButtonRow>((hv_Height - hv_TextHeight) - 25)).TupleAnd(hv_GraphButtonRow<hv_Height)).TupleAnd(hv_GraphButtonColumn>((hv_Width - hv_TextWidth) - 15))).TupleAnd(hv_GraphButtonColumn<hv_Width)))
						{
							//Wait until the continue button has been released
							if (0 != (hv_WaitForButtonRelease == HTuple("true")))
							{
								while (0 != 1)
								{
									GetMpositionSubPix(hv_WindowHandle, &hv_GraphButtonRow, &hv_GraphButtonColumn,
										&hv_GraphButton);
									if (0 != (HTuple(hv_GraphButton == 0).TupleOr(hv_GraphButton == HTuple())))
									{
										if (0 != (HTuple(HTuple(HTuple(hv_GraphButtonRow>((hv_Height - hv_TextHeight) - 25)).TupleAnd(hv_GraphButtonRow<hv_Height)).TupleAnd(hv_GraphButtonColumn>((hv_Width - hv_TextWidth) - 15))).TupleAnd(hv_GraphButtonColumn<hv_Width)))
										{
											hv_ButtonReleased = 1;
										}
										else
										{
											hv_ButtonReleased = 0;
										}
										//
										break;
									}
									//Keep waiting until mouse button is released or moved out of the window
								}
							}
							else
							{
								hv_ButtonReleased = 1;
							}
							//Exit the visualization loop
							if (0 != hv_ButtonReleased)
							{
								hv_Exit = 1;
								break;
							}
						}
						hv_GraphEvent = 1;
						break;
					}
					else
					{
						hv_ButtonHold = 0;
					}
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
			if (0 != hv_GraphEvent)
			{
				analyze_graph_event_visualize_object_model_3d(ho_Image, hv_MouseMapping,
					hv_GraphButton, hv_GraphButtonRow, hv_GraphButtonColumn, hv_WindowHandle,
					hv_WindowHandleBuffer, hv_VirtualTrackball, hv_TrackballSize, hv_SelectedObject,
					hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, hv_CamParam, hv_Label, hv_Title,
					hv_Information, hv_GenParamName, hv_GenParamValue, hv_Poses, hv_ButtonHold,
					hv_TBCenter, hv_TBSize, hv_WindowCenteredRotation, hv_MaxNumModels, &hv_Poses,
					&hv_SelectedObject, &hv_ButtonHold, &hv_WindowCenteredRotation);
			}
			if (0 != hv_Exit)
			{
				break;
			}
		}
		//
		//Display final state with persistence, if requested
		//Note that disp_object_model_3d must be used instead of the 3D scene
		if (0 != ((hv_PersistenceParamName.TupleLength())>0))
		{
			DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D, hv_CamParam, hv_Poses,
				(HTuple("disp_background").Append("alpha")).TupleConcat(hv_PersistenceParamName),
				(HTuple("true").Append(0.0)).TupleConcat(hv_PersistenceParamValue));
		}
		//
		//Compute the output pose
		if (0 != ExpGetGlobalVar_gIsSinglePose())
		{
			(*hv_PoseOut) = hv_Poses.TupleSelectRange(0, 6);
		}
		else
		{
			(*hv_PoseOut) = hv_Poses;
		}
		//
		//Clean up
		SetSystem("clip_region", hv_ClipRegion);
		// dev_set_preferences(...); only in hdevelop
		// dev_set_preferences(...); only in hdevelop
		dump_image_output_visualize_object_model_3d(ho_Image, hv_WindowHandleBuffer,
			hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, hv_GenParamName, hv_GenParamValue,
			hv_CamParam, hv_Poses, hv_ColorImage, hv_Title, HTuple(), hv_Label, 0, "false",
			hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject,
			hv_WindowCenteredRotation, hv_TBCenter);
		DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
		HDevWindowStack::SetActive(hv_WindowHandle);
		if (HDevWindowStack::IsOpen())
			DispObj(ho_ImageDump, HDevWindowStack::GetActive());
		CloseWindow(hv_WindowHandleBuffer);
		SetPart(hv_WindowHandle, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2);
		ClearScene3d(hv_Scene3D);
		hv_Scene3D = HTuple();
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		try
		{
			if (0 != (0<(hv_Scene3DTest.TupleLength())))
			{
				ClearScene3d(hv_Scene3DTest);
				hv_Scene3DTest = HTuple();
			}
			if (0 != (0<(hv_Scene3D.TupleLength())))
			{
				ClearScene3d(hv_Scene3D);
				hv_Scene3D = HTuple();
			}
			if (0 != (0<(hv_WindowHandleBuffer.TupleLength())))
			{
				CloseWindow(hv_WindowHandleBuffer);
				hv_WindowHandleBuffer = HTuple();
			}
		}
		// catch (e) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_e);
			//suppress all further exceptions to return the original exception
		}

		throw HException(hv_Exception);
	}
	return;
}

// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d_ext(HTuple hv_WindowHandle, HTuple hv_ObjectModel3D,
	HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue,
	HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple hv_MessageQueue,
	HTuple hv_Buttons, HTuple hv_Type, HTuple hv_Message, HTuple hv_DispViewPoint,
	HTuple hv_ViewPoint)
{

	// Local iconic variables
	HObject  ho_Image, ho_ImageDump;

	// Local control variables
	HTuple  hv_Parameters, hv_Scene3DTest, hv_Scene3D;
	HTuple  hv_WindowHandleBuffer, hv_TrackballSize, hv_VirtualTrackball;
	HTuple  hv_MouseMapping, hv_gDispObjOffset, hv_gInfoDecor;
	HTuple  hv_gLabelsDecor, hv_gTitleDecor, hv_gInfoPos, hv_gTitlePos;
	HTuple  hv_gAlphaDeselected, hv_ExitButton, hv_MaxNumModels;
	HTuple  hv_WindowCenteredRotation, hv_NumModels, hv_SelectedObject;
	HTuple  hv_ButtonPressStatus, hv_ClipRegion, hv_CPLength;
	HTuple  hv_RowNotUsed, hv_ColumnNotUsed, hv_Width, hv_Height;
	HTuple  hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2;
	HTuple  hv_CamParamValue, hv_CamWidth, hv_CamHeight, hv_Scale;
	HTuple  hv_Indices, hv_DispBackground, hv_Mask, hv_Center;
	HTuple  hv_Poses, hv_HomMat3Ds, hv_Sequence, hv_PoseEstimated;
	HTuple  hv_gIsSinglePose, hv_Font, hv_Exception, hv_gUsesOpenGL;
	HTuple  hv_OpenGLInfo, hv_DummyObjectModel3D, hv_CameraIndexTest;
	HTuple  hv_PoseTest, hv_InstanceIndexTest, hv_MinImageSize;
	HTuple  hv_TrackballRadiusPixel, hv_idx, hv_MaxAscent, hv_MaxDescent;
	HTuple  hv_MaxWidth, hv_MaxHeight, hv_Ascent, hv_Descent;
	HTuple  hv_TextWidth, hv_TextHeight, hv_ButtonWidth, hv_ButtonHeight;
	HTuple  hv_gButtons, hv_NumChannels, hv_ColorImage, hv_OriginalGenParamName;
	HTuple  hv_OriginalGenParamValue, hv_Exit, hv_PreviousSentPose;
	HTuple  hv_CameraIndex, hv_AllInstances, hv_SetLight, hv_LightParam;
	HTuple  hv_LightPosition, hv_LightKind, hv_LightIndex, hv_PersistenceParamName;
	HTuple  hv_PersistenceParamValue, hv_AlphaOrig, hv_I, hv_ParamName;
	HTuple  hv_ParamValue, hv_ParamNameTrunk, hv_Instance, hv_HomMat3D;
	HTuple  hv_Qx, hv_Qy, hv_Qz, hv_TBCenter, hv_TBSize, hv_ButtonHold;
	HTuple  hv_SupressUpdateMessage, hv_VisualizeTB, hv_MaxIndex;
	HTuple  hv_TrackballCenterRow, hv_TrackballCenterCol, hv_GraphEvent;
	HTuple  hv_Redraw, hv_RecreateScene3D, hv_GraphButton, hv_MessageHandle;
	HTuple  hv_MessageType, hv_Pos, hv_Angle, hv_Pose, hv_NewPoses;
	HTuple  hv_Index, hv_Model, hv_ButtonIndex, hv_ButtonText;
	HTuple  hv_ButtonPressed, hv_FoundButton, hv_FoundButton2;
	HTuple  hv_PoseOut, hv_GraphButtonRow, hv_GraphButtonColumn;

	//The procedure visualize_object_model_3d can be used to display
	//one or more 3d object models and to interactively modify
	//the object poses by using the mouse.
	//
	//The pose can be modified by moving the mouse while
	//pressing a mouse button. The default settings are:
	//
	// Rotate: Left mouse button
	// Zoom: Shift + Left mouse button (or Center mouse button)
	// Pan: Ctrl + Left mouse button
	//
	//Furthermore, it is possible to select and deselect objects,
	//to decrease the mouse sensitivity, and to toggle the
	//inspection mode (see the description of the generic parameter
	//'inspection_mode' below):
	//
	// (De-)select object(s): Right mouse button
	// Low mouse sensitivity: Alt + Mouse button
	// Toggle inspection mode: Ctrl + Alt + Left mouse button
	//
	//In GenParamName and GenParamValue all generic Parameters
	//of disp_object_model_3d are supported.
	//
	//**********************************************************
	//Define parameter variables
	//**********************************************************
	//
	CreateMessage(&hv_Parameters);
	SetMessageTuple(hv_Parameters, "MessageQueue", hv_MessageQueue);

	//
	//**********************************************************
	//Initialize Handles to enable correct handling in error case
	//**********************************************************
	hv_Scene3DTest = HTuple();
	hv_Scene3D = HTuple();
	hv_WindowHandleBuffer = HTuple();

	//**********************************************************
	//Some user defines that may be adapted if desired
	//**********************************************************
	//
	//TrackballSize defines the diameter of the trackball in
	//the image with respect to the smaller image dimension.
	hv_TrackballSize = 0.8;
	//
	//VirtualTrackball defines the type of virtual trackball that
	//shall be used ('shoemake' or 'bell').
	hv_VirtualTrackball = "shoemake";
	//VirtualTrackball := 'bell'
	//
	//Functionality of mouse buttons
	//    1: Left Button
	//    2: Middle Button
	//    4: Right Button
	//    5: Left+Right Mousebutton
	//  8+x: Shift + Mousebutton
	// 16+x: Ctrl + Mousebutton
	// 48+x: Ctrl + Alt + Mousebutton
	//in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]
	hv_MouseMapping.Clear();
	hv_MouseMapping[0] = 17;
	hv_MouseMapping[1] = 1;
	hv_MouseMapping[2] = 2;
	hv_MouseMapping[3] = 5;
	hv_MouseMapping[4] = 9;
	hv_MouseMapping[5] = 4;
	hv_MouseMapping[6] = 49;
	//
	//The labels of the objects appear next to their projected
	//center. With gDispObjOffset a fixed offset is added
	//                  R,  C
	hv_gDispObjOffset.Clear();
	hv_gDispObjOffset[0] = -30;
	hv_gDispObjOffset[1] = 0;
	SetMessageTuple(hv_Parameters, "gDispObjOffset", hv_gDispObjOffset);
	//
	//Customize the decoration of the different text elements
	//              Color,   Box
	hv_gInfoDecor.Clear();
	hv_gInfoDecor[0] = "white";
	hv_gInfoDecor[1] = "false";
	SetMessageTuple(hv_Parameters, "gInfoDecor", hv_gInfoDecor);
	hv_gLabelsDecor.Clear();
	hv_gLabelsDecor[0] = "white";
	hv_gLabelsDecor[1] = "false";
	SetMessageTuple(hv_Parameters, "gLabelsDecor", hv_gLabelsDecor);
	hv_gTitleDecor.Clear();
	hv_gTitleDecor[0] = "black";
	hv_gTitleDecor[1] = "true";
	SetMessageTuple(hv_Parameters, "gTitleDecor", hv_gTitleDecor);
	//
	//Customize the position of some text elements
	//  gInfoPos has one of the values
	//  {'UpperLeft', 'LowerLeft', 'UpperRight'}
	hv_gInfoPos = "LowerLeft";
	SetMessageTuple(hv_Parameters, "gInfoPos", hv_gInfoPos);
	//  gTitlePos has one of the values
	//  {'UpperLeft', 'UpperCenter', 'UpperRight'}
	hv_gTitlePos = "UpperLeft";
	SetMessageTuple(hv_Parameters, "gTitlePos", hv_gTitlePos);
	//Alpha value (=1-transparency) that is used for visualizing
	//the objects that are not selected
	hv_gAlphaDeselected = 0.3;
	SetMessageTuple(hv_Parameters, "gAlphaDeselected", hv_gAlphaDeselected);
	//BUTTONS
	hv_ExitButton = -1;
	if (0 != (hv_Buttons == HTuple()))
	{
		//Customize the label of the continue button
		hv_Buttons[0] = " Continue ";
		//Position of the button
		hv_Buttons[1] = "right";
		hv_Buttons[2] = "bottom";
		hv_Buttons[3] = -1;
		hv_Buttons[4] = -1;
		hv_ExitButton = 0;
	}
	//Number of 3D Object models that can be selected and handled individually.
	//If there are more models passed then this number, some calculations
	//are performed differently and the individual selection and handling
	//of models is not supported anymore. Note that the value of MaxNumModels
	//can be overwritten with the generic parameter max_num_selectable_models.
	hv_MaxNumModels = 1000;
	//Defines the default for the initial state of the rotation center:
	//(1) The rotation center is fixed in the center of the image and lies
	//    on the surface of the object.
	//(2) The rotation center lies in the center of the object.
	hv_WindowCenteredRotation = 2;
	//
	//**********************************************************
	//
	//Initialize some values
	hv_NumModels = hv_ObjectModel3D.TupleLength();
	hv_SelectedObject = HTuple(hv_NumModels, 1);
	hv_ButtonPressStatus = 0;
	//
	//Apply some system settings
	// dev_set_preferences(...); only in hdevelop
	// dev_get_preferences(...); only in hdevelop
	// dev_set_preferences(...); only in hdevelop
	GetSystem("clip_region", &hv_ClipRegion);
	SetSystem("clip_region", "false");
	dev_update_off();
	//
	//Check if GenParamName matches GenParamValue
	if (0 != ((hv_GenParamName.TupleLength()) != (hv_GenParamValue.TupleLength())))
	{
		throw HException("Number of generic parameters does not match number of generic parameter values");
	}
	//
	//
	//Refactor camera parameters to fit to window size
	//
	hv_CPLength = hv_CamParam.TupleLength();
	GetWindowExtents(hv_WindowHandle, &hv_RowNotUsed, &hv_ColumnNotUsed, &hv_Width,
		&hv_Height);
	GetPart(hv_WindowHandle, &hv_WPRow1, &hv_WPColumn1, &hv_WPRow2, &hv_WPColumn2);
	SetPart(hv_WindowHandle, 0, 0, hv_Height - 1, hv_Width - 1);
	if (0 != (hv_CPLength == 0))
	{
		gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width / 2, hv_Height / 2,
			hv_Width, hv_Height, &hv_CamParam);
	}
	else
	{
		get_cam_par_data(hv_CamParam, (((((HTuple("sx").Append("sy")).Append("cx")).Append("cy")).Append("image_width")).Append("image_height")),
			&hv_CamParamValue);
		hv_CamWidth = HTuple(hv_CamParamValue[4]).TupleReal();
		hv_CamHeight = HTuple(hv_CamParamValue[5]).TupleReal();
		hv_Scale = ((hv_Width / hv_CamWidth).TupleConcat(hv_Height / hv_CamHeight)).TupleMin();
		set_cam_par_data(hv_CamParam, "sx", HTuple(hv_CamParamValue[0]) / hv_Scale, &hv_CamParam);
		set_cam_par_data(hv_CamParam, "sy", HTuple(hv_CamParamValue[1]) / hv_Scale, &hv_CamParam);
		set_cam_par_data(hv_CamParam, "cx", HTuple(hv_CamParamValue[2])*hv_Scale, &hv_CamParam);
		set_cam_par_data(hv_CamParam, "cy", HTuple(hv_CamParamValue[3])*hv_Scale, &hv_CamParam);
		set_cam_par_data(hv_CamParam, "image_width", (HTuple(hv_CamParamValue[4])*hv_Scale).TupleInt(),
			&hv_CamParam);
		set_cam_par_data(hv_CamParam, "image_height", (HTuple(hv_CamParamValue[5])*hv_Scale).TupleInt(),
			&hv_CamParam);
	}
	//
	//Check the generic parameters for max_num_selectable_models
	//(Note that the default is set above to MaxNumModels := 1000)
	hv_Indices = hv_GenParamName.TupleFind("max_num_selectable_models");
	if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
	{
		if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleIsNumber()))
		{
			if (0 != (((HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleNumber()).TupleInt())<1))
			{
				//Wrong parameter value: Only integer values greater than 0 are allowed
				throw HException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
			}
		}
		else
		{
			//Wrong parameter value: Only integer values greater than 0 are allowed
			throw HException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
		}
		hv_MaxNumModels = (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleNumber()).TupleInt();
		hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
		hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
	}
	//
	//Check the generic parameters for window_centered_rotation
	//(Note that the default is set above to WindowCenteredRotation := 2)
	hv_Indices = hv_GenParamName.TupleFind("inspection_mode");
	if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
	{
		if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]) == HTuple("surface")))
		{
			hv_WindowCenteredRotation = 1;
		}
		else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]) == HTuple("standard")))
		{
			hv_WindowCenteredRotation = 2;
		}
		else
		{
			//Wrong parameter value, use default value
		}
		hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
		hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
	}
	//
	//Check the generic parameters for disp_background
	//(The former parameter name 'use_background' is still supported
	// for compatibility reasons)
	hv_DispBackground = "false";
	if (0 != ((hv_GenParamName.TupleLength())>0))
	{
		hv_Mask = (hv_GenParamName.TupleEqualElem("disp_background")).TupleOr(hv_GenParamName.TupleEqualElem("use_background"));
		hv_Indices = hv_Mask.TupleFind(1);
	}
	else
	{
		hv_Indices = -1;
	}
	if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
	{
		hv_DispBackground = HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]);
		if (0 != (HTuple(hv_DispBackground != HTuple("true")).TupleAnd(hv_DispBackground != HTuple("false"))))
		{
			//Wrong parameter value: Only 'true' and 'false' are allowed
			throw HException("Wrong value for parameter 'disp_background' (must be either 'true' or 'false')");
		}
		//Note the the background is handled explicitly in this procedure
		//and therefore, the parameter is removed from the list of
		//parameters and disp_background is always set to true (see below)
		hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
		hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
	}
	//
	//Read and check the parameter Label for each object
	if (0 != ((hv_Label.TupleLength()) == 0))
	{
		hv_Label = 0;
	}
	else if (0 != ((hv_Label.TupleLength()) == 1))
	{
		hv_Label = HTuple(hv_NumModels, hv_Label);
	}
	else
	{
		if (0 != ((hv_Label.TupleLength()) != hv_NumModels))
		{
			//Error: Number of elements in Label does not match the
			//number of object models
			// stop(...); only in hdevelop
		}
	}
	//
	//Read and check the parameter PoseIn for each object
	get_object_models_center(hv_ObjectModel3D, &hv_Center);
	if (0 != ((hv_PoseIn.TupleLength()) == 0))
	{
		//If no pose was specified by the caller, automatically calculate
		//a pose that is appropriate for the visualization.
		//Set the initial model reference pose. The orientation is parallel
		//to the object coordinate system, the position is at the center
		//of gravity of all models.
		CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]),
			0, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
		determine_optimum_pose_distance(hv_ObjectModel3D, hv_CamParam, 0.9, hv_PoseIn,
			&hv_PoseEstimated);
		hv_Poses = HTuple();
		hv_HomMat3Ds = HTuple();
		hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
		hv_Poses = HTuple(hv_PoseEstimated[hv_Sequence % 7]);
		hv_gIsSinglePose = 1;
		SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
	}
	else if (0 != ((hv_PoseIn.TupleLength()) == 7))
	{
		hv_Poses = HTuple();
		hv_HomMat3Ds = HTuple();
		hv_Sequence = HTuple::TupleGenSequence(0, (hv_NumModels * 7) - 1, 1);
		hv_Poses = HTuple(hv_PoseIn[hv_Sequence % 7]);
		hv_gIsSinglePose = 1;
		SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
	}
	else
	{
		if (0 != ((hv_PoseIn.TupleLength()) != ((hv_ObjectModel3D.TupleLength()) * 7)))
		{
			//Error: Wrong number of values of input control parameter 'PoseIn'
			// stop(...); only in hdevelop
		}
		else
		{
			hv_Poses = hv_PoseIn;
		}
		hv_gIsSinglePose = 0;
		SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
	}

	//
	//Open (invisible) buffer window to avoid flickering
	OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", &hv_WindowHandleBuffer);
	SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height - 1, hv_Width - 1);
	GetFont(hv_WindowHandle, &hv_Font);
	try
	{
		SetFont(hv_WindowHandleBuffer, hv_Font);
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
	}
	//
	// Is OpenGL available and should it be used?
	hv_gUsesOpenGL = "true";
	SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
	hv_Indices = hv_GenParamName.TupleFind("opengl");
	if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
	{
		hv_gUsesOpenGL = HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]);
		SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
		hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
		hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
		if (0 != (HTuple(hv_gUsesOpenGL != HTuple("true")).TupleAnd(hv_gUsesOpenGL != HTuple("false"))))
		{
			//Wrong parameter value: Only 'true' and 'false' are allowed
			throw HException("Wrong value for parameter 'opengl' (must be either 'true' or 'false')");
		}
	}
	if (0 != (hv_gUsesOpenGL == HTuple("true")))
	{
		GetSystem("opengl_info", &hv_OpenGLInfo);
		if (0 != (hv_OpenGLInfo == HTuple("No OpenGL support included.")))
		{
			hv_gUsesOpenGL = "false";
			SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
		}
		else
		{
			GenObjectModel3dFromPoints(0, 0, 0, &hv_DummyObjectModel3D);
			CreateScene3d(&hv_Scene3DTest);
			AddScene3dCamera(hv_Scene3DTest, hv_CamParam, &hv_CameraIndexTest);
			determine_optimum_pose_distance(hv_DummyObjectModel3D, hv_CamParam, 0.9, ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)),
				&hv_PoseTest);
			AddScene3dInstance(hv_Scene3DTest, hv_DummyObjectModel3D, hv_PoseTest, &hv_InstanceIndexTest);
			try
			{
				DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3DTest, hv_InstanceIndexTest);
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
				hv_gUsesOpenGL = "false";
				SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
			}
			hv_Scene3DTest = HTuple();
			hv_DummyObjectModel3D = HTuple();
		}
	}
	//
	//Compute the trackball
	hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
	hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize) / 2.0;
	//
	//Measure the text extents for the continue button in the
	//graphics window
	//Finalize Buttons
	{
		HTuple end_val312 = (hv_Buttons.TupleLength()) - 1;
		HTuple step_val312 = 5;
		for (hv_idx = 0; hv_idx.Continue(end_val312, step_val312); hv_idx += step_val312)
		{
			GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth,
				&hv_MaxHeight);
			GetStringExtents(hv_WindowHandleBuffer, HTuple(hv_Buttons[hv_idx + 0]) + "  ", &hv_Ascent,
				&hv_Descent, &hv_TextWidth, &hv_TextHeight);
			hv_ButtonWidth = HTuple(hv_Buttons[hv_idx + 3]);
			if (0 != (hv_ButtonWidth == -1))
			{
				hv_ButtonWidth = hv_TextWidth;
			}
			hv_ButtonHeight = HTuple(hv_Buttons[hv_idx + 4]);
			if (0 != (hv_ButtonHeight == -1))
			{
				//Button border is of size 2
				hv_ButtonHeight = hv_MaxHeight;
			}
			//X position
			if (0 != (HTuple(hv_Buttons[hv_idx + 1]) == HTuple("right")))
			{
				hv_Buttons[hv_idx + 1] = (hv_Width - 15) - hv_ButtonWidth;
			}
			else if (0 != (HTuple(hv_Buttons[hv_idx + 1]) == HTuple("left")))
			{
				hv_Buttons[hv_idx + 1] = 15;
			}
			else if (0 != (HTuple(hv_Buttons[hv_idx + 1]) == HTuple("center")))
			{
				hv_Buttons[hv_idx + 1] = (hv_Width / 2) - (hv_ButtonWidth / 2);
			}
			else
			{
				throw HException("Invalid button horizontal position: " + HTuple(hv_Buttons[hv_idx + 1]));
			}
			hv_Buttons[hv_idx + 3] = HTuple(hv_Buttons[hv_idx + 1]) + hv_ButtonWidth;
			//Y position
			if (0 != (HTuple(hv_Buttons[hv_idx + 2]) == HTuple("bottom")))
			{
				hv_Buttons[hv_idx + 2] = (hv_Height - 25) - hv_ButtonHeight;
			}
			else if (0 != (HTuple(hv_Buttons[hv_idx + 2]) == HTuple("top")))
			{
				hv_Buttons[hv_idx + 2] = 25;
			}
			else if (0 != (HTuple(hv_Buttons[hv_idx + 2]) == HTuple("center")))
			{
				hv_Buttons[hv_idx + 2] = (hv_Height / 2) - (hv_ButtonHeight / 2);
			}
			else
			{
				throw HException("Invalid button vertical position: " + HTuple(hv_Buttons[hv_idx + 2]));
			}
			hv_Buttons[hv_idx + 4] = HTuple(hv_Buttons[hv_idx + 2]) + hv_ButtonHeight;
		}
	}
	hv_gButtons = hv_Buttons;
	SetMessageTuple(hv_Parameters, "gButtons", hv_gButtons);
	//
	//Store background image
	if (0 != (hv_DispBackground == HTuple("false")))
	{
		ClearWindow(hv_WindowHandle);
	}
	DumpWindowImage(&ho_Image, hv_WindowHandle);
	//Special treatment for color background images necessary
	CountChannels(ho_Image, &hv_NumChannels);
	hv_ColorImage = hv_NumChannels == 3;
	//
	hv_OriginalGenParamName = hv_GenParamName;
	hv_OriginalGenParamValue = hv_GenParamValue;

	hv_Exit = 0;
	hv_PreviousSentPose = HTuple();
	while (0 != (hv_Exit.TupleNot()))
	{
		hv_GenParamName = hv_OriginalGenParamName;
		hv_GenParamValue = hv_OriginalGenParamValue;

		CreateScene3d(&hv_Scene3D);
		AddScene3dCamera(hv_Scene3D, hv_CamParam, &hv_CameraIndex);
		AddScene3dInstance(hv_Scene3D, hv_ObjectModel3D, hv_Poses, &hv_AllInstances);
		//Always set 'disp_background' to true,  because it is handled explicitly
		//in this procedure (see above)
		SetScene3dParam(hv_Scene3D, "disp_background", "true");
		//Check if we have to set light specific parameters
		hv_SetLight = hv_GenParamName.TupleRegexpTest("light_");
		if (0 != hv_SetLight)
		{
			//set position of light source
			hv_Indices = hv_GenParamName.TupleFind("light_position");
			if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
			{
				//If multiple light positions are given, use the last one
				hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]).TupleSplit(HTuple(", "))).TupleNumber();
				if (0 != ((hv_LightParam.TupleLength()) != 4))
				{
					throw HException("light_position must be given as a string that contains four space separated floating point numbers");
				}
				hv_LightPosition = hv_LightParam.TupleSelectRange(0, 2);
				hv_LightKind = "point_light";
				if (0 != (HTuple(hv_LightParam[3]) == 0))
				{
					hv_LightKind = "directional_light";
				}
				//Currently, only one light source is supported
				RemoveScene3dLight(hv_Scene3D, 0);
				AddScene3dLight(hv_Scene3D, hv_LightPosition, hv_LightKind, &hv_LightIndex);
				TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
				TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
			}
			//set ambient part of light source
			hv_Indices = hv_GenParamName.TupleFind("light_ambient");
			if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
			{
				//If the ambient part is set multiple times, use the last setting
				hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]).TupleSplit(HTuple(", "))).TupleNumber();
				if (0 != ((hv_LightParam.TupleLength())<3))
				{
					throw HException("light_ambient must be given as a string that contains three space separated floating point numbers");
				}
				SetScene3dLightParam(hv_Scene3D, 0, "ambient", hv_LightParam.TupleSelectRange(0, 2));
				TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
				TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
			}
			//Set diffuse part of light source
			hv_Indices = hv_GenParamName.TupleFind("light_diffuse");
			if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
			{
				//If the diffuse part is set multiple times, use the last setting
				hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]).TupleSplit(HTuple(", "))).TupleNumber();
				if (0 != ((hv_LightParam.TupleLength())<3))
				{
					throw HException("light_diffuse must be given as a string that contains three space separated floating point numbers");
				}
				SetScene3dLightParam(hv_Scene3D, 0, "diffuse", hv_LightParam.TupleSelectRange(0, 2));
				TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
				TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
			}
		}
		//
		//Handle persistence parameters separately because persistence will
		//only be activated immediately before leaving the visualization
		//procedure
		hv_PersistenceParamName = HTuple();
		hv_PersistenceParamValue = HTuple();
		//Set position of light source
		hv_Indices = hv_GenParamName.TupleFind("object_index_persistence");
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("true")))
			{
				hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("object_index_persistence");
				hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("false")))
			{
			}
			else
			{
				throw HException("Wrong value for parameter 'object_index_persistence' (must be either 'true' or 'false')");
			}
			TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
			TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
		}
		hv_Indices = hv_GenParamName.TupleFind("depth_persistence");
		if (0 != (HTuple(hv_Indices != -1).TupleAnd(hv_Indices != HTuple())))
		{
			if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("true")))
			{
				hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("depth_persistence");
				hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
			}
			else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength()) - 1])]) == HTuple("false")))
			{
			}
			else
			{
				throw HException("Wrong value for parameter 'depth_persistence' (must be either 'true' or 'false')");
			}
			TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
			TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
		}
		//
		//Parse the generic parameters
		//- First, all parameters that are understood by set_scene_3d_instance_param
		hv_AlphaOrig = HTuple(hv_NumModels, 1);
		{
			HTuple end_val456 = (hv_GenParamName.TupleLength()) - 1;
			HTuple step_val456 = 1;
			for (hv_I = 0; hv_I.Continue(end_val456, step_val456); hv_I += step_val456)
			{
				hv_ParamName = HTuple(hv_GenParamName[hv_I]);
				hv_ParamValue = HTuple(hv_GenParamValue[hv_I]);
				//Check if this parameter is understood by set_scene_3d_param
				if (0 != (hv_ParamName == HTuple("alpha")))
				{
					hv_AlphaOrig = HTuple(hv_NumModels, hv_ParamValue);
				}
				try
				{
					SetScene3dParam(hv_Scene3D, hv_ParamName, hv_ParamValue);
					continue;
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					if (0 != (HTuple(HTuple(hv_Exception[0]) == 1203).TupleOr(HTuple(hv_Exception[0]) == 1303)))
					{
						throw HException((("Wrong type or value for parameter " + hv_ParamName) + ": ") + hv_ParamValue);
					}
				}
				//Check if it is a parameter that is valid for only one instance
				//and therefore can be set only with set_scene_3d_instance_param
				hv_ParamNameTrunk = hv_ParamName.TupleRegexpReplace("_\\d+$", "");
				if (0 != (hv_ParamName == hv_ParamNameTrunk))
				{
					hv_Instance = HTuple::TupleGenSequence(0, hv_NumModels - 1, 1);
				}
				else
				{
					hv_Instance = (hv_ParamName.TupleRegexpReplace(("^" + hv_ParamNameTrunk) + "_(\\d+)$", "$1")).TupleNumber();
					if (0 != (HTuple(hv_Instance<0).TupleOr(hv_Instance>(hv_NumModels - 1))))
					{
						throw HException(("Parameter " + hv_ParamName) + " refers to a non existing 3D object model");
					}
				}
				try
				{
					SetScene3dInstanceParam(hv_Scene3D, hv_Instance, hv_ParamNameTrunk, hv_ParamValue);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					if (0 != (HTuple(HTuple(hv_Exception[0]) == 1204).TupleOr(HTuple(hv_Exception[0]) == 1304)))
					{
						throw HException((("Wrong type or value for parameter " + hv_ParamName) + ": ") + hv_ParamValue);
					}
					else if (0 != (HTuple(HTuple(hv_Exception[0]) == 1203).TupleOr(HTuple(hv_Exception[0]) == 1303)))
					{
						throw HException("Wrong parameter name " + hv_ParamName);
					}
					else
					{
						throw HException(hv_Exception);
					}
				}
				if (0 != (hv_ParamNameTrunk == HTuple("alpha")))
				{
					hv_AlphaOrig[hv_Instance] = hv_ParamValue;
				}
			}
		}
		//
		//Start the visualization loop
		PoseToHomMat3d(hv_Poses.TupleSelectRange(0, 6), &hv_HomMat3D);
		AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]), HTuple(hv_Center[2]),
			&hv_Qx, &hv_Qy, &hv_Qz);
		hv_TBCenter.Clear();
		hv_TBCenter.Append(hv_Qx);
		hv_TBCenter.Append(hv_Qy);
		hv_TBCenter.Append(hv_Qz);
		hv_TBSize = (0.5 + ((0.5*(hv_SelectedObject.TupleSum())) / hv_NumModels))*hv_TrackballRadiusPixel;
		hv_ButtonHold = 0;
		hv_SupressUpdateMessage = 0;
		while (0 != (hv_Exit.TupleNot()))
		{
			hv_VisualizeTB = (hv_SelectedObject.TupleMax()) != 0;
			hv_MaxIndex = ((HTuple(hv_ObjectModel3D.TupleLength()).TupleConcat(hv_MaxNumModels)).TupleMin()) - 1;
			//Set trackball fixed in the center of the window
			hv_TrackballCenterRow = hv_Height / 2;
			hv_TrackballCenterCol = hv_Width / 2;
			if (0 != (hv_WindowCenteredRotation == 1))
			{
				try
				{
					get_trackball_center_fixed(hv_SelectedObject.TupleSelectRange(0, hv_MaxIndex),
						hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel,
						hv_Scene3D, hv_ObjectModel3D.TupleSelectRange(0, hv_MaxIndex), hv_Poses.TupleSelectRange(0, ((hv_MaxIndex + 1) * 7) - 1),
						hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, hv_GenParamValue,
						&hv_TBCenter, &hv_TBSize);
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					disp_message(hv_WindowHandle, "Surface inspection mode is not available.",
						"image", 5, 20, "red", "true");
					hv_WindowCenteredRotation = 2;
					get_trackball_center(hv_SelectedObject.TupleSelectRange(0, hv_MaxIndex),
						hv_TrackballRadiusPixel, hv_ObjectModel3D.TupleSelectRange(0, hv_MaxIndex),
						hv_Poses.TupleSelectRange(0, ((hv_MaxIndex + 1) * 7) - 1), &hv_TBCenter, &hv_TBSize);
					WaitSeconds(1);
				}
			}
			else
			{
				get_trackball_center(hv_SelectedObject.TupleSelectRange(0, hv_MaxIndex), hv_TrackballRadiusPixel,
					hv_ObjectModel3D.TupleSelectRange(0, hv_MaxIndex), hv_Poses.TupleSelectRange(0, ((hv_MaxIndex + 1) * 7) - 1),
					&hv_TBCenter, &hv_TBSize);
			}
			dump_image_output(ho_Image, hv_Parameters, hv_WindowHandleBuffer, hv_Scene3D,
				hv_AlphaOrig, hv_ObjectModel3D, hv_GenParamName, hv_GenParamValue, hv_CamParam,
				hv_Poses, hv_ColorImage, hv_Title, hv_Information, hv_Label, hv_VisualizeTB,
				"true", hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject,
				hv_WindowCenteredRotation, hv_TBCenter, hv_Type, hv_Message, hv_DispViewPoint,
				hv_ViewPoint);
			DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
			if (0 != 1)
			{
				DispObj(ho_ImageDump, hv_WindowHandle);
			}
			else
			{
				HDevWindowStack::SetActive(hv_WindowHandle);
				if (HDevWindowStack::IsOpen())
					DispObj(ho_ImageDump, HDevWindowStack::GetActive());
			}

			if (0 != (hv_Poses != hv_PreviousSentPose))
			{
				send_pose_update(hv_Parameters, hv_Poses);
				hv_PreviousSentPose = hv_Poses;
			}
			//
			//
			//Check for mouse events
			hv_GraphEvent = 0;
			hv_Exit = 0;
			hv_Redraw = 0;
			hv_RecreateScene3D = 0;
			while (0 != (hv_Exit.TupleNot()))
			{
				//
				//Check graphic event
				try
				{
					get_mouse_info(hv_WindowHandle, hv_MessageQueue, 0.01, &hv_GraphButtonRow,
						&hv_GraphButtonColumn, &hv_GraphButton);

					if (0 != (hv_GraphButton == -1))
					{
						//timeout! Check the second message queue
						try
						{
							//Process all messages first, then perform any update
							//This avoids message congestion, where we are too slow with the redrawing.
							while (0 != 1)
							{
								DequeueMessage(HTuple(hv_MessageQueue[1]), "timeout", 0.001, &hv_MessageHandle);
								GetMessageTuple(hv_MessageHandle, "type", &hv_MessageType);
								if (0 != (hv_MessageType == HTuple("exit")))
								{
									//Graceful exit
									hv_Exit = 1;
									break;
								}
								else if (0 != (hv_MessageType == HTuple("exit_fast")))
								{
									//Fast exit - no cleanup of resources! Use only for debugging.
									return;
								}
								else if (0 != (hv_MessageType == HTuple("toggle_param")))
								{
									GetMessageTuple(hv_MessageHandle, "param", &hv_ParamName);
									hv_Pos = hv_OriginalGenParamName.TupleFind(hv_ParamName);
									if (0 != (HTuple(hv_Pos != -1).TupleAnd(hv_Pos != HTuple())))
									{
										if (0 != (HTuple(hv_OriginalGenParamValue[hv_Pos]) == HTuple("true")))
										{
											hv_OriginalGenParamValue[hv_Pos] = "false";
										}
										else
										{
											hv_OriginalGenParamValue[hv_Pos] = "true";
										}
									}
									else
									{
										hv_OriginalGenParamName = hv_OriginalGenParamName.TupleConcat(hv_ParamName);
										hv_OriginalGenParamValue = hv_OriginalGenParamValue.TupleConcat("true");
										hv_Pos = (hv_OriginalGenParamName.TupleLength()) - 1;
									}
									//try
									//set_scene_3d_param (Scene3D, GenParamName[Pos], GenParamValue[Pos])
									//catch (Exception)
									//If the parameter cannot be set directly, recreate the scene
									//completely
									hv_RecreateScene3D = 1;
									//endtry
									hv_Redraw = 1;
								}
								else if (0 != (hv_MessageType == HTuple("auto_rotate")))
								{
									GetMessageTuple(hv_MessageHandle, "angle", &hv_Angle);
									hv_Pose.Clear();
									hv_Pose[0] = 0;
									hv_Pose[1] = 0;
									hv_Pose[2] = 0;
									hv_Pose[3] = 0;
									hv_Pose[4] = 0;
									hv_Pose.Append(hv_Angle);
									hv_Pose.Append(0);
									PoseCompose(hv_Poses, hv_Pose, &hv_Poses);
									SetScene3dInstancePose(hv_Scene3D, hv_AllInstances, hv_Poses);
									hv_Redraw = 1;
								}
								else if (0 != (hv_MessageType == HTuple("set_pose")))
								{
									GetMessageTuple(hv_MessageHandle, "poses", &hv_NewPoses);
									if (0 != ((hv_NewPoses.TupleLength()) == (hv_Poses.TupleLength())))
									{
										hv_NewPoses = hv_Poses;
									}
									else if (0 != ((hv_NewPoses.TupleLength()) == 7))
									{
										hv_Poses = ((const HTuple&)hv_NewPoses)[HTuple::TupleGenSequence(0, (hv_Poses.TupleLength()) - 1, 1) % 7];
									}
									else
									{
										//use only first pose in NewPoses
										hv_Poses = ((const HTuple&)hv_NewPoses)[HTuple::TupleGenSequence(0, (hv_Poses.TupleLength()) - 1, 1) % 7];
									}
									SetScene3dInstancePose(hv_Scene3D, hv_AllInstances, hv_Poses);
									hv_Redraw = 1;
								}
								else if (0 != (hv_MessageType == HTuple("replace_object_model")))
								{
									GetMessageTuple(hv_MessageHandle, "index", &hv_Index);
									GetMessageTuple(hv_MessageHandle, "model", &hv_Model);
									hv_ObjectModel3D[hv_Index] = hv_Model;
									hv_RecreateScene3D = 1;
									hv_Redraw = 1;
								}
								else if (0 != (hv_MessageType == HTuple("force_redraw")))
								{
									hv_Redraw = 1;
								}
								else if (0 != (hv_MessageType == HTuple("change_button_text")))
								{
									GetMessageTuple(hv_MessageHandle, "index", &hv_ButtonIndex);
									GetMessageTuple(hv_MessageHandle, "text", &hv_ButtonText);
									if (0 != (HTuple(hv_ButtonIndex >= 0).TupleAnd(hv_ButtonIndex<((hv_gButtons.TupleLength()) / 5))))
									{
										hv_gButtons[5 * hv_ButtonIndex] = hv_ButtonText;
										SetMessageTuple(hv_Parameters, "gButtons", hv_gButtons);
									}
									hv_Redraw = 1;
								}
								else if (0 != (hv_MessageType == HTuple("change_title")))
								{
									GetMessageTuple(hv_MessageHandle, "title", &hv_Title);
									hv_Redraw = 1;
								}
							}
						}
						// catch (Exception) 
						catch (HException &HDevExpDefaultException)
						{
							HDevExpDefaultException.ToHTuple(&hv_Exception);
							//Timeout in dequeue_message is OK
							if (0 != (HTuple(hv_Exception[0]) != 9400))
							{
								throw HException(hv_Exception);
							}
						}
						if (0 != hv_Redraw)
						{
							break;
						}
						continue;
					}

					if (0 != (hv_GraphButton != 0))
					{
						check_mouse_over_button(hv_Parameters, hv_GraphButtonRow, hv_GraphButtonColumn,
							&hv_FoundButton);
						hv_ButtonPressed = -1;
						if (0 != (hv_FoundButton >= 0))
						{
							//Wait until the button has been released
							while (0 != 1)
							{
								get_mouse_info(hv_WindowHandle, hv_MessageQueue, HTuple(), &hv_GraphButtonRow,
									&hv_GraphButtonColumn, &hv_GraphButton);
								if (0 != (hv_GraphButton == 0))
								{
									check_mouse_over_button(hv_Parameters, hv_GraphButtonRow, hv_GraphButtonColumn,
										&hv_FoundButton2);
									if (0 != (hv_FoundButton2 == hv_FoundButton))
									{
										hv_ButtonPressed = hv_FoundButton;
									}
									break;
								}
								//Keep waiting until mouse button is released or moved out of the window
							}
							if (0 != (hv_ButtonPressed >= 0))
							{
								if (0 != (hv_ButtonPressed == hv_ExitButton))
								{
									hv_Exit = 1;
									break;
								}
								else
								{
									CreateMessage(&hv_MessageHandle);
									SetMessageTuple(hv_MessageHandle, "type", "button_pressed");
									SetMessageTuple(hv_MessageHandle, "button", hv_ButtonPressed / 5);
									EnqueueMessage(HTuple(hv_MessageQueue[2]), hv_MessageHandle, HTuple(),
										HTuple());
								}
							}
						}
						hv_GraphEvent = 1;
						break;
					}
					else
					{
						hv_ButtonHold = 0;
					}
				}
				// catch (Exception) 
				catch (HException &HDevExpDefaultException)
				{
					HDevExpDefaultException.ToHTuple(&hv_Exception);
					//Keep waiting
				}
			}
			if (0 != hv_GraphEvent)
			{
				analyze_graph_event(ho_Image, hv_Parameters, hv_MouseMapping, hv_GraphButton,
					hv_GraphButtonRow, hv_GraphButtonColumn, hv_WindowHandle, hv_WindowHandleBuffer,
					hv_VirtualTrackball, hv_TrackballSize, hv_SelectedObject, hv_Scene3D,
					hv_AlphaOrig, hv_ObjectModel3D, hv_CamParam, hv_Label, hv_Title, hv_Information,
					hv_GenParamName, hv_GenParamValue, hv_Poses, hv_ButtonHold, hv_TBCenter,
					hv_TBSize, hv_WindowCenteredRotation, hv_MaxNumModels, hv_MessageQueue,
					&hv_Poses, &hv_SelectedObject, &hv_ButtonHold, &hv_WindowCenteredRotation);
			}
			if (0 != hv_RecreateScene3D)
			{
				break;
			}
		}
	}

	try
	{
		//
		//Display final state with persistence, if requested
		//Note that disp_object_model_3d must be used instead of the 3D scene
		if (0 != ((hv_PersistenceParamName.TupleLength())>0))
		{
			try
			{
				DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D, hv_CamParam, hv_Poses,
					(HTuple("disp_background").Append("alpha")).TupleConcat(hv_PersistenceParamName),
					(HTuple("true").Append(0.0)).TupleConcat(hv_PersistenceParamValue));
			}
			// catch (Exception) 
			catch (HException &HDevExpDefaultException)
			{
				HDevExpDefaultException.ToHTuple(&hv_Exception);
				// stop(...); only in hdevelop
			}
		}
		//
		//Compute the output pose
		GetMessageTuple(hv_Parameters, "gIsSinglePose", &hv_gIsSinglePose);
		if (0 != hv_gIsSinglePose)
		{
			hv_PoseOut = hv_Poses.TupleSelectRange(0, 6);
		}
		else
		{
			hv_PoseOut = hv_Poses;
		}
		//
		//Clean up
		SetSystem("clip_region", hv_ClipRegion);
		// dev_set_preferences(...); only in hdevelop
		// dev_set_preferences(...); only in hdevelop
		dump_image_output(ho_Image, hv_Parameters, hv_WindowHandleBuffer, hv_Scene3D,
			hv_AlphaOrig, hv_ObjectModel3D, hv_GenParamName, hv_GenParamValue, hv_CamParam,
			hv_Poses, hv_ColorImage, hv_Title, HTuple(), hv_Label, 0, "false", hv_TrackballCenterRow,
			hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject, hv_WindowCenteredRotation,
			hv_TBCenter, hv_Type, hv_Message, hv_DispViewPoint, hv_ViewPoint);
		DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
		HDevWindowStack::SetActive(hv_WindowHandle);
		if (HDevWindowStack::IsOpen())
			DispObj(ho_ImageDump, HDevWindowStack::GetActive());
		CloseWindow(hv_WindowHandleBuffer);
		SetPart(hv_WindowHandle, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2);

		//Notify listener that we have terminated
		if (0 != (hv_MessageQueue != HTuple()))
		{
			CreateMessage(&hv_MessageHandle);
			SetMessageTuple(hv_MessageHandle, "type", "done");
			EnqueueMessage(HTuple(hv_MessageQueue[2]), hv_MessageHandle, HTuple(), HTuple());
		}
	}
	// catch (Exception) 
	catch (HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		if (0 != (HTuple(HTuple(hv_Exception[0]) == 2454).TupleOr(HTuple(hv_Exception[0]) == 5100)))
		{
			//Handle was already cleared -> indicates that the window was closed (by the user)
			//Abort gracefully.
			return;
		}
		else
		{
			//Unknown / Unexpected exception
			throw HException(hv_Exception);
		}
	}

	return;
}

// Short Description: Display continue button and wait for user to click it 
void wait_continue_button(HTuple hv_WindowHandle)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Row1, hv_Column1, hv_WinWidth, hv_WinHeight;
	HTuple  hv_Ascent1, hv_Descent1, hv_TextWidth, hv_TextHeight;
	HTuple  hv_ButtonRow, hv_ButtonCol, hv_Row, hv_Column, hv_Button;
	HTuple  hv_Exception;

	//Wait for the user to click the exit button
	GetWindowExtents(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_WinWidth, &hv_WinHeight);
	GetStringExtents(hv_WindowHandle, "Continue", &hv_Ascent1, &hv_Descent1, &hv_TextWidth,
		&hv_TextHeight);
	hv_ButtonRow = (hv_WinHeight - hv_TextHeight) - 20;
	hv_ButtonCol = (hv_WinWidth - hv_TextWidth) - 30;
	disp_text_button(hv_WindowHandle, "Continue", "window", hv_ButtonRow, hv_ButtonCol,
		"black", "#f28f26");
	while (0 != 1)
	{
		try
		{
			GetMposition(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Button);
			if (0 != (HTuple(HTuple(hv_Button != 0).TupleAnd(hv_Row >= hv_ButtonRow)).TupleAnd(hv_Column >= hv_ButtonCol)))
			{
				break;
			}
		}
		// catch (Exception) 
		catch (HException &HDevExpDefaultException)
		{
			HDevExpDefaultException.ToHTuple(&hv_Exception);
			if (0 != (HTuple(HTuple(hv_Exception[0]) == 2454).TupleOr(HTuple(hv_Exception[0]) == 5100)))
			{
				//Handle was already cleared -> indicates that the window was closed (by the user)
				//Abort gracefully.
				return;
			}
			else if (0 != (HTuple(hv_Exception[0]) == 5))
			{
				//Ignore -> mouse outside of window
			}
			else
			{
				//Unknown / Unexpected exception
				//Ignore for now
			}
		}
		WaitSeconds(0.01);
	}
	return;
}

void write_note(HTuple hv_WindowHandle, HTuple hv_Type, HTuple hv_String)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_Strings, hv_Row, hv_Column, hv_WinWidth;
	HTuple  hv_WinHeight, hv_Pos, hv_Ascent, hv_Descent, hv_Width;
	HTuple  hv_Height, hv_SubStrings, hv_Num, hv_CurrTestString;
	HTuple  hv_Index;

	hv_Strings.Clear();
	hv_Strings[0] = "              ";
	hv_Strings[1] = "[INSTRUCTION] ";
	hv_Strings[2] = "[OK         ] ";
	hv_Strings[3] = "[WARNING    ] ";
	hv_Strings[4] = "[INFO       ] ";
	hv_Strings[5] = "[ERROR      ] ";

	if (0 != (hv_Type == HTuple("Title")))
	{

	}
	if (0 != (hv_Type == HTuple("none")))
	{
		WriteString(hv_WindowHandle, HTuple(hv_Strings[0]));
		SetColor(hv_WindowHandle, "white");
	}
	else if (0 != (hv_Type == HTuple("instruction")))
	{
		SetColor(hv_WindowHandle, "cornflower blue");
		WriteString(hv_WindowHandle, HTuple(hv_Strings[1]));
		SetColor(hv_WindowHandle, "light steel blue");
	}
	else if (0 != (hv_Type == HTuple("ok")))
	{
		SetColor(hv_WindowHandle, "green");
		WriteString(hv_WindowHandle, HTuple(hv_Strings[2]));
		SetColor(hv_WindowHandle, "#AAFFAA");
	}
	else if (0 != (hv_Type == HTuple("warning")))
	{
		SetColor(hv_WindowHandle, "yellow");
		WriteString(hv_WindowHandle, HTuple(hv_Strings[3]));
		SetColor(hv_WindowHandle, "#FFFF00");
	}
	else if (0 != (hv_Type == HTuple("info")))
	{
		SetColor(hv_WindowHandle, "white");
		WriteString(hv_WindowHandle, HTuple(hv_Strings[4]));
	}
	else if (0 != (hv_Type == HTuple("error")))
	{
		SetColor(hv_WindowHandle, "red");
		WriteString(hv_WindowHandle, HTuple(hv_Strings[5]));
		SetColor(hv_WindowHandle, "#FFAAAA");
	}
	else
	{
		// stop(...); only in hdevelop
	}

	//Break into lines such that
	//"[SomeInfo]  Text" does not overflow
	GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_WinWidth, &hv_WinHeight);
	hv_Pos = 0;
	while (0 != (hv_Pos<(hv_String.TupleLength())))
	{
		GetStringExtents(hv_WindowHandle, HTuple(hv_Strings[0]) + HTuple(hv_String[hv_Pos]),
			&hv_Ascent, &hv_Descent, &hv_Width, &hv_Height);
		if (0 != (hv_Width>(hv_WinWidth - 20)))
		{
			//Break this line!
			TupleSplit(HTuple(hv_String[hv_Pos]), " ", &hv_SubStrings);
			for (hv_Num = (hv_SubStrings.TupleLength()) - 1; hv_Num >= 1; hv_Num += -1)
			{
				hv_CurrTestString = ((hv_SubStrings.TupleSelectRange(0, hv_Num - 1)) + " ").TupleSum();
				GetStringExtents(hv_WindowHandle, HTuple(hv_Strings[0]) + hv_CurrTestString,
					&hv_Ascent, &hv_Descent, &hv_Width, &hv_Height);
				if (0 != (hv_Width>(hv_WinWidth - 20)))
				{
					continue;
				}
				else
				{
					//Split the line here
					hv_String[hv_Pos] = ((hv_SubStrings.TupleSelectRange(0, hv_Num - 1)) + " ").TupleSum();
					TupleInsert(hv_String, hv_Pos + 1, ((hv_SubStrings.TupleSelectRange(hv_Num, (hv_SubStrings.TupleLength()) - 1)) + " ").TupleSum(),
						&hv_String);
					break;
				}
			}
		}
		hv_Pos += 1;
	}

	{
		HTuple end_val56 = (hv_String.TupleLength()) - 1;
		HTuple step_val56 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val56, step_val56); hv_Index += step_val56)
		{
			if (0 != (hv_Index>0))
			{
				NewLine(hv_WindowHandle);
				WriteString(hv_WindowHandle, HTuple(hv_Strings[0]));
			}
			WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
		}
	}

	NewLine(hv_WindowHandle);
	SetColor(hv_WindowHandle, "white");

	return;
}

// Generated stubs for parallel procedure calls. Wrapped in name
// space to avoid name conflicts with actual procedure names
namespace HDevExportCpp
{
	// Parallel execution wrapper for visualize_object_model_3d_ext(...) 
	static void* _hcppthread_visualize_object_model_3d_ext(void *hcthread)
	{
		// +++ define thread context for this procedure
		HDevThread*  hcppthread = (HDevThread*)hcthread;
		try
		{
			// Input parameters
			const HTuple        &cbhv_WindowHandle = hcppthread->GetInputCtrlParamTuple(0);
			const HTuple        &cbhv_ObjectModel3D = hcppthread->GetInputCtrlParamTuple(1);
			const HTuple        &cbhv_CamParam = hcppthread->GetInputCtrlParamTuple(2);
			const HTuple        &cbhv_PoseIn = hcppthread->GetInputCtrlParamTuple(3);
			const HTuple        &cbhv_GenParamName = hcppthread->GetInputCtrlParamTuple(4);
			const HTuple        &cbhv_GenParamValue = hcppthread->GetInputCtrlParamTuple(5);
			const HTuple        &cbhv_Title = hcppthread->GetInputCtrlParamTuple(6);
			const HTuple        &cbhv_Label = hcppthread->GetInputCtrlParamTuple(7);
			const HTuple        &cbhv_Information = hcppthread->GetInputCtrlParamTuple(8);
			const HTuple        &cbhv_MessageQueue = hcppthread->GetInputCtrlParamTuple(9);
			const HTuple        &cbhv_Buttons = hcppthread->GetInputCtrlParamTuple(10);
			const HTuple        &cbhv_Type = hcppthread->GetInputCtrlParamTuple(11);
			const HTuple        &cbhv_Message = hcppthread->GetInputCtrlParamTuple(12);
			const HTuple        &cbhv_DispViewPoint = hcppthread->GetInputCtrlParamTuple(13);
			const HTuple        &cbhv_ViewPoint = hcppthread->GetInputCtrlParamTuple(14);

			// Call visualize_object_model_3d_ext
			visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam,
				cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label,
				cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message,
				cbhv_DispViewPoint, cbhv_ViewPoint);

			// Reduce reference counter of thread object
			hcppthread->Exit();
			delete hcppthread;

		}
		catch (HException& exc)
		{
			// No exceptions may be raised from stub in parallel case,
			// so we need to store this information prior to cleanup
			bool is_direct_call = hcppthread->IsDirectCall();
			// Attempt to clean up in error case, too
			hcppthread->Exit();
			delete hcppthread;
			// Propagate exception if called directly
			if (is_direct_call)
				throw exc;
		}
		return NULL;
	}

	// Parallel execution wrapper for set_edge_parameter_sliders(...) 
	static void* _hcppthread_set_edge_parameter_sliders(void *hcthread)
	{
		// +++ define thread context for this procedure
		HDevThread*  hcppthread = (HDevThread*)hcthread;
		try
		{
			// Input parameters
			const HTuple        &cbhv_WindowHandle = hcppthread->GetInputCtrlParamTuple(0);
			const HTuple        &cbhv_ObjectModel3D = hcppthread->GetInputCtrlParamTuple(1);
			const HTuple        &cbhv_MesageQueues = hcppthread->GetInputCtrlParamTuple(2);
			const HTuple        &cbhv_MessageQueueOut = hcppthread->GetInputCtrlParamTuple(3);
			const HTuple        &cbhv_ModelDiameter = hcppthread->GetInputCtrlParamTuple(4);
			const HTuple        &cbhv_AmplitudeRange = hcppthread->GetInputCtrlParamTuple(5);
			const HTuple        &cbhv_MaxGapRange = hcppthread->GetInputCtrlParamTuple(6);
			const HTuple        &cbhv_Viewpoint = hcppthread->GetInputCtrlParamTuple(7);

			// Output parameters
			HTuple        cbhv_MinAmplitude;
			HTuple        cbhv_MaxGap;

			// Call set_edge_parameter_sliders
			set_edge_parameter_sliders(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_MesageQueues,
				cbhv_MessageQueueOut, cbhv_ModelDiameter, cbhv_AmplitudeRange, cbhv_MaxGapRange,
				cbhv_Viewpoint, &cbhv_MinAmplitude, &cbhv_MaxGap);

			// Store output parameters in thread object
			hcppthread->StoreOutputCtrlParamTuple(0, cbhv_MinAmplitude);
			hcppthread->StoreOutputCtrlParamTuple(1, cbhv_MaxGap);

			// Reduce reference counter of thread object
			hcppthread->Exit();
			delete hcppthread;

		}
		catch (HException& exc)
		{
			// No exceptions may be raised from stub in parallel case,
			// so we need to store this information prior to cleanup
			bool is_direct_call = hcppthread->IsDirectCall();
			// Attempt to clean up in error case, too
			hcppthread->Exit();
			delete hcppthread;
			// Propagate exception if called directly
			if (is_direct_call)
				throw exc;
		}
		return NULL;
	}

}

#ifndef NO_EXPORT_MAIN
// Main procedure 

inline double deg2rad(double val)
{
	return PI * val / 180.0;
}

Eigen::Matrix4d compute_pose(const std::string &scene_file, const std::string &reference_model_file, double rel_sampling_distance, double keypoint_fraction)
{

	// Local iconic variables
	HObject  ho_EmptyObject;

	// Local control variables
	HTuple  hv_ReferenceModelPath, hv_ScenePath, hv_ReferenceModelRaw;
	HTuple  hv_RefStatus, hv_SceneModelRaw, hv_SceneStatus;
	HTuple  hv_ReferenceModel, hv_SceneModel, hv_ReferenceSurfaceModel;
	HTuple  hv_WindowHandle, hv_Instructions, hv_Message, hv_PoseOut;
	HTuple  hv_PoseOut2, hv_T0, hv_Pose, hv_Score, hv_SurfaceMatchingResultID;
	HTuple  hv_T1, hv_CreateNames, hv_CreateValues, hv_FindNames;
	HTuple  hv_FindValues, hv_TimeForMatching, hv_ObjectModel3DResult;
	HTuple  hv_Index2, hv_CPose, hv_ObjectModel3DRigidTrans;
	HTuple  hv_SampledScene, hv_KeyPoints, hv_ScoreString, hv_NumResult;
	HTuple  hv_Colors, hv_Shapes, hv_Radii, hv_Indices;

	//Initialization
	dev_update_off();
	if (HDevWindowStack::IsOpen())
		ClearWindow(HDevWindowStack::GetActive());
	GenEmptyObj(&ho_EmptyObject);
	if (HDevWindowStack::IsOpen())
		CloseWindow(HDevWindowStack::Pop());

	hv_ReferenceModelPath = reference_model_file.c_str();
	
	hv_ScenePath = scene_file.c_str();

	ReadObjectModel3d(hv_ReferenceModelPath, 1, HTuple(), HTuple(), &hv_ReferenceModelRaw,
		&hv_RefStatus);
	ReadObjectModel3d(hv_ScenePath, 1, HTuple(), HTuple(), &hv_SceneModelRaw, &hv_SceneStatus);

	SampleObjectModel3d(hv_ReferenceModelRaw, "accurate", 0.002, HTuple(), HTuple(),
		&hv_ReferenceModel);
//	SampleObjectModel3d(hv_ReferenceModelRaw, "accurate_use_normals", 0.002, HTuple(), HTuple(),
//		&hv_ReferenceModel);
//	SampleObjectModel3d(hv_SceneModelRaw, "accurate_use_normals", 0.002, HTuple(), HTuple(), &hv_SceneModel);
	SampleObjectModel3d(hv_SceneModelRaw, "accurate", 0.002, HTuple(), HTuple(), &hv_SceneModel);

	//create_surface_model (ReferenceModel, 0.05, 'train_3d_edges', 'true', ReferenceSurfaceModel)
	CreateSurfaceModel(hv_ReferenceModel, 0.1, HTuple(), HTuple(), &hv_ReferenceSurfaceModel);

	SetWindowAttr("background_color", "black");
	OpenWindow(0, 0, 640, 480, 0, "visible", "", &hv_WindowHandle);
	HDevWindowStack::Push(hv_WindowHandle);
	hv_Instructions[0] = "Rotate: Left button";
	hv_Instructions[1] = "Zoom:   Shift + left button";
	hv_Instructions[2] = "Move:   Ctrl  + left button";
	hv_Message = "Surface model";
	visualize_object_model_3d(hv_WindowHandle, hv_SceneModel, HTuple(), HTuple(), HTuple(),
		HTuple(), hv_Message, HTuple(), hv_Instructions, &hv_PoseOut);
	if (HDevWindowStack::IsOpen())
		ClearWindow(HDevWindowStack::GetActive());
	hv_Message = "Ref model";
	visualize_object_model_3d(hv_WindowHandle, hv_ReferenceModel, HTuple(), HTuple(),
		HTuple(), HTuple(), hv_Message, HTuple(), hv_Instructions, &hv_PoseOut2);

	CountSeconds(&hv_T0);
	FindSurfaceModel(hv_ReferenceSurfaceModel, hv_SceneModel, rel_sampling_distance, keypoint_fraction, 0.2, "true",
		(HTuple("num_matches").Append("scene_normal_computation")), (HTuple(1).Append("mls")), &hv_Pose, &hv_Score, &hv_SurfaceMatchingResultID);
	CountSeconds(&hv_T1);

	double* pose_array = hv_Pose.ToDArr();

	Eigen::Matrix3d pose_rotation = (Eigen::AngleAxisd(deg2rad(pose_array[0]), Eigen::Vector3d::UnitX()) *
		Eigen::AngleAxisd(deg2rad(pose_array[1]), Eigen::Vector3d::UnitY()) *
		Eigen::AngleAxisd(deg2rad(pose_array[2]), Eigen::Vector3d::UnitZ()))
		.toRotationMatrix();

	Eigen::Vector3d pose_translation;
	pose_translation << pose_array[3], pose_array[4], pose_array[5];

	Eigen::Matrix4d estimated_pose = Eigen::Matrix4d::Identity();
	estimated_pose.block<3, 3>(0, 0) = pose_rotation;
	estimated_pose.block<3, 1>(0, 3) = pose_translation;

	
//	debug_find_surface_model(hv_ReferenceSurfaceModel, hv_ReferenceModel, hv_SceneModel,
//		hv_SurfaceMatchingResultID, &hv_CreateNames, &hv_CreateValues, &hv_FindNames,
//		&hv_FindValues);

	hv_TimeForMatching = (hv_T1 - hv_T0) * 1000;

	hv_ObjectModel3DResult = HTuple();

	{
		HTuple end_val39 = (hv_Score.TupleLength()) - 1;
		HTuple step_val39 = 1;
		for (hv_Index2 = 0; hv_Index2.Continue(end_val39, step_val39); hv_Index2 += step_val39)
		{
			if (0 != (HTuple(hv_Score[hv_Index2])<0.11))
			{
				continue;
			}
			hv_CPose = hv_Pose.TupleSelectRange(hv_Index2 * 7, (hv_Index2 * 7) + 6);
			RigidTransObjectModel3d(hv_ReferenceModel, hv_CPose, &hv_ObjectModel3DRigidTrans);
			hv_ObjectModel3DResult = hv_ObjectModel3DResult.TupleConcat(hv_ObjectModel3DRigidTrans);
		}
	}

	hv_Message = "Original scene points (white)";
	hv_Message[1] = "Sampled scene points (cyan)";
	hv_Message[2] = "Key points (yellow)";
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", HTuple(),
		&hv_SampledScene);
	GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "key_points", HTuple(), &hv_KeyPoints);
	if (HDevWindowStack::IsOpen())
		ClearWindow(HDevWindowStack::GetActive());

	visualize_object_model_3d(hv_WindowHandle, (hv_SceneModel.TupleConcat(hv_SampledScene)).TupleConcat(hv_KeyPoints),
		HTuple(), HTuple(), HTuple(HTuple("color_") + ((HTuple(0).Append(1)).Append(2))).TupleConcat(HTuple("point_size_") + ((HTuple(0).Append(1)).Append(2))),
		(((((HTuple("gray").Append("cyan")).Append("yellow")).Append(1.0)).Append(3.0)).Append(5.0)),
		hv_Message, HTuple(), hv_Instructions, &hv_PoseOut);

	hv_Message = "Scene: ";
	hv_Message[1] = ((HTuple(HTuple("Found ") + (hv_ObjectModel3DResult.TupleLength())) + " object(s) in ") + (hv_TimeForMatching.TupleString(".3"))) + " ms";
	hv_ScoreString = ((hv_Score.TupleString(".2f")) + " / ").TupleSum();
	//Message[2] := 'Score(s): ' + ScoreString{0:strlen(ScoreString) - 4}
	hv_NumResult = hv_ObjectModel3DResult.TupleLength();
	TupleGenConst(hv_NumResult, "green", &hv_Colors);
	TupleGenConst(hv_NumResult, "circle", &hv_Shapes);
	TupleGenConst(hv_NumResult, 3, &hv_Radii);
	hv_Indices = HTuple::TupleGenSequence(1, hv_NumResult, 1);

	if (HDevWindowStack::IsOpen())
		ClearWindow(HDevWindowStack::GetActive());
	visualize_object_model_3d(hv_WindowHandle, hv_SceneModel.TupleConcat(hv_ObjectModel3DResult),
		HTuple(), hv_PoseOut, ("color_" + (HTuple(0).TupleConcat(hv_Indices))).TupleConcat("point_size_0"),
		(HTuple("gray").TupleConcat(hv_Colors)).TupleConcat(1.0), hv_Message, HTuple(),
		hv_Instructions, &hv_PoseOut);

	return estimated_pose;
}

std::vector<std::string> read_file(std::string path)
{
	std::ifstream infile(path);
	std::vector<std::string> lines;
	std::string line;

	while (std::getline(infile, line))
	{
		lines.push_back(line);
	}

	infile.close();

	return lines;
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
	UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
	// Wait until the timer has fired to start processing.
	LockMutex(gStartMutex);
	UnlockMutex(gStartMutex);

	try
	{
		action();
	}
	catch (HException &exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char *)exception.ProcName(),
			(const char *)exception.ErrorMessage());
	}

	// Tell the main thread to terminate itself.
	LockMutex(gStartMutex);
	gTerminate = TRUE;
	UnlockMutex(gStartMutex);
	CFRunLoopStop(CFRunLoopGetMain());
	return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
	Herror                error;
	CFRunLoopTimerRef     Timer;
	CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

	CreateMutex("type", "sleep", &gStartMutex);
	LockMutex(gStartMutex);

	error = HpThreadHandleAlloc(&gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleAlloc failed: %d\n", error);
		exit(1);
	}

	error = HpThreadCreate(gActionThread, 0, apple_action);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadCreate failed: %d\n", error);
		exit(1);
	}

	Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
		CFAbsoluteTimeGetCurrent(), 0, 0, 0,
		timer_callback, &TimerContext);
	if (!Timer)
	{
		fprintf(stderr, "CFRunLoopTimerCreate failed\n");
		exit(1);
	}
	CFRunLoopAddTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);

	for (;;)
	{
		HBOOL terminate;

		CFRunLoopRun();

		LockMutex(gStartMutex);
		terminate = gTerminate;
		UnlockMutex(gStartMutex);

		if (terminate)
			break;
	}

	CFRunLoopRemoveTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);
	CFRelease(Timer);

	error = HpThreadHandleFree(gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleFree failed: %d\n", error);
		exit(1);
	}

	ClearMutex(gStartMutex);
	return 0;
}
#endif


#define SM_CHECK_PARAM_EXISTS(parser, param_name) \
             if (!parser.has(param_name)) {\
			    std::cerr << "Missing parameter: " << param_name << std::endl;\
				return false;\
			 }

#define SM_CHECK_VALID_DIR(dir) \
	if (!fs::is_directory(dir)) {\
	  std::cerr << "Invalid directory: " << dir << std::endl;\
	  return false;\
	}

#define SM_CHECK_VALID_FILE(f) \
	if (!fs::is_regular_file(f)) {\
      std::cerr << "Invalid file: " << f << std::endl;\
      return false;\
    }


bool parse_model_ids(const std::string &ids_s, std::vector<int> &model_ids)
{
	std::stringstream ids_ss(ids_s);
	try
	{
		for (int i; ids_ss >> i;) {
			model_ids.push_back(i);
			if (ids_ss.peek() == ',')
				ids_ss.ignore();
		}
	} catch (const std::exception&)
	{
		std::cerr << "Ivalid model ids: " << ids_s << std::endl;
		return false;
	}
	
	return true;
}


bool parse_configuration(int argc, char **argv, Configuration &config) {
	const std::string configuration_keys = "{ help h usage ? |          | help on usage }"
		"{ref_models_dir   |          | reference models directory}"
		"{scene_dir   |          | directory containing the scene}"
		"{model_ids |          | comma-separated model ids}"
		"{rel_smp_dist  |    0.05    | relative sampling distance}"
		"{kp_frac  |   0.4       | keypoint fraction}";

	cv::CommandLineParser parser(argc, argv, configuration_keys);

	SM_CHECK_PARAM_EXISTS(parser, "ref_models_dir");
	std::string ref_models_dir = parser.get<std::string>("ref_models_dir");

	SM_CHECK_PARAM_EXISTS(parser, "scene_dir");
	std::string scene_dir = parser.get<std::string>("scene_dir");

	SM_CHECK_PARAM_EXISTS(parser, "model_ids");
	std::string model_ids_s = parser.get<std::string>("model_ids");

	std::vector<int> model_ids;
	if (!parse_model_ids(model_ids_s, model_ids)) return false;

	SM_CHECK_PARAM_EXISTS(parser, "rel_smp_dist");
	double relative_sampling_distance = parser.get<double>("rel_smp_dist");

	SM_CHECK_PARAM_EXISTS(parser, "kp_frac");
	double keypoint_fraction = parser.get<double>("kp_frac");

	config.set_reference_models_dir(ref_models_dir);
	config.set_scene_dir(scene_dir);
	config.set_model_ids(model_ids);
	config.set_relative_sampling_distance(relative_sampling_distance);
	config.set_keypoint_fraction(keypoint_fraction);
	
	return true;
}

std::map<int, std::string> get_reference_object_files(const std::string &reference_models_dir, const std::vector<int> &model_ids)
{
	std::map<int, std::string> reference_object_files;

	for (auto model_id : model_ids)
	{
		std::stringstream filename_ss;
		filename_ss << "obj_" << std::setfill('0') << std::setw(6) << model_id << ".ply";
		const std::string filename = filename_ss.str();

		std::string out_file = (fs::path(reference_models_dir) / filename).string();
		reference_object_files[model_id] = out_file;
	}

	return reference_object_files;
}

std::map<int, Eigen::Matrix4d> estimate_poses(const std::map<int, std::string> &reference_object_files, const Configuration &config)
{
	std::map<int, Eigen::Matrix4d> poses;

	std::string scene_file = (fs::path(config.get_scene_dir()) / "model.ply").string();

	for (auto const& [model_id, model_file] : reference_object_files)
	{
		std::cout << "Estimating pose for object #" << model_id << std::endl;

		auto pose = compute_pose(scene_file, model_file, config.get_relative_sampling_distance(),
		                   config.get_keypoint_fraction());
		poses[model_id] = pose;
	}

	return poses;
}

void store_poses(const std::map<int, Eigen::Matrix4d> &object_poses, const Configuration &config)
{
	const std::string scene_dir = config.get_scene_dir();
	std::string estimated_poses_dir = (fs::path(scene_dir) / "object_poses").string();

	if (!fs::is_directory(estimated_poses_dir))
	{
		fs::create_directories(estimated_poses_dir);
	}

	for (auto const&[model_id, pose] : object_poses)
	{
		std::stringstream filename_ss;
		filename_ss << std::setfill('0') << std::setw(6) << model_id << ".txt";
		const std::string filename = filename_ss.str();

		std::string out_file = (fs::path(estimated_poses_dir) / filename).string();

		std::ofstream out_filestream;
		out_filestream.open(out_file);
		out_filestream << pose << std::endl;
		out_filestream.close();
	}
}


int main(int argc, char *argv[])
{
	int ret = 0;

	try
	{
#if defined(_WIN32)
		SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
		XInitThreads();
#endif

		// Default settings used in HDevelop (can be omitted) 
		SetSystem("width", 512);
		SetSystem("height", 512);

#ifndef __APPLE__

		Configuration config;
		if (!parse_configuration(argc, argv, config))
		{
			return 1;
		}

		auto reference_object_files = get_reference_object_files(config.get_reference_models_dir(), config.get_model_ids());
		auto estimated_object_poses = estimate_poses(reference_object_files, config);
		store_poses(estimated_object_poses, config);
		
#else
		ret = apple_main(argc, argv);
#endif
	}
	catch (HException &exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char *)exception.ProcName(),
			(const char *)exception.ErrorMessage());
		ret = 1;
	}
	return ret;
}

#endif


#endif


